ver:"3.0"
depends,func,name,src
["anAhuDuctGain","anZoneEnabled"],M,"ruReheatFailure","/*\n  This function returns a grid of periods an equip has a dyfunctional reheat\n  valve, whereby the terminal unit reheat command is 90% or more but DAT is low.\n  Based on a given minimum differential, default 10°F, above AHU SAT + estimated\n  duct gain.\n  \n  Arguments:\n  equip           equip record of equip to test\n  span            dateSpan, span of dates to run analysis on\n  minDiffTemp     number in °F, minimum target temp differential between\n                  measured discharge air temp and estimated entering air temp\n  minrh           number in %, default 90%, above which valve position is considered\n                  fully open\n  rhDelay         allowed time delay for heating coil to warm up after 100% cmd\n  minTime         duration, filter out periods shorter than minTime\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n  zoneEnabledOnly Bool, if true filter out periods when anZoneEnabled\n                  period is False / Off\n  enMinAirflowSp  Minimum airlfow setpoint to consider zone controls are\n                  enabled.\n  \n  // kW Engineering // RGV // Last Update: 2020-01-08 //\n*/\n\n(equip:readById(@p:lbnl:r:2324cceb-e30a4c1a), span:pastWeek(),\n minDiffTemp: 5°F, minrh: 90%, rhDelay: 90min, minTime: 30min,\n mergePeriod: 15min, zoneEnabledOnly:false, enMinAirflowSp: 50cfm) => do\n  // Params: syncDelay allows buffer in case reheat valve position\n  // is trended at 15min and DAT is trended at 5min\n  syncDelay: 15min\n  \n  dat: read(discharge and air and temp and sensor and equipRef==equip->id,\n            false)\n  rh: read(heat and valve and cmd and equipRef==equip->id, false)\n    \n  // Retrieve occupied command if occOnly is true\n  zone: if(equip.has(\"zone\")) equip\n        else if(equip.has(\"equipRef\")) readById(equip->equipRef)\n        else null\n  zoneEn: if (zone!= null and zoneEnabledOnly)\n            anZoneEnabled(zone->id, span, enMinAirflowSp)\n          else null\n  \n  // If DAT is missing, return null\n  if (dat==null) return null\n  \n  // If terminal unit has no reheat valve cmd, return null\n  if (rh==null) return null\n\n  // Period is valid only when reheat valve has been fully open\n  // for at least rhDelay\n  extSpan: span.toDateSpan().start-1day..span.toDateSpan().end+1day\n  fullrh: rh.hisRead(extSpan, {limit: null})\n            .hisFindPeriods(v => v > minrh)\n            .hisPeriodShift(rhDelay, -syncDelay)\n  \n  // Estimate duct heat gain for related AHU\n  if (not(readById(equip->id).has(\"ahuRef\"))) return null\n  ahuId: equip->ahuRef\n  heatGain: anAhuDuctGain(ahuId, span, rhDelay)\n  if (heatGain==null) return null\n\n  // Load AHU SAT and TU DAT history, and flag when DAT < SAT + DHG + minDiffTemp\n  // and reheat valve has been fully open or nearly so (fullrh period)\n  sat: read(discharge and air and temp and sensor and equipRef==ahuId,\n            false)\n  // If AHU SAT is missing, return null\n  if (sat==null) return null \n  \n  datHis: dat.hisRead(span, {limit: null}).renameCol(\"v0\",\"dat\")\n  eatHis: sat.hisRead(span, {limit: null})\n             .addCol(\"eat\", row => row->v0 + heatGain)\n             .keepCols([\"ts\",\"eat\"])\n  \n  // Join trends, interpolate, filter out reheat periods\n  flagPeriods: hisJoin([datHis, eatHis])\n      .hisInterpolate()\n      .hisFindInPeriods(fullrh)\n\n  // Filter out unoccupied periods if occ is avilable\n  if (zoneEn != null)\n    flagPeriods= flagPeriods.hisFindInPeriods(zoneEn)\n\n  // Detect DAT < EAT + minDiffTemp\n  flagPeriods= flagPeriods\n      .addCol(\"flag\", row => if (row.has(\"dat\") and row.has(\"eat\"))\n                               row->dat < row->eat + minDiffTemp\n                             else\n                               null)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindPeriods(flag => if (flag != null) flag else false)\n  \n  // Re-filter to avoid last TRUE lasting until midnight\n  flagPeriods= hisPeriodIntersection([flagPeriods, fullrh])\n  \n  // Filter out unoccupied periods again, if occ is avilable\n  if (zoneEn != null)\n    flagPeriods= hisPeriodIntersection([flagPeriods, zoneEn])\n\n  // Rename cols after hisPeriodIntersection\n  flagPeriods= flagPeriods.renameCol(\"v0\",\"flag\")\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip.dis() + \" has leaky reheat valve or miscalibrated DAT sensor\"\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})\nend\n"
[],M,"toolHisAlign","/*\n  Process a history grid to align timestamps of contained histories,\n  for example in preparation for a foldCols. Determine average interval\n  for each history, then select a target interval for hisRollup. Rollup\n  using given rollupFunc. Process missing (null) values based on selected\n  option. NA values are propagated. Options for null values:\n  - Show missing values with NA\n  - Remove rows with any missing values\n  If any column / trend is COV with hisMode:\"cov\" tag, return original\n  grid if minRollup is 0, or apply hisRollup at provided minRollup.\n  \n  Arguments:\n  hisGrid          History grid to process\n  rollupFunc       Func, function used for rollup\n  intervalFunc     Func, (x,y) function used to select rollup interval\n  removeMissing    Bool, if true, remove rows with any null values,\n                   else replace all null values with NA\n  minRollup        Number (time), specify minimum rollup time\n  validIntervals   List of Numbers (time), valid rollup intervals\n\n  // kW Engineering // RGV // Last Update: 2020-01-21 //\n*/\n\n(hisGrid, rollupFunc:avg, intervalFunc:min,\n removeMissing:true, minRollup:0min,\n validIntervals:[1s, 2s, 5s, 10s, 15s, 30s,\n                 1min, 2min, 3min, 5min, 10min, 15min, 30min,\n                 1hr, 2hr, 6hr, 12hr, 24hr]) => do\n  // Initialize\n  interval: null\n  covFlag: false\n  minRollup= try minRollup.to(\"s\") catch 0s\n  \n  // Cycle through each column and determine corresponding\n  // average interval\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    subHisGrid: hisGrid.keepCols([\"ts\"].add(colName))\n                       .hisClip\n                       .findAll(row => row[colName] != null)\n    if (subHisGrid.size < 2) return null\n    tsList: subHisGrid.colToList(\"ts\")\n    avgInterval: (tsList[-1] - tsList[0]) / (tsList.size - 1)\n    avgInterval= avgInterval.to(\"s\")\n    // Check metadata for hisMode==cov\n    if (subHisGrid.col(colName).meta[\"hisMode\"]==\"cov\")\n      covFlag= true\n    // Apply intervalFunc selection function\n    interval= if (interval==null) avgInterval\n              else intervalFunc(interval, avgInterval)\n  end\n  // If minRollup > 0, apply to interval\n  if (minRollup > 0) interval= max(interval, minRollup)\n  \n  // If some histories are COV and minRollup is specified,\n  // simply rollup at minRollup\n  if (covFlag and minRollup > 0)\n    hisGrid= hisGrid.hisRollup(rollupFunc, minRollup)\n  // Else if any history is COV and minRollup isn't specified, or if\n  // no interval was found do not rollup\n  else if (covFlag or interval==null or interval==0)\n    hisGrid= hisGrid\n  // Else select closest valid interval from validIntervals and rollup\n  else do\n    distF: (x,y) => abs(x.to(\"s\") - y.to(\"s\")).as(1)\n    finalInterval: validIntervals\n      .sort((a,b) => distF(a,interval) <=> distF(b,interval))\n      .first\n    \n    // Perform rollup\n    hisGrid= hisGrid.hisRollup(rollupFunc, finalInterval)\n  end\n  \n  // Process missing data\n  if (removeMissing)\n    hisGrid= hisGrid.findAll(row => row.all(v => v != null))\n  else // Show missing values with NA\n    hisGrid= hisGrid.hisMap(v => if (v==null) na() else v)\n\n  return hisGrid\nend\n"
["toolRecursiveSearch"],M,"toolRecursiveSearch","/*\n\n  Find all records that match the given filter string and that have\n  an equipRef (or other specified ref) located at or below the given\n  equipRef (called trunkRef)\n  e.g. allows to find all the power sensors in a high-level equipment\n  such as a cooling tower, even if the power sensors are located\n  under the cooling tower fans.\n  \n  Example use:\n  toolRecursiveSearch(@p:lbnl:r:2322ffa1-a7bd7110, \"power and sensor\")\n  \n  Return grid similar to readAll\n  \n  Arguments: \n  trunkRef         Ref to an equip to search under\n  filterStr        String that will be parsed as filter\n  refTypes         List of strings, refs to follow (e.g. equipRef)\n  maxDepth         Number, stop after given number of iterations\n\n  // kW Engineering // RGV // Last Update: 2019-05-23 //\n\n*/\n\n(trunkRef, filterStr: \"point\", refTypes:[\"equipRef\", \"zoneRef\"],\n maxDepth:10) => do\n  filterStrLoc: \"(\" + filterStr + \") and equipRef->id==@\" + toStr(trunkRef)\n  grid: readAll(parseFilter(filterStrLoc))\n  \n  // Find other equips pointing to current trunkRef\n  eqRefsStr: refTypes.map(v => v+\"==\"+trunkRef).concat(\" or \")\n  eqFilterStr: \"equip and \" + eqRefsStr\n  eqList: readAll(equip and equipRef==trunkRef)\n  if (isEmpty(eqList) or maxDepth==0) return grid\n  else do\n    eqList.each subeq => do\n      newRows: toolRecursiveSearch(subeq->id, filterStr, refTypes, maxDepth-1)\n      if (not(isEmpty(newRows))) grid = grid.addRows(newRows)\n    end\n  end\n  return grid\nend\n"
[],M,"anAhuDuctGain","/*\n\n  Review data from all terminal units served by a given AHU and returns\n  the estimated duct heat gain as one value for the entire period.\n  The heat gain is first calcualted over time, based on the 10th percentile\n  of observed zone DATs for zones not actively reheating (percentile allows\n  for a few DAT sensors reading too low). The global heat gain for the\n  period is then calculated as the 80th percentile heat gain in that period.\n \n  Arguments: \n  ahuId      id of ahu to analyze\n  span       dates to analyze\n  rhDelay    allowed time delay for residual heat to leave heat coil\n  pctSensor  percentile used, for each time stamp, to select a DAT\n             default 10\n  pctTime    percentile used to select the resulting period-wide heat gain\n             default 80\n  \n  // kW Engineering // RGV // Last Update: 2018-09-20 //\n\n*/\n\n(ahuId: read(ahu and equip and siteRef->dis==\"67\" and navName==\"AHU-01\")->id,\n span:yesterday(), rhDelay: 90min, pctSensor: 10, pctTime: 80) => do\n  // Load SAT history, return null if SAT is missing\n  sat: read(discharge and air and temp and sensor\n            and equipRef==ahuId,false)\n  if (sat == null) return null\n  sat= sat.hisRead(span, {limit: null})\n       \n  if (sat.foldCol(\"v0\",count) < 2) return 0°F\n \n  // Find all terminal units served by AHU\n  tus: readAll(terminalUnit and equip and ahuRef==ahuId)\n  \n  // Cycle through terminal units, and for each return valid DAT data\n  // for periods when the RH valve has been closed long enough\n  eats: tus.map(tu => do\n    dat: read(discharge and air and temp and sensor and equipRef==tu->id,\n              false)\n    rh: read(heat and valve and cmd and equipRef==tu->id,\n             false)\n    \n    // If DAT is missing, skip\n    if (dat==null) return null\n    // If terminal unit has reheat coil but valve cmd is missing, skip\n    if (rh==null and tu.has(\"hotWaterHeat\")) return null\n    \n    // If terminal unit has no reheat, then entire period is valid\n    if (rh==null) norh: dat.hisRead(span, {limit: null})\n                           .hisFindPeriods(v => true)\n    // Otherwise, period is valid only when reheat valve has been closed\n    // for at least rhDelay\n    else do\n      extSpan: span.toDateSpan().start-1day..span.toDateSpan().end+1day\n      norh: rh.hisRead(extSpan, {limit: null})\n              .hisFindPeriods(v => v == 0%)\n              .hisPeriodShift(rhDelay, 0min)\n    end\n    \n    datHis: dat.hisRead(span, {limit: null})\n    if (datHis.foldCol(\"v0\",count) < 2) return null\n    \n    eat: hisJoin([datHis, sat])\n            .hisInterpolate()\n            .keepCols([\"ts\",\"v0\"])\n            .hisFindInPeriods(norh)\n            .addMeta({forceConst})\n\n    return {eat: eat}\n  end)\n  \n  // Combine all valid zone DATs into one grid\n  eats= hisJoin(eats.colToList(\"eat\"))\n  \n  // Select for each timestamp a DAT based on percentile\n  min: eats.addCol(\"selected\", row => do\n               vals: row.findAll((v,n) => n != \"ts\" and v != null).vals\n               sz: vals.size\n               if(sz > 1) vals.sort()[round(sz * pctSensor / 100)]\n               else null\n           end)\n           .keepCols([\"ts\",\"selected\"])\n           .addColMeta(\"selected\", {dis: \"DAT, no reheat\",\n                              chartType: \"scatter\",\n                              chartGroup: \"temps\",\n                              chartMin: 50°F,\n                              chartMax: 100°F,\n                              strokeWidth: 1})\n \n  sat= sat.addColMeta(\"v0\", {chartGroup: \"temps\",\n                             chartMin: 50°F,\n                             chartMax: 100°F,\n                             strokeWidth: 5})\n  \n  // Calculate difference between SAT and the selected DAT\n  temps: hisJoin([sat, min]).addCol(\"diff\", row => row[\"selected\"] - row[\"v0\"])\n  \n  // Based on percentile, return one heat gain value\n  gains: temps.colToList(\"diff\").findAll(v => v != null)\n  samples: gains.size\n  \n  if (samples > 1)\n    return max(0, gains.sort()[floor(samples * pctTime / 100)])\n  else\n    return null\nend\n"
["toolHisAlign","toolRecursiveSearch"],M,"anZoneEnabled","/*\n  For a given zone, review available trends for the given period and return a period trend\n  that shows when the zone controls are considered enabled.\n  \n  Zone controls are considered disabled if:\n  Occupied Mode exists and is False\n  OR Supply Airflow Setpoint exists and is less than airflowSetpointMin, default 10 cfm\n  OR Supply Airflow exists and is less than airflowSetpointMin, default 10 cfm\n  OR Window Switch exists and is True\n  \n  Conversely, zone controls are considred enabled if:\n  Occupied Mode is True or does not exist\n  AND Supply Airflow Septoint is equal to or above the airflowSetpointMin or does not exist\n  AND Supply Airflow is equal to or above the airflowSetpointMin or does not exist\n  AND Window Switch is False or does not exist\n  \n  \n  Arguments: \n  zoneRef            Reference of zone equip\n  dates              Span, dates to run analysis on\n  airflowSetpointMin Number in CFM below which the setpoint is considered to be zero,\n                     default 10 cfm\n  rollup             Time interval to use for rollup, default 15min\n\n  // kW Engineering // RGV // Last Update: 2020-01-07 //\n*/\n\n(zoneRef: @p:lbnl:r:22756fdf-411ba8fd, dates: pastWeek(),\n airflowSetpointMin: 10cfm, rollup:15min) => do\n  // Check / convert inputs\n  airflowSetpointMin= airflowSetpointMin.as(\"cfm\")\n \n  // Retrieve zone record\n  zone: readById(zoneRef)\n  \n  // Check that provided reference is for a zone equip\n  if (not(zone.has(\"zone\")))\n    return null\n  \n  // Retrieve needed values and points\n  saSps: toolRecursiveSearch(zoneRef,\n    \"point and equipRef->supply and air and flow and effective and sp\")\n  saSensor: toolRecursiveSearch(zoneRef,\n    \"point and equipRef->supply and air and flow and sensor\")\n  occModes: toolRecursiveSearch(zoneRef, \"point and occupied and zone and cmd\")\n  windowSwitches: toolRecursiveSearch(zoneRef, \"point and windowSwitch and sensor\")\n  \n  // Supplay airflow setpoint test\n  sspT: if (isEmpty(saSps))\n             hisSlidingWindows(dates, 24hr, 24hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF SP not found\"})\n        else saSps\n             .hisRead(dates, {limit:null})\n             .toolHisAlign(avg, min)\n             .hisFoldCols(sum)\n             .hisFindPeriods(v => v!= na() and v != null and v >= airflowSetpointMin)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF SP >= \"+airflowSetpointMin})\n\n  // Measured supplay airflow  test\n  safT: if (isEmpty(saSensor))\n             hisSlidingWindows(dates, 24hr, 24hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF sensor not found\"})\n        else saSensor\n             .hisRead(dates, {limit:null})\n             .toolHisAlign(avg, min)\n             .hisFoldCols(sum)\n             .hisFindPeriods(v => v!= na() and v != null and v >= airflowSetpointMin)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF sensor >= \"+airflowSetpointMin})\n\n  // Occupied mode test\n  occT: if (isEmpty(occModes))\n             hisSlidingWindows(dates, 24hr, 24hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" Occ mode not found\"})\n        else do \n          occPeriods: []\n          occModes.each(occMode => occPeriods= occPeriods\n                                   .add(occMode\n                                        .hisRead(dates, {limit:null})\n                                        .hisFindPeriods(v => v)))\n          occPeriods.hisPeriodUnion()\n                    .addColMeta(\"v0\", {dis:zone.dis()+\" Occupied mode\"})\n        end\n             \n  // Window closed switch test\n  wdcT: if (isEmpty(windowSwitches))\n             hisSlidingWindows(dates, 24hr, 24hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" Window switch not found\"})\n        else do \n          wdcPeriods: []\n          windowSwitches.each(wdcS => wdcPeriods= wdcPeriods\n                                      .add(wdcS\n                                           .hisRead(dates, {limit:null})\n                                           .hisFindPeriods(v => not(v))))\n          wdcPeriods.hisPeriodUnion()\n                    .addColMeta(\"v0\", {dis:zone.dis()+\" Window closed\"})\n        end\n  \n  // Combine all tests\n  return hisPeriodIntersection([sspT, safT, occT, wdcT])\n         .addColMeta(\"v0\", {dis:zone.dis()+\" Zone controls enabled\"})\n         .addMeta({view:\"chart\"})\nend\n"
