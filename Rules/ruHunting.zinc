ver:"3.0"
depends,dis,func,help,name,ruleOn,src
["anHunting"],"Valve Hunting",M,"Valve command rate of change exceeded a given threshold (default 5%/min) for longer than a given time period (default 30min)","ruValveHunting","terminalUnit","(equip, dates, maxChangePerMinute: 5%, mergePeriod: 30min, minTime: 30min) => do\n  // Get valve cmd point, return null if not found\n  valve: read(point and valve and cmd and equipRef==equip->id, false)\n  if (valve == null) return null\n  \n  // Get history data, and use exterior function anHunting\n  data: valve.hisRead(dates, {limit: null})\n  if (isEmpty(data)) return null\n  \n  // Sparks from returned periods\n  sparks: anHunting(data, maxChangePerMinute, mergePeriod, minTime)\n  \n  if (sparks==null or isEmpty(sparks)) return null\n  else return sparks\n\n end"
[],,M,,"anHunting",,"/*\n\n  Analyze a history grid and find periods of hunting, defined as periods\n  of at least minTime during which the rate of change is consistently\n  greater than maxChangePerMinute.\n  Return grid with periods of hunting.\n  \n  Arguments: \n  hisGrid            Grid of history data, with ts and v0 columns (others ignored)\n                     values should be percentages beteen 0% and 100%\n  maxChangePerMinute Allowed rate of change, default 5% (per minute)\n  mergePeriod        Merge sparks that are less than mergePeriod apart, default 30min\n  minTime            Minimum hunting time to be reported, default 30min\n\n  // kW Engineering // RGV // Last Update: 2018-07-12 //\n\n*/\n\n(hisGrid, maxChangePerMinute: 5%, mergePeriod: 30min, minTime: 30min) => do\n  // Check that history is in %, otherwise return null\n  if (not hisGrid.has(\"v0\") or not hisGrid.col(\"v0\").meta.has(\"unit\")\n      or hisGrid.col(\"v0\").meta->unit != \"%\")\n    return null\n\n  // Remove unit from maxChangePerMinute for threshold to avoid unit issues\n  threshold: maxChangePerMinute.as(1)\n\n  // Initialize prev, previous values\n  prev: {ts: null, v0: null}\n  \n  // Calculate rate of change for hisGrid\n  rateGrid: hisGrid.map row => do\n    if (prev[\"ts\"] == null or prev[\"v0\"] == null) do\n      prev = {ts: row->ts, v0: row->v0}\n      return {ts: null, v0: null}\n    end else if (row->v0 == na()) do\n      // Return a row with na() as value, but do not change previous values\n      return {ts: row->ts, v0: row->v0}\n    end else if (prev->v0 == na()) do\n      // Return a row with na() as value, and change previous values\n      prev = {ts: row->ts, v0: row->v0}\n      return {ts: row->ts, v0: na()}\n    end else do\n      rChange: abs((row->v0 - prev->v0) / (row->ts - prev->ts).to(1min))\n      prev = {ts: row->ts, v0: row->v0}\n      return {ts: row->ts, v0: rChange}\n    end\n  end\n  // Remove null values, typically just leading row\n  .findAll(row => row[\"ts\"] != null and row[\"v0\"] != null)\n  // Remove na() values, corresponding to issues not related to this rule\n  .findAll(row => row[\"v0\"] != na())\n  \n  // Apply theshold\n  huntPeriods: rateGrid.hisFindPeriods v => v > threshold\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  huntPeriods = hisPeriodShift(huntPeriods, -mergePeriod/2, mergePeriod/2)\n  huntPeriods = hisPeriodShift(huntPeriods, mergePeriod/2, -mergePeriod/2)\n  huntPeriods = huntPeriods.findAll(r => r->v0 >= minTime)\n  \n  if (isEmpty(huntPeriods)) return null\n  \n  dis: huntPeriods.col(\"v0\").meta->navName + \" is hunting\"\n  return huntPeriods.addColMeta(\"v0\", {dis: dis})\nend\n"
["anHunting"],"Damper Hunting",M,"Damper command rate of change exceeded a given threshold (default 5%/min) for longer than a given time period (default 30min)","ruDamperHunting","terminalUnit","(equip, dates, maxChangePerMinute: 5%, mergePeriod: 30min, minTime: 30min) => do\n  // Get damper cmd point, return null if not found\n  damper: read(point and damper and cmd and equipRef==equip->id, false)\n  if (damper == null) return null\n  \n  // Get history data, and use exterior function anHunting\n  data: damper.hisRead(dates, {limit: null})\n  if (isEmpty(data)) return null\n  \n  // Sparks from returned periods\n  sparks: anHunting(data, maxChangePerMinute, mergePeriod, minTime)\n  \n  if (sparks==null or isEmpty(sparks)) return null\n  else return sparks\n\n end"
