ver:"3.0"
apply,depends,dependsFiles,dis,foldOn,func,help,hisSrc,import,kpiOn,kwe,name,regModel,ruleOn,src,viewRef,virtual
,["psySaturationPressure","psyHumidityRatio","psyHumidityRatioPw"],,,,M,,,,,,"psyWetBulb",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate wet bulb temperature, return result in °F\n  \n  Arguments (unit conversions applied as first step):        \n  tempDryBulb         Dry bulb temperature [°F]\n  tempDewPoint        Dew point temperature [°F]\n  ambientPressure     Ambient Pressure [mbar]\n    \n  Uses Newton-Rhapson iteration\n*/\n\n(tempDryBulb, tempDewPoint, ambientPressure) => do\n  // Parameters\n  maxTries: 100\n  accuracyThreshold: 0.001%\n  result: tempDryBulb  // Initial test value\n  \n  // Apply conversions\n  tempDryBulb = tempDryBulb.to(\"°C\")\n  tempDewPoint = tempDewPoint.to(\"°C\")\n  ambientPressure = ambientPressure.to(\"kPa\")\n  \n  // Calculate intermediary properties\n  satVaporPressureDewPoint: psySaturationPressure(tempDewPoint)\n  humidityRatio: psyHumidityRatioPw(satVaporPressureDewPoint, ambientPressure)\n  \n  // Solve to within accuracy_threshold using Newton-Raphson.\n  // Remove units for calculation (using gH₂O/kgAir)\n  humidityRatio = humidityRatio.as(1)\n  humidityRatioTest: psyHumidityRatio(tempDryBulb, result, ambientPressure).as(1)\n  humidityRatioTest2: 0\n  acc: 0\n  \n  maxTries.times i => do\n    if (abs((humidityRatioTest - humidityRatio)/humidityRatio) <= accuracyThreshold) return i //do tempWetBulb = result end\n    humidityRatioTest2 = psyHumidityRatio(tempDryBulb, result - 0.001, ambientPressure).as(1)\n    result = result - (humidityRatioTest - humidityRatio) / (humidityRatioTest - humidityRatioTest2) * 0.001\n    humidityRatioTest = psyHumidityRatio(tempDryBulb, result, ambientPressure).as(1)\n    acc = acc + 1\n  end\n  \n  // Discard result if all iterations were used (accuracy likely not achieved)\n  if (acc < maxTries) tempWetBulb: result\n  else tempWetBulb: null\n  \n  tempWetBulb.to(\"°F\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"scrapeDentMeterNew",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// readAll DENT equip\n\n// for each DENT equip:\n\n  // get device name (navName?)\n  // using that device name, get the csv\n  // convert csv dates from str to dateTime (in a map)\n  // get *earliest* hisEnd of the points (readAll points under that equip)\n  // delete all rows earlier than earliest hisEnd\n  // convert csv from str to val (in a map)\n  // get channel (equip->channel)\n  // write those channels to appropriate points\n  \n() => do\n\"Hello world\"\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ahuCoolandEcon",,,"(ahu, dates, minTime: 0min) => do\n\n// normalize minTime to hours\n  minTime = minTime.to(1h)\n\n  // get periods when cooling and heating\n  cool: read(cool and cmd and valve and equipRef==ahu->id).hisRead(dates).hisFindPeriods(x => x > 10)\n  \n  // \n  econ: readAll(outside and damper and cmd and unit and not minVal and equipRef==ahu->id).hisRead(dates).hisFindPeriods(x => x > 0)\n\n  // compute intersection of those periods\n  hisPeriodIntersection([cool, econ])\n    .findAll(r => r->v0 >= minTime)\n end\n",,
,["toolHisAlign"],,,,M,,,,,,"viAhuZoneDampers",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, load supply damper positions for all TUs\n  served by that AHU then display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), rollup: 15min, colors: \"green, red\") => do\n  pts: readAll(damper and cmd\n               and equipRef->supply and equipRef->terminalUnit\n               and equipRef->ahuRef==ahuRef)\n               \n  if(isEmpty(pts)) return null\n  \n  try do\n    pos: pts.hisRead(dates, {limit:null})\n    \n    if (rollup>0)\n      pos= pos.hisRollup(avg, rollup)\n    else\n      pos= pos.toolHisAlign(avg, max)\n    \n    pos=pos.hisFlatten((val, ts, his) => do\n        eq: readById(his->equipRef)\n        room: if (eq.has(\"equipRef\"))\n                readById(eq->equipRef)\n              else\n                eq\n        dis: if (readAll(supply and terminalUnit and equipRef==room->id).size >= 2)\n               room->navName + \" \" +\n               reGroups(\"\"\"(Supply,? )?(.*)\"\"\", eq->navName)[2]\n             else room->navName\n        {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n         rm: dis,\n         v0: val}\n    end)\n    .reorderCols([\"ts\",\"rm\",\"v0\"])\n    .addColMeta(\"v0\", {chartMin: 0%,\n                       chartMax: 100%})\n    .addMeta({view: \"chart\", chartType:\"heatMap\", \n              title: \"Supply damper commands, zones served by \"\n                     + readById(ahuRef).dis() + \", \"\n                     + pos.meta[\"hisRollupInterval\"],\n              colors: colors})\n  catch (ex) do\n    pos: null\n  end\n  return pos\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualUnmeteredEnergy",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual energy point under a virtual submeter,\n  representing all the unmetered energy for a higher-level meter.\n  \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  try do\n    virtualSubmeter: readById(rec->equipRef)\n    higherMeter: readById(virtualSubmeter->submeterOf)\n  end catch return null\n  \n  energyPts: readAll(delta and energy and point and not hidden and\n                     (equipRef==higherMeter->id\n                      or equipRef->submeterOf==higherMeter->id)\n                     and equipRef!= virtualSubmeter->id)\n\n  energyPts.hisRead(dates, {limit: null})\n           .hisRollup(sum, rec->hisVirtualInterval)\n           .hisMap((val, ts, his) => do\n               if (val==null) return na()\n               weight: if (his->equipRef==higherMeter->id) 1\n                       else -1 \n               return val * weight\n           end)\n           .hisFoldCols(sum)\n           .hisMap(v => if (v<0) 0 else v)\n           .each(row => yield(row->ts, row->v0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toAhuHeat","toAhuCool"],,,,M,,,,,,"unnecessaryDehumidifying",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/**************************************************************************************\nFind all AHUs with cooling & heating coils and a dehumidifying system. \nFind periods when dehumdifying is active but not needed\nAuthor: LCH - kW Engineering\n**************************************************************************************/\n(ahu, dates, minTime: 30min)=> do\n\n  // normalize minTime to hours\n  minTime = minTime.to(1h)\n  \n  //create empty array where heating/cooling periods will be stored\n  coolingPeriods: []\n  heatingPeriods: []\n  \n  //find all stages of cooling/heating for ahu\n  coolPts: toAhuCool(ahu, false)\n  heatPts: toAhuHeat(ahu, false)\n \n   //collect heating/cooling periods for all stages when valves is open \n if (coolPts == null) return null\n else if (coolPts.size < 2) coolingPeriods = coolingPeriods.add(coolPts.hisRead(dates).hisFindPeriods(v=> v>5%))\n else if (coolPts.size > 1) coolPts.each rec => do\n    coolingPeriods = coolingPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v>5%))\n   end\n if (heatPts == null) return null\n else if (heatPts.size < 2) heatingPeriods = heatingPeriods.add(heatPts.hisRead(dates).hisFindPeriods(v=> v>5%))\n else if (heatPts.size > 1) heatPts.each rec => do\n    heatingPeriods = heatingPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v>5%))\n  end\n  \n  //combine multiple stages of cooling and heating\n  coolingOn: hisPeriodMatrix(coolingPeriods)\n  heatingOn: hisPeriodMatrix(heatingPeriods)\n  \n  //collect all periods when any cooling or heating valves are active\n  spark1: hisPeriodMatrix(coolingPeriods).findAll r => r->numTrue != 0\n  spark2: hisPeriodMatrix(heatingPeriods).findAll r => r->numTrue != 0\n  sparkMatrix: hisPeriodMatrix([spark1, spark2]).findAll r => r->numTrue == 2\n  \n  //collect dehumid sp and value for selected dates\n  dehumSp: read(zone and air and dehumidify and sp and equipRef == ahu->id, false)\n  if (dehumSp == null) return null\n  else\n  dehumSp = dehumSp.hisRead(dates)\n  \n  humSens: read(zone and air and humidity and sensor and equipRef == ahu->id, false)\n  if (humSens == null) humSens = read(humidity and \"return\" and sensor and equipRef == ahu->id, false)\n  if (humSens == null) return null\n  else\n  humSens = humSens.hisRead(dates)\n  \n  //join sp and value histories\n  joined: hisJoin([dehumSp, humSens]).hisInterpolate()\n  \n  //mapped for difference between sp and value\n  mapped: joined.map row => do\n            {\n            ts: row->ts,\n            val: row.get(\"v0\") - row.get(\"v1\")\n            }\n          end\n\n  //Finds periods when sp is greater than value (no dehumifing necessary)\n  spark3: mapped.hisFindPeriods(x => x > 2) \n  \n  //Final spark is when heating is on, cooling is on, and dehumidifying is not needed\n  sparkFinal: hisPeriodIntersection([sparkMatrix, spark3]).findAll(r => r->v0 >= minTime)\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ruMeterAccDecreaseNotRollover","ruMeterAccZeroNotRollover"],,"Accumulator Decreased",,M,"Accumulator decreased and decrease did not meet zeroing conditions",,,,,"ruMeterAccDecreaseNotZero",,"meter","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates, defaultMaxStep: 100) => do\n  decreaseNotRo: ruMeterAccDecreaseNotRollover(equip, dates)\n  \n  zeroNotRo: ruMeterAccZeroNotRollover(equip, dates, defaultMaxStep)\n  \n  if (zeroNotRo==null or isEmpty(zeroNotRo))\n    return decreaseNotRo\n  \n  notZeroNotRo: hisPeriodMatrix([zeroNotRo])\n                .findAll(r => r->numTrue==0)\n                .keepCols([\"ts\",\"dur\"])\n  \n  if (isEmpty(notZeroNotRo) or isEmpty(decreaseNotRo)) return null\n  return hisPeriodIntersection([decreaseNotRo, notZeroNotRo])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Compared Deviation",,M,,,,,,"hisDeviationCompare_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// This his a hisSrc function, which displays:\n//   - history for selected point over selected period of time\n//   - low and high limits for the history based on average and hard-coded tolerance\n//   - percentage of point values that are out of tolerance\n//   - same thing for the history of the point \"\$duration\" earlier, for comparison\n// duration: time shift for comparison\n// number:   low percentile threshold for average, high threshold will be 1 minus number (symmetrical)\n// Warning: percentage of out of tolerance counts points, and will be inaccurate if\n//          interval time varies.\n\n(point, dates, duration, number) => do\n  // Hardcoded allowed deviation from reference, due to limitation of inputs of hisSrc func\n  tolerance: 0.5\n\n  // Number input defines our low percentile threshold, limit to 0 - 30\n  if (number>30) do percentile:30\n  end else if (number<0) do percentile:0\n  end else do percentile:number end\n\n  // Read data from current historian display, get meta info needed for proper display\n  r_current: point.hisRead(dates)\n  his_meta: r_current.meta\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_c_lo: round(r_current.size*percentile/100,0)\n  i_c_hi: round(r_current.size*(1.0 - percentile/100),0)\n  current_ref: r_current.sort(\"v0\")[i_c_lo..i_c_hi].foldCol(\"v0\",avg)\n  r_current = r_current.addCol(\"v0_limit_lo\", row => (current_ref - tolerance))\n  r_current = r_current.addCol(\"v0_limit_hi\", row => (current_ref + tolerance))\n  cur_out_num: r_current.findAll(row => (row->v0 < (current_ref - tolerance)) or (row->v0 > (current_ref + tolerance))).foldCol(\"v0\",count)\n  cur_out_pct: round(cur_out_num / r_current.size * 100, 0)\n\n  // Read data from earlier, shift timestamps to current historian display, make grid\n  r: point.hisRead(dates - duration)\n  list_ts: colToList(r,\"ts\")\n  list_v1: colToList(r,\"v0\")\n  list_ts0: list_ts.map s => s + duration\n  r_past: list_ts0.toGrid.map( (row,index) => {ts:row->val, v1:list_v1[index]} )\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_p_lo: round(r_past.size*percentile/100,0)\n  i_p_hi: round(r_past.size*(1.0 - percentile/100),0)\n  past_ref: r_past.sort(\"v1\")[i_p_lo..i_p_hi].foldCol(\"v1\",avg)\n  r_past = r_past.addCol(\"v1_limit_lo\", row => (past_ref - tolerance))\n  r_past = r_past.addCol(\"v1_limit_hi\", row => (past_ref + tolerance))\n  past_out_num: r_past.findAll(row => (row->v1 < (past_ref - tolerance)) or (row->v1 > (past_ref + tolerance))).foldCol(\"v1\",count)\n  past_out_pct: round(past_out_num / r_past.size * 100, 0)\n  \n  // Merge current and past grids and set meta information for proper display\n  r_past_meta: r_past.addMeta(his_meta)\n  r_joined: hisJoin([r_current, r_past_meta])\n  \n  point_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"dis\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  r_out: r_joined.addColMeta(\"v0\", {dis: point_dis+\", out of tolerance \"+cur_out_pct+\"%\", color: \"#3d80df\", chartGroup:\"1\"})\n                 .addColMeta(\"v0_limit_lo\", {dis: point_dis+\" low limit\", color: \"#4dcde1\", chartGroup:\"1\"})\n                 .addColMeta(\"v0_limit_hi\", {dis: point_dis+\" high limit\", color: \"#4dcde1\", chartGroup:\"1\"})\n                 .addColMeta(\"v1\", {dis: duration+\" earlier: \"+point_dis+\", out of tolerance \"+past_out_pct+\"%\", color: \"#d73d40\", chartGroup:\"2\"})\n                 .addColMeta(\"v1_limit_lo\", {dis: duration+\" earlier: \"+point_dis+\" low limit\", color: \"#c123b0\", chartGroup:\"2\"})\n                 .addColMeta(\"v1_limit_hi\", {dis: duration+\" earlier: \"+point_dis+\" high limit\", color: \"#c123b0\", chartGroup:\"2\"})\n                 .addMeta({dis: \"LAGGED \"+duration+\" \"+point_dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anFumeHoodSash"],,,,M,,,,,,"viFumeHoodSashHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all fume hoods and calculate\n  their sash height using the function anFumeHoodSash\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n  rollupMinutes      Number in minutes, use for rollup\n  focus              Str, enum:\"All,Occupied,Unoccupied\"\n  scheduleRef        Ref for schedule to use along with focus\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastWeek(),\n rollupMinutes:15, focus:\"All\", scheduleRef:null,\n showErrors: false, clip:18in) => do\n  unit: \"in\"\n  \n  // Retrieve location / site record, then retrieve all fume hoods\n  loc: readById(locRef)\n  if (loc.has(\"site\"))\n    fhs: readAll(fumeHood and equip and siteRef==locRef)\n  else\n    fhs: readAll(fumeHood and equip and locationRef==locRef)\n    \n  // Exit if no fume hoods were found\n  if(isEmpty(fhs)) return null\n  \n  // Create grid of sash height calculated histories\n  hisGrid: null\n  \n  // Filter by focus / schedule\n  if (focus != \"All\" and scheduleRef != null) do\n    schedule: readById(scheduleRef)\n      \n    if (schedule->navName == \"Occupancy Sensors\")\n      // Placeholder, retrieve occ sensor info and filter\n      filterPeriods: null\n    else do\n      if (focus==\"Occupied\")\n        filterFunc: v => v\n      else\n        filterFunc: v => not(v)\n    \n      filterPeriods: scheduleHis(schedule, dates)\n                     .hisFindPeriods(filterFunc)\n    end\n  end else filterPeriods: null\n  \n  // Calculate sash heights and combine\n  fhs.each fh => do\n    fhSashHeight: anFumeHoodSash(fh->id, dates, 0.1, null, 0, showErrors)  \n    if (fhSashHeight==null or isEmpty(fhSashHeight)) return null\n    \n    if (filterPeriods != null)\n      fhSashHeight= hisFindInPeriods(fhSashHeight, filterPeriods)\n    \n    if (hisGrid==null) hisGrid= fhSashHeight\n    else hisGrid= hisJoin([hisGrid, fhSashHeight])\n  end\n  \n  hisGrid= hisGrid.hisRollup(avg, rollupMinutes.to(\"min\"))\n\n  try do\n    hisGrid= hisGrid.hisMap(v => if (v == null) null\n                            else if (v == na()) na()\n                            else min(max(v.to(unit),0in),clip))\n        .hisFlatten((val, ts, his) => \n               {ts: ts,\n                rm: his->equipRef->equipRef->navName + \" (\"\n                    + reGroups(\"Fume Hood\\\\W? ?(.*)\",\n                               his->equipRef->navName)[1] + \")\",\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: 0in,\n                           chartMax: clip.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: \"#00cc33, #00cc33, #73c027, #e6b31a, #ff9933, #ff4d1a, #ff0000\"})\n                  //\"#00cc33, #00cc33, #66cc1a, #cccc00, #ff9933, #ff4d1a, #ff0000\"\n                                                                //#e6b31a\n  catch (ex) do\n    return null\n  end\n  \n  title: loc.dis() + \" sash heights, heat map, \"\n         + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n         + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")\n  if (loc.has(\"site\")) title= \"B\" + title\n  if (focus != \"All\")\n    title= title + \", \" + focus.decapitalize + \" hours only\"\n\n  return hisGrid.addMeta({title: title})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viMeterHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns a grid formatted as a heat map with:\n  x: date\n  y: time of day\n  z: hourly energy consumption of given meter\n  grid is optimized for use as a chart.\n  \n  z values are clipped based on given clip value.\n  z color scale is aligned from 0 to max or clip value.\n  \n  Arguments:\n  meterRef       meter id for which to display consumption\n  span           dateSpan, span of dates for which to return data\n  clip           number, value to clip power at for display (0..clip)\n*/\n\n(meterRef, span, clip) => do\n  // Force conversion to DateTime span (instead of Date-only span)\n  span= span.toSpan()\n  // Find consumption delta point associated with given meter ID\n  dEnergy: read(equipRef==meterRef->id\n                and energy and delta and sensor and point\n                and not hidden,\n                // Don't throw exception if no point found\n                false)\n  \n  // Instead, return null if no point found\n  if (dEnergy == null) return null\n  \n  // Determine target unit, gas consumption will be converted to kWh\n  unit: if (dEnergy->unit == \"BTU\") \"kWh\" else dEnergy->unit\n  \n  // Load historical trends\n  dEnergy= dEnergy.hisRead(span, {limit: null})\n  \n  // Escape by returning null if no historical data is found\n  if (isEmpty(dEnergy.hisClip())) return null\n  \n  // Process NA, rollup to 1h and clip to remove leading and trailing\n  dEnergy= dEnergy.hisMap(v => if(v==na()) null else v)\n                  .hisRollup(sum, 1h)\n                  .hisClip()\n\n  // Determine max hourly consumption and suggested clip value\n  actualMax: round(dEnergy.foldCol(\"v0\",max).to(unit))\n  samples: dEnergy.colToList(\"v0\").size\n  suggestClip: dEnergy.colToList(\"v0\").sort()[round(samples * 0.995)-1]\n  suggestClip= round(suggestClip.to(unit)*1.1)\n  suggestClip= if (actualMax / suggestClip > 1.5) suggestClip\n               else actualMax \n\n  // Map for clipping consumption values between 0 and clip\n  dEnergy= dEnergy\n           .hisMap(v => if (v == null) na()\n                        else min(max(v.to(unit),0),\n                                 clip.as(unit))) \n\n  // Format grid for display as heat map graph\n  dEnergy= dEnergy\n    .addColMeta(\"v0\", {chartMin: 0.as(unit),\n                       chartMax: clip.as(unit)})\n    .addMeta({chartType: \"heatMap\", colors: \"green, yellow, red\",\n              title: readById(meterRef->id).dis()\n                     + \" (max \" + actualMax.format(\"#,###\")\n                     + \" , clipped at \" + clip.as(unit).format(\"#,###\")\n                     + \" , suggested \" + suggestClip.format(\"#,###\") + \")\",\n             })\n  \n  // Return grid\n  return dEnergy\nend\n\n/*\n  Updates\n  2019-10-11   Added hisMap to manage NA values, cleaned up code and comments\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"sqlTestScript6",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  sql: \"SELECT *\" +\n       \" FROM ION_Data.dbo.Source S\"\n\n  data: read(sqlConn and dis==\"ionDB\").sqlQuery(sql)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viWetBulbScatter",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of 15-minute CT Fan Power vs OA WB Temp data at B59 (in °F)\n  ??Compare pastWeek with the month prior??\n*/\n\n(wbLoc:null, sysRef:null, dates:today, rollup:15min) => do\n  // Default to B59 TW if no ref is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and condenserWaterPlant and navName==\"Plant\")\n    \n    sysRef= sysRef->locationRef\n    \n  // Default to local OA WB\n  if(wbLoc==null)\n    wbLoc= read(equip and siteRef->dis==\"59\" and condenserWaterPlant and navName==\"Plant\")\n    \n    wbLoc= wbLoc->id\n  \n  //x is the wetbulb temperature (defaulting to the same location as the default \n   x: read(equipRef==wbLoc and outside and point and sensor and wetBulb)\n      .hisRead(dates, {limit:null})\n      .hisRollup(avg, rollup)\n  \n  //y is the total ct fan power\n   y: readAll(locationRef == sysRef and power and sensor and point and equipRef-> fan)\n      .hisRead(dates, {limit:null})\n      .hisFoldCols(sum)\n      .hisRollup(avg, rollup)  // Average over 15 min to get a more reasonable number of points\n  \n  // join wetbulb and ct fan power to prep for scatter chart\n   joined: hisJoin([x, y])\n   newSeries: joined.\n              keepCols([\"v0\",\"v1\"]).\n              renameCol(\"v0\",\"oaWetbulb\").\n              renameCol(\"v1\",\"total\")\n  \n  // make scatter chart  \n    newSeries.addMeta({chartType: \"scatter\", \n                     title: \"Total CT Fan Power vs. Outside Air Wetbulb Temperature\"})\n             .addColMeta(\"total\", \n                     {chartType: \"scatter\", \n                     color: \"#FF8C00\",\n                     dis: \"Cooling Tower Fan Power\"})\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["googleCalRead"],,,,M,,,,,,"syncGoogleCal",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function takes a grid of points for\n  Google Calendar with the beginning and ending\n  time for the sliding window (currently is 2h <= now () <= 2day)\n  and passes each point to inner google calendar function.\n  \n  Arguments: \n  google_points     Grid of points with point->calendarID variable\n  start_date        dateTime for beginning of sliding window\n  end_date          dateTime for ending of sliding window\n  \n  // LBNL // JBR // Last Update: 2019-02-19 //\n*/\n\n(google_points, start_date, end_date) => do\n\n  // For each point in grid, call base calendar function\n  // with correct start and end time\n  google_points.each row => do\n  try do\n  \n    start_date = start_date.format(\"MM/DD/YYYY hh:mm:ss\")\n    end_date = end_date.format(\"MM/DD/YYYY hh:mm:ss\")\n  \n    googleCalRead(row, start_date, end_date)\n     \n   end // end try\n   catch (ex) do\n     echo(ex)\n   end// end try\n   \n  end// end each\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpFridayFun",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  hisGrid: readByIds([@p:lbnl:r:23d4fc7f-6db76065])\n           .hisRead(2019-03-01)\n           .addMeta({persist})\n           \n  grid2: hisGrid.map((row, index) => do\n    if (index==0) return null\n    return {ts: row->ts, v0: row->v0, timeDiff: row->ts - hisGrid[index-1]->ts}\n  end)\n  \n  return grid2.findAll(row => row[\"timeDiff\"]!=null)\n              .addColMeta(\"timeDiff\",{unit:\"s\",\n                                      kind:\"Number\",\n                                      chartType:\"line\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecTags"],,,,M,,,,,,"toolFormatTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Takes in a history grid and applies additional grouping, colors, width\n  \n  Arguments: \n  hisGrid        History grid\n  group          Str, describes grouping methodology, see enum below\n  tagGroups      Str[], used with group==\"By specified tag groups\"\n                   list of tag filters to group points together\n  colorFilters   Str[], list of color filters, see default below\n  spanFilters    Str[], list of chart min/max filters, see default below\n  width          Number, override strokeWidth if not zero\n  chartMin       Number, if not null, add corresponding chartMin to all trends\n\n  group enum: \"By unit, By equip, By equip and unit, By tags,\n               By equip and tags, By specified tag groups\"\n*/\n\n(hisGrid, group, tagGroups:[], colorFilters:null, spanFilters:null,\n width:0, chartMin:null) => do\n  // Default color filters if null passed as argument\n  if (colorFilters==null)\n    // Default colors\n    colorFilters= [\"outside and air:forestgreen\",\n                   \"return and air:red\",\n                   \"discharge and air and equipRef->ahu:deepskyblue\",\n                   \"mixed and air:blueviolet\",\n                   \"cool and valve:dodgerblue\",\n                   \"heat and valve:firebrick\",\n                   \"sp:black\"]\n                   \n  // Default chart min/max\n  if (spanFilters==null)\n    spanFilters= [\"unit==\\\"%\\\" and cmd:0%,100%\",\n                  \"zone and air and temp:50°F,90°F\"]\n  \n  // Apply display units\n  hisGrid= hisGrid.hisMap((val,ts,his) => do\n    if(his.has(\"chartUnit\")) val.to(his[\"chartUnit\"])\n    else val\n  end)\n\n\n  // Cycle through history columns and apply grouping and colors\n  hisGrid.colNames.remove(0).each colName => do\n    his: hisGrid.col(colName).meta\n    // Remove weatherPoint tag to allow grouping of weather station points\n    hisGrid= hisGrid.addColMeta(colName, {-weatherPoint})\n    \n    // chartGroup overrides\n    if (group==\"By navName\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->navName\n                       catch null})\n    \n    if (group==\"By unit\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:null})\n      \n    if (group==\"By equip\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->equipRef.toStr()\n                       catch null})\n                                                \n    if (group==\"By equip and unit\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->equipRef.toStr()+his->unit\n                       catch null})\n                                                \n    if (group==\"By tags\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:\n          try toolRecTags(his)\n              .findAll(v => not([\"sensor\",\"sp\",\"cmd\"].contains(v)))\n              .sort().concat(\"_\")\n          catch null})\n        \n    if (group==\"By equip and tags\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:\n          try his->equipRef.toStr()+toolRecTags(his)\n              .findAll(v => not([\"sensor\",\"sp\",\"cmd\"].contains(v)))\n              .sort().concat(\"_\")\n          catch null})\n          \n    if (group==\"By specified tag groups\" and his[\"kind\"]==\"Number\"\n        and tagGroups != null and not(isEmpty(tagGroups))) do\n      tagGroups.each tagGrp => do\n        try if (not(isEmpty([his].findAll(filterToFunc(tagGrp.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {chartGroup: tagGrp.toTagName()})\n        catch null\n      end\n    end\n    \n    // Color overrides\n    colorFilters.each colorFilter => do\n      color: colorFilter.split(\":\")[1]\n      filter: colorFilter.split(\":\")[0]\n      try if (not(isEmpty([his].findAll(filterToFunc(filter.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {color: color})\n        catch null\n    end\n    \n    // Span overrides\n    spanFilters.each spanFilter => do\n      disSpan: spanFilter.split(\":\")[1]\n      chartMin: try disSpan.split(\",\")[0].parseNumber() catch null\n      chartMax: try disSpan.split(\",\")[1].parseNumber() catch null\n      filter: spanFilter.split(\":\")[0]\n      try if (not(isEmpty([his].findAll(filterToFunc(filter.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {chartMin: chartMin,\n             chartMax: chartMax})\n        catch null\n    end\n    \n    // Override width if greater than zero\n    if (width>0)\n      hisGrid= hisGrid.addColMeta(colName,\n                 {strokeWidth: width})\n    \n    // Add chartMin if provided\n    if (isNumber(chartMin) and his.has(\"unit\"))\n      hisGrid= hisGrid.addColMeta(colName,\n                 {chartMin: chartMin.as(his->unit)})\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-24  Raphael Vitti\n    Added chartMin input and block of code to add chartMin to trends.\n  2020-03-30  Raphael Vitti\n    Added unit to chartMin, and chartMin doesn't apply if his has no unit.\n*/",,
,[],,,,M,,,,,,"calculateAccumulatorToDelta",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates deltas between accumulator values, and\n  assigns the delta 'forward', i.e. delta1 = (acc1 - acc0) at ts1\n  If a negative delta is calculated (rollover or accumulator backup)\n  no value is returned for that interval.\n  \n  After calculation, the points are written and stored to history.\n  \n  Virtual point (delta) needs to reference the source point\n  (accumulator) as a pointRef.\n  \n  Arguments:\n  restartDate (optional)   Date to rewrite history from. Must be\n                           a date, not a dateTime.\n  newOnly (optional)       If true, calculate only for points that\n                           have no history (not hisEnd)\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2018-08-23 //\n*/\n\n(restartDate:null, newOnly:false) => do\n\n  today: now().date\n  // We expect all virtual delta points with a pointRef\n  //  and no hisFunc can go through this function\n  filter: \"virtual and delta and sensor and point\" +\n          \" and his and pointRef and not hisFunc\"\n  if (newOnly) filter = filter + \" and not hisEnd\"\n  query: parseFilter(filter)\n             \n  ptList: readAll(query)\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  ptList.each pt => do\n    hisEnd: pt[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    argument). Assign dates based on the 4 possibilities\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input: clear history from restartDate\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Calculate.\n    // Initialize previous value tracker\n    prevVal: null\n    deltaVal: null\n    dict: null\n\n    // Read accumulator history and calculate deltas\n    rawGrid: pt->pointRef  // Accumulator point.\n           .hisRead(dates, {limit: null})\n    resultGrid: rawGrid.map row => do\n        // All rows that are not first row\n        if (prevVal != null) do\n          deltaVal = row->v0  - prevVal\n          dict = {ts: row->ts, v0: deltaVal}\n        end else do\n          // map func needs every row to be filled in,\n          // null will be filtered out later\n          dict = {ts: null, v0: null}\n        end\n        // Update values\n        prevVal = row->v0\n        dict\n      end\n    \n    // Filter out result grid to remove negative values (accumulator reset)\n    resultGrid = resultGrid.findAll(row => row[\"v0\"] >= 0)\n    \n    // Filter out redundant data (already in history)\n    filteredGrid: resultGrid.findAll(row => row->ts > hisEnd)\n    \n    // Write calculated data to history.\n    hisWrite(filteredGrid, pt)\n    return {written: filteredGrid.size, status: \"OK\"}\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"ION Meter Offline",,M,"ION meter stopped reporting and is likely offline",,,,,"ruMeterElecIonOffline",,"meter and sqlMeter","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates) => do\n  // Get all non-virtual points\n  pts: readAll(point and not virtual\n               and equipRef==equip->id)\n  if (isEmpty(pts)) return hisSlidingWindows(dates, 1h, 1h)\n  \n  pts.hisRead(dates, {limit:null})\n     .hisRollup(max, 24hr)\n     .hisFindPeriods((val, ts, his) => do\n       return val == null\n     end)\n end\n \n // hisSlidingWindows(date(now()), 24hr, 24hr)\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecsTags"],,,,M,,,,,,"recEditTagSet",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(tagSetDict) => do\n  // Normalize action input\n  tagSetDict= actionNormInput(tagSetDict, \"dict\")\n  \n  // Equipment tags can't be changed from here\n  if (tagSetDict.has(\"eqTags\")) throw \"Equipment tags can't be edited from here\"\n  \n  // Load older record\n  oldRec: readById(tagSetDict->id)\n  \n  // If ptTags has changed, change all corresponding points' tags to new tag\n  if (tagSetDict.has(\"ptTags\")) do\n    // Convert to lists of tags\n    eqTagSet: if (oldRec.has(\"eqTags\")) oldRec->eqTags.split(\",\")\n              else null\n    ptTagSet: oldRec->ptTags.split(\",\")\n    newPtTagSet: tagSetDict->ptTags.split(\",\")\n    \n    // Find all points with eqTags and ptTags matching the previous record\n    filter: \"point and \"\n    // eqTags filter string\n    if (eqTagSet != null)\n      filter= filter + \"equipRef->\" + eqTagSet.concat(\" and equipRef->\") + \" and \"\n    // ptTags filter string\n    filter= filter + ptTagSet.concat(\" and \")\n    points: readAll(parseFilter(filter))\n    \n    // Remove ignored tags, remove points from list if match isn't exact\n    points= points.toolRecsTags()\n                  .findAll(pt => do\n                    tags: pt.remove(\"id\").findAll(v => v != null).names\n                    return tags.all(tag => ptTagSet.contains(tag))\n                  end)\n    \n    // Build change dict\n    changeDict: {}\n    // Remove old tags\n    ptTagSet.each ptTag => changeDict= changeDict.set(ptTag,removeMarker())\n    // Add new tags\n    newPtTagSet.each ptTag => changeDict= changeDict.set(ptTag,marker())\n    \n    // Cycle through points, remove old tags, add new tags\n    points.each(pt => commit(diff(readById(pt->id), changeDict)))\n  end\n\n  recEdit(tagSetDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridShowGaps","viPUEAndWetBulb"],,,,M,,,,,,"viB59PUEPrePostScatter_v2",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of 15-minute of the PUE vs OA WB Temp data \n  at B59 (in °F)\n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01),\n dateRangePost: lastWeek().toSpan(),\n minCompPower: null, maxCompPower: null,\n pueEquipRef:null,\n timeSeries:false) => do\n \n   // Default to PUE, Estimates for Avg <50kW if no selection is made\n  if(pueEquipRef==null)\n    pueEquipRef= \"L1, Estimates for Avg <50kW\"\n  else \n    pueEquipRef= \"L1, \"+ pueEquipRef\n  \n  // Params\n  binWidth: 3\n  \n  // Load desired data from both date ranges\n  gridPre: viPUEAndWetBulb(dateRangePre, minCompPower, maxCompPower,\n                           pueEquipRef, \"Pre\")\n  gridPost: viPUEAndWetBulb(dateRangePost, minCompPower, maxCompPower,\n                            pueEquipRef, \"Post\")\n\n  // Bin gridPre\n  binned: {}.toGrid()\n  gridPre\n  .colToList(\"oaWetBulb\")\n  .findAll(v => v!=null)\n  .map(v => round(v)).unique() // OA WB Bins\n  .each(oaWbBin => do\n    basePUEs: gridPre.findAll(r => r[\"oaWetBulb\"]>=(oaWbBin-binWidth/2) and\n                                   r[\"oaWetBulb\"]<(oaWbBin+binWidth/2) and\n                                   r.has(\"puePre\") and r[\"puePre\"] != na())\n                     .colToList(\"puePre\")\n    samples: basePUEs.size\n    binned= binned.addRow(\n      {oaWetBulb: oaWbBin,\n       avg: basePUEs.fold(avg),\n       percentile95: if (samples>1) basePUEs.sort((a,b) => a <=> b)[round(95 / 100 * (samples-1))]\n                     else null\n      })\n  end)\n  binned= binned\n  .removeCols([\"avg\"])\n  .sort((a,b) => a->oaWetBulb <=> b->oaWetBulb)\n\n  // For time series, calculate target in post range\n  if (timeSeries) do\n    gridPost= gridPost\n    .addCol(\"bin\", r => round(r->oaWetBulb))\n    .addCol(\"target\", row => do\n      targetBin: binned.find(r => r->oaWetBulb==row->bin, false)\n      if (targetBin==null) return na() else return targetBin->percentile95\n    end)\n    .removeCol(\"bin\")\n    \n    // Format chart\n    graph: gridPost\n           .addMeta({title: \"PUE Time Series\"})\n           .toolHisGridShowGaps(15min, \"point or not point\")\n  end else do\n    // Concatenate both history grids\n    allGrid: addRows(gridPre, gridPost)\n    .removeCol(\"ts\")\n    .addRows(binned)\n    colNames: allGrid.colNames\n    allGrid= allGrid.reorderCols(colNames.moveTo(\"oaWetBulb\", 0))             \n  \n    // Format chart\n    graph: allGrid\n           .addMeta({chartType: \"scatter\",\n                     title: \"PUE (Baseline vs. Recent)\"})\n           .addColMeta(\"oaWetBulb\", {chartMin: 40°F, chartMax: 70°F})\n end\n\n  if (graph.has(\"puePre\"))\n    graph= graph\n    .addColMeta(\"puePre\", \n                {dis: \" PUE, Baseline \"+dateRangePre,\n                 color: \"#7ED7DE\",\n                 chartType: if (timeSeries) \"line\" else \"scatter\",\n                 chartMin: 1,\n                 chartGroup: \"all\"})\n                  \n  if (graph.has(\"puePost\"))\n    graph= graph                      \n    .addColMeta(\"puePost\", \n                {dis: \" PUE, Recent \"+dateRangePost,\n                 color: \"#DE3E30\",\n                 chartType: if (timeSeries) \"line\" else \"scatter\",\n                 chartMin: 1,\n                 chartGroup: \"all\"})\n                      \n  if (graph.has(\"avg\"))\n    graph= graph\n    .addColMeta(\"avg\", \n               {dis: \"Binned Average Baseline\",\n                color: \"black\",\n                chartType:if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n  if (graph.has(\"percentile95\"))\n    graph= graph\n    .addColMeta(\"percentile95\", \n               {dis: \"Binned 95th Percentile Baseline\",\n                color: \"black\",\n                chartType: if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n  if (graph.has(\"target\"))\n    graph= graph\n    .addColMeta(\"target\", \n               {dis: \"Target, Based on Binned 95th Percentile Baseline\",\n                color: \"black\",\n                chartType: if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n   return graph\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"ptMetricsCoolingSystemITUE",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This virtual point function (hisFunc) calculated the cooling system\n  ITUE of a CRAY computer, comparing its fan power to its compute power.\n  \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n\n  computerRef: rec->equipRef\n  computeMeter: toolRecursiveSearch(computerRef, \"meter and compute\")[0]\n  computePowerPt: read(power and sensor and equipRef==computeMeter->id, false)\n  fanMeter: toolRecursiveSearch(computerRef, \"meter and fan\")[0]\n  fanPowerPt: read(power and sensor and equipRef==fanMeter->id, false)  \n  \n  interval: rec->hisVirtualInterval\n  \n  computePower: computePowerPt.hisRead(dates, {limit:null})\n                              .hisRollup(avg, interval)\n                              .renameCol(\"v0\",\"compute\")\n  \n  fanPower: fanPowerPt.hisRead(dates, {limit:null})\n                      .hisRollup(avg, interval)\n                      .renameCol(\"v0\",\"fan\")\n  \n  grid: hisJoin([computePower, fanPower])\n        .addCol(\"itue\", row => do\n          if (row.any(v => v==null or v==na() or v==0)) return na()\n          else return ((row->compute + row->fan) / row->compute).as(1)\n        end)\n        .each(row => yield(row->ts, row->itue))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recTrashTask",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(refs) => do\n  recTrash(refs)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"mapALCPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_x/yyy.csv`\n to add these points to zone equips that already exist.\n  \n The file includes a match to the current tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(fileUri ,types: [0,1,2,3,4,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(fileUri)\n  \n  i: 0\n  \n  // Cycle through connectors\n  alcPtList.unique(\"connRef\").colToList(\"connRef\").each connRef => do\n    // Load bacnet info for connector\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, \"MS\", \"TL\"]\n    \n    connectorId: parseRef(connRef)\n    types.each type => do\n      learn: bacnetLearn(connectorId, type)\n      bacnetPtList= bacnetPtList.set(type, learn)\n    end\n  \n    // Cycle through points of interest on given connector\n    alcPtList.findAll(row => row->connRef == connRef).each row => do\n      // Update job message\n      jobProgress((i / alcPtList.size())*100.as(1%), row->alcDisplay)\n      i= i+1\n      \n      // Find related equip\n      eq: readById(parseRef(row->eq))\n      \n      // Get info from bacnetPtList by matching bacnetCur\n      curType: row->bacnetCur[0..1]\n      bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n      if (bacnetGrid == null) bacnetGrid= [].toGrid()\n      bacnetCurRow: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n      if (bacnetCurRow == null)\n        bacnetCurRow= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n        \n      // Find bacnetHis\n      bacnetHisGrid: bacnetPtList[20]\n      if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n      bacnetHisRow: bacnetHisGrid.find(his => his[\"dis\"]==row[\"bacnetHisName\"])\n      if (bacnetHisRow == null) bacnetHisRow= {}\n\n      // Prepare new point dict\n\t\t\tptDict: {point,\n\t\t\t\t\t disMacro: \"\\\$equipRef \\\$navName\",\n\t\t\t\t\t bacnetConnRef: connectorId,\n\t\t\t\t\t connRef: connectorId,\n\t\t\t\t\t cur,\n\t\t\t\t\t bacnetCur: row->bacnetCur,\n\t\t\t\t\t bacnetHis: bacnetHisRow[\"bacnetHis\"], //optional\n\t\t\t\t\t bacnetCurName: row->bacnetCurName,\n\t\t\t\t\t bacnetHisName: row[\"bacnetHisName\"],\n\t\t\t\t\t kind: bacnetCurRow[\"kind\"], //optional\n\t\t\t\t\t unit: bacnetCurRow[\"unit\"], //optional\n\t\t\t\t\t enum: bacnetCurRow[\"enum\"], //optional\n\t\t\t\t\t equipRef: eq->id,\n\t\t\t\t\t his,\n\t\t\t\t\t notes: row[\"alcDisplay\"], //optional\n\t\t\t\t\t locationRef: eq->locationRef,\n\t\t\t\t\t siteRef: eq->siteRef,\n\t\t\t\t\t tz: \"Los_Angeles\",\n\t\t\t\t\t tmp: today()}\n      \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      if (finalize)\n        commit(diff(null, ptDict, {add}))\n        \n    end // Cycle through points\n  end // Cycle through connectors\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anRegGasHddApply_v1","anRegGasHddCalculate_v2"],,,,M,"Calculate avoided energy usage over a given post-install period, and calculate corresponding statistics.",,,,M,"anRegGasHddAvoided_v1","dailyGasHDD",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate avoided energy usage over a given post-install period,\n  and calculate corresponding statistics.\n  Return dictionary with:\n    avoidedUsageResults:  dict of avoided energy usage statistics\n    postResults:          dict of post-install model coefficients\n                            and fit statistics\n    graph:                chart grid for measured & adjusted usage\n    dataset:              grid of post dataset, plus adjusted usage\n  \n  Arguments: \n  meterUsageRef      Ref of gas meter usage data point\n  dateSpanBase       Span of baseline dates to create model from\n  dateSpanPost       Span of post-install dates to calculate avoided usage on\n  ddRefTemp          Reference temp for calculation of degree days\n\n  Notes:\n  Uncertainty currently does not account for autocorrelation and\n  will therefore be underestimated if autocorrelation is significant\n*/\n\n(meterUsageRef, dateSpanBase, dateSpanPost, ddRefTemp) => do\n  // Associate functions\n  calcModel: anRegGasHddCalculate_v2\n  applyModel: anRegGasHddApply_v1\n\n  // Perform base and post regressions\n  baseModel: calcModel(meterUsageRef, dateSpanBase, ddRefTemp, \"BASE: \")\n  postModel: calcModel(meterUsageRef, dateSpanPost, ddRefTemp, \"POST: \")\n  \n  // Calculate adjusted baseline\n  adjustedBase: applyModel(meterUsageRef, dateSpanPost, baseModel->results)\n                  .renameCol(\"fittedUsage\", \"adjustedBaseUsage\")\n  \n  // Prepare post dataset including adjusted base\n  postDataset: hisJoin([postModel->dataset, adjustedBase])\n                 // Filter out dates with missing data\n                .findAll(row => row.has(\"usage\"))\n                // Add avoided energy usage\n                .addCol(\"avoidedUsage\",\n                        row => row->adjustedBaseUsage - row->usage)\n                        \n  //Calculate statistics\n  avoidedUsage: postDataset.foldCol(\"avoidedUsage\", sum)\n  adjustedTotal: postDataset.foldCol(\"adjustedBaseUsage\", sum)\n  f: avoidedUsage / adjustedTotal\n  m: postModel->results[\"n\"]\n  n: baseModel->results[\"n\"]\n  baseMse: baseModel->results[\"mse\"]\n  baseAvg: baseModel->results[\"measuredAvg\"]\n  avoidedUncertainty68: 1.26 * 1 / (m * baseAvg * f)\n                             * sqrt(baseMse * (1 + 2 / n) * m)\n                             \n  // Compile results\n  avoidedUsageResults: {\n    avoidedUsage: avoidedUsage,\n    avoidedUsageRelative: (f*100).as(1%),\n    adjustedTotal: adjustedTotal,\n    uncertainty68: (avoidedUncertainty68*100).as(1%)\n  }\n  \n  // Modify post graph to add adjusted baseline\n  baseIntercept: baseModel->results[\"intercept\"]\n  baseSlopeWeekday: baseModel->results[\"slopeWeekday\"]\n  baseSlopeWeekend: baseModel->results[\"slopeWeekend\"]\n  postGraph: postModel->graph\n    .addCol(\"adjustedBaseWeekday\", row => if(row.has(\"heat\"))\n      (baseIntercept + baseSlopeWeekday*row->heat).as(1BTU)\n      else null)\n    .addCol(\"adjustedBaseWeekend\", row => if(row.has(\"heat\"))\n      (baseIntercept + baseSlopeWeekend*row->heat).as(1BTU)\n      else null)\n    // Add meta data to control graph display\n    .addColMeta(\"adjustedBaseWeekday\", {chartType:\"scatter\", chartGroup:\"all\",\n                                        color:\"#F18E1D\"})\n    .addColMeta(\"adjustedBaseWeekend\", {chartType:\"scatter\", chartGroup:\"all\",\n                                        color:\"#B56B16\"})\n    // Rename post regression columns and reorder for clarity\n    .renameCol(\"regressionWeekday\", \"postRegressionWeekday\")\n    .renameCol(\"regressionWeekend\", \"postRegressionWeekend\")\n    .reorderCols([\"heat\",\"adjustedBaseWeekend\",\"adjustedBaseWeekday\",\n                  \"postRegressionWeekend\",\"postRegressionWeekday\",\n                  \"usageWeekend\",\"usageWeekday\"])\n  \n  return {avoidedUsageResults: avoidedUsageResults,\n          postResults:postModel->results,\n          graph:postGraph,\n          dataset:postDataset}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"dataQualityToBool",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, and a given span (optional), return a\n  day by day timeline of data validity.\n  \n  Arguments: \n  meterRef        Target id\n  span            Datespan (optional)\n  \n  Returns a history grid with dates as ts, and Bool as v0\n*/\n\n(meterRef, span:null) => do\n  // Load dataQuality records associated with given meter\n  qualityRecs: readAll(dataQuality and meterRef==meterRef)\n  if (isEmpty(qualityRecs)) return null\n  \n  // Sort records by startDate\n  qualityRecs= qualityRecs\n  .sort((a,b) => a->startDate <=> b->startDate)\n  \n  // If span is not provided, process full range from first\n  // available record until today\n  if(span==null)\n    span= qualityRecs.first->startDate..today()\n  span= span.toDateSpan()\n\n  // Cycle through records to compute a list of dates for which\n  // data is \"Validated\"\n  validDaysList: []\n  qualityRecs.each((qualityRec,i) => do\n    // If data is not \"Validated\", skip record\n    if (qualityRec->dataQuality==\"Insufficient\") return null\n    \n    // Determine period start and period end for current record\n    thisStart: qualityRec->startDate\n    thisEnd: try qualityRecs[i+1]->startDate - 1day\n             catch span.end\n               \n    // If there is no overlap, skip record\n    if (span.start >= thisEnd) return null\n    if (span.end < thisStart) return null\n    \n    // Create datespan associated with record and overlapping 'span'\n    qSpanStart: if (span.start > thisStart) span.start\n                else thisStart\n    qSpanEnd: thisEnd\n    qSpan: (qSpanStart..qSpanEnd).toDateSpan()\n\n    // Cycle through span and add each date to validDaysList\n    qSpan.eachDay day =>\n      validDaysList= validDaysList.add(day)\n  end)\n  \n  // If there are no valid dates, return null\n  if (isEmpty(validDaysList)) return null\n  \n  chart: {}.toGrid()\n  span.eachDay day => do\n    val: if (validDaysList.contains(day)) true else false\n    chart= chart.addRow({ts:day, v0:val})\n  end\n \n  return chart\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"syncWeatherLBNL1fromFile",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function is used to backfill missing data from a CSV file from mesowest\n https://mesowest.utah.edu/cgi-bin/droman/download_api2.cgi?stn=LBNL1&year1=2019&day1=19&month1=11&hour1=10&timetype=LOCAL&unit=0\n \n parseFloat is used by default on all values\n \n Arguments:\n filepath\n \n Notes:\n For this function to be used with another weather station,\n new weatherPoints must be created and linked inside the function\n*/\n\n(filepath: `io/tmp/weatehr_backfill.csv`) => do\n  // Load file\n  grid: ioReadCsv(filepath)\n  \n  // Set parameters: csv column names of interest, converted to legal tag names,\n  //   and associated weather points of interest, by id\n  datetime_t: toTagName(\"Date_Time\")\n  pt_list: [\n    {tagName: toTagName(\"air_temp_set_1\"), link: readById(@p:lbnl:r:21954442-d84f76af)},\n    {tagName: toTagName(\"air_temp_set_2\"), link: readById(@p:lbnl:r:2194e058-3f3ac56d)},\n    {tagName: toTagName(\"pressure_set_1\"), link: readById(@p:lbnl:r:21954521-a510f570), sUnit:\"inHg\", tUnit:\"mbar\"},\n    {tagName: toTagName(\"relative_humidity_set_1\"), link: readById(@p:lbnl:r:219543f4-55d8f4c0)},\n    {tagName: toTagName(\"dew_point_temperature_set_1d\"), link: readById(@p:lbnl:r:2195488b-f8b89630)},\n    {tagName: toTagName(\"wind_speed_set_1\"), link: readById(@p:lbnl:r:2195460a-3039caf5)},\n    {tagName: toTagName(\"wind_gust_set_1\"), link: readById(@p:lbnl:r:21954730-b9e48c6e)},\n    {tagName: toTagName(\"wind_direction_set_1\"), link: readById(@p:lbnl:r:219546a6-a3325fb6)},\n    {tagName: toTagName(\"precip_accum_fifteen_minute_set_1\"), link: readById(@p:lbnl:r:219547ab-f705db2e)},\n    {tagName: toTagName(\"solar_radiation_set_1\"), link: readById(@p:lbnl:r:21954364-2304a444)}\n  ]\n  \n  // Parse dates\n  grid= grid.addCol(\"ts\", r => parseDateTime(r[datetime_t]+\" Los_Angeles\", \"MM/DD/YYYY hh:mm zzzz\", \"Los_Angeles\"))\n            .sort((a,b) => a->ts <=> b->ts)\n            \n  // Get first timestamp and remove all data from weatherpoints starting then\n  startTime: grid.first->ts\n  pt_list.each pt => pt->link.hisRemove(startTime..now())\n\n  // Iterate through list of points of interest and write records if value is available\n  pt_list.each pt => do\n    hisGrid: grid.keepCols([\"ts\", pt->tagName])\n                 .reorderCols([\"ts\", pt->tagName])\n                 .hisFindAll(v => v != null)\n                 .hisMap(v => parseFloat(v, checked: false))\n                 .hisMap(v => if (pt.has(\"sUnit\") and pt.has(\"tUnit\"))\n                                v.as(pt->sUnit).to(pt->tUnit)\n                              else v)\n                 .hisFindAll(v => v != null)\n                 .hisWrite(pt[\"link\"])\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"backfillJaceTest",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  pt: readById(@p:lbnl:r:258a708f-32e5d174)\n  dict: {}\n  tagName1: \"facility\"\n  tagVal1: \"Bldg0\"\n  tagName2: \"meterName\"\n  tagVal2: \"Bob\"\n  tagName3: \"pointName\"\n  tagVal3: \"Bob Sr.\"\n  dict= dict.set(tagName1, tagVal1)\n  dict= dict.set(tagName2, tagVal2)\n  dict= dict.set(tagName3, tagVal3)\n  commit(diff(pt, dict))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptAccumulatorToDelta"],,,,M,,,,,,"hisFuncAccToDelta",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Wrapper around ptAccumulatorToDelta for use as hisFunc\n  \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  grid: ptAccumulatorToDelta(rec, dates)\n  grid.each row => yield(row->ts, row->v0)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptPowerToEnergy",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates energy samples from power samples.\n  \n Virtual point (energy) needs to reference the source point (power)\n  as a pointRef.\n  \n Assuming the power was created from a COV rate, energy is calculated\n  forward, i.e. energy1 = power0 * (ts1 - ts0), given the timestamp ts1.\n  If power is sampled at regular intervals, this creates a slight bias\n  backwards, because ideally in this case we would use\n  energy1 = power1 * (ts2 - ts0)/2 = power1 * (ts1 - ts0) at timestamp ts1.\n  However, if intervals are short enough the results should be acceptable,\n  whereas using the fixed intervals methology on a cov trend could result\n  in large biases.\n  \n Unit conversion relies on core functionalities. Check results.\n \n Arguments:\n *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  // Initialize previous value and previous timestamp trackers\n  prevVal: null\n  prevTs: null\n  rec= if(isRef(rec)) readById(rec) else rec\n  maxGap: if(rec.has(\"hisMaxGap\")) rec->hisMaxGap else 1hr\n\n  rec->pointRef  // Accumulator point\n    .hisRead(dates, {limit: null})\n    .each row => do\n      // All rows that are not first row\n      if (prevVal != null) do\n        deltaTs: row->ts - prevTs\n        if (deltaTs > maxGap) do\n          yield(row->ts, na())\n        end else do\n          energy: prevVal * deltaTs\n          yield(row->ts, energy)\n        end\n      end\n      // Update values\n      prevTs = row->ts\n      prevVal = row->v0\n    end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"queryNerscElastic",,,"/*\n  Copyright 2020 Chris Weyandt\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function queries skyspark-pipeline according\n  to start and end dates. The point must contain an\n  elasticIndix and elasticMetric tag with a fully formed UID\n  \n  example:\n  elasticIndex  =   modbus\n  elasticMetric =   data.host:b59-ups1|data.modbus_point:Output Power\n  \n  Arguments: \n  point         NERSC Elastic point\n  start_date    dateTime object specifying start of ranged query\n  end_date      dateTime object specifying end of ranged query\n\n  // LBNL // CTW // Last Update: 2019-04-24 //\n*/\n\n\n( point, start_date, end_date ) => do\n\n  // convert dateTime to UTC\n  start_date = start_date.toTimeZone(\"UTC\")\n  end_date = end_date.toTimeZone(\"UTC\")\n  \n  // Format datetime strings\n  start_string: start_date.format(\"YYYY-MM-DD'T'hh:mm:ss\")\n  end_string: end_date.format(\"YYYY-MM-DD'T'hh:mm:ss\")\n  \n  // Prepare query\n  baseURI: \"{\\\"index\\\":\\\"\" + \n            point->elasticIndex + \n            \"\\\",\\\"metric\\\":\\\"\" + \n            point->elasticMetric + \n            \"\\\"\"\n  fullURI: baseURI + \n            \",\\\"value\\\":\\\"data.datum\\\",\\\"time\\\":\\\"@timestamp\\\",\\\"start\\\":\\\"<start_time>\\\",\\\"end\\\":\\\"<end_time>\\\"}?elastic\"\n  \n  uri: fullURI.toStr()\n              .replace(\"<start_time>\",start_string)\n              .replace(\"<end_time>\", end_string)\n\n  // Local Python server is running on port 9000\n  query: \"http://128.3.66.91:9000/?\" + uri\n\n  try do\n     // Call ioReadJson to Python server for middleman request\n     // Parse returned timeseries string into JSON format\n     data: ioReadJson(``+query)\n  end catch(ex) do // Catch any errors\n    return {message:\"Error in ioReadJson.\",error:ex}\n  end // end try-catch\n  \n  return data\n   \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"fandocDeficiencyNotes",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyRef, filterStr:\"All\") => do\n  groupId: readById(deficiencyRef)[\"deficiencyGroupRef\"]\n  if (groupId==null) groupId= \"\"\n  notes: if (filterStr==\"All\")\n           readAll((deficiencyNote and deficiencyRef==deficiencyRef) or\n                   (deficiencyGroupNote) and deficiencyGroupRef==groupId)\n         else\n           readAll(deficiencyNote and deficiencyRef==deficiencyRef)\n  \n  if(isEmpty(notes))\n    return \"Deficiency has no associated notes\"\n  \n  doc: \"\"\n  notes.sort((a,b) => a->timestamp <=> b->timestamp)\n       .each((note, n) => do\n    if(doc != \"\") doc= doc+\"\\n\\n---\\n\"\n    doc= doc+\"*On \"+date(note->timestamp).format(\"YYYY-MM-DD (WWW)\")\n            +\" at \"+time(note->timestamp).format(\"hh:mm\")\n            +\", \"+note->author+\" wrote\"\n    if(note.has(\"deficiencyNote\")) doc= doc + \":*\\n\\n\" + note->deficiencyNote+\"\\n\\n---\\n\"\n    else doc= doc + \" (to group):*\\n\\n\" + note->deficiencyGroupNote+\"\\n\\n---\\n\"\n  end)\n  return doc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viMeterConsumption"],,,,M,,,,,,"viMeterConsMonthlySums",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display a grid with the totalized consumption of a given meter's interval data\n  each calendar month, along with meter uptime if available.\n  Optionally, add a column with extrapolated reads from monthly reads if the\n  meter has monthly reads.\n\n  Arguments: \n  meterRef\n  span             Show calendar months included in span\n  removeSparks     Bool, if true, consider data is not valid when there is\n                   any spark on the meter\n  monthlyReads     Bool, if true and the meter has monthly reads, extrapolate\n                   monthly reads to calendar months.\n*/\n(meterRef, span:2015-01-01..today(), removeSparks:true, monthlyReads:false) => do\n  // Process span to force date span and align with calendar months\n  span= span.toDateSpan\n  startDate: if (day(span.start)==1) span.start\n             else date(year(span.start +32day -day(span.start)),\n                       month(span.start +32day -day(span.start)),\n                       1)\n  endDate: if (day(span.end+1day)==1) span.end\n           else date(year(span.end),month(span.end),1) - 1day\n  if (startDate>endDate) return null \n  span= startDate..endDate\n\n  // Find the consumption differential trend associated with the meter, should have delta tag\n  consPoint: read(delta and sensor and not hidden and equipRef->id==meterRef, false)\n  // Exit if not found\n  if (consPoint==null) return null\n\n  // Cycle through calendar months of span and show sum and uptime\n  resGrid: {}.toGrid()\n  span.eachMonth mo => do\n    resGrid= resGrid.addRow(\n        viMeterConsumption([meterRef], mo, removeSparks)\n        .first\n        .set(\"monthStart\",mo.start))\n  end\n  \n  // Format results and return\n  return resGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgUpdateTagSets",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Read tagging standard csv and store tag sets in database\n*/\n\n() => do\n  // Load dependencies\n  try tagSets: ioReadCsv(`io/taggingStandard.csv`)\n  catch\n    return {error: \"io/taggingStandard.csv could not be loaded\"}.toGrid()\n  \n  // Cycle through tagSets from file\n  tagSets.each tagSet => do\n    // If exact match on \"tags\" tag exists, update index\n    if (read(tagSet and tags==tagSet->tags, false)!=null)\n      commit(diff(read(tagSet and tags==tagSet->tags),\n                  {index:tagSet->index}))\n    \n    // Else commit new set\n    else do\n      tagSet= tagSet.set(\"tagSet\", marker())\n      commit(diff(null, tagSet, {add}))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"fandocDataQualityLinks",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Prepare and return fandoc substring containing hyperlinks\n  based on 'links' field of provided dictionary\n  \n  Arguments:\n  qualityRec      Dictionary, containing 'links' tag\n*/\n\n(qualityRec) => do\n  // If provided dictionary does not contain 'links' tag return \"\"\n  try links: qualityRec->links\n  catch return \"\"\n  \n  // If links exists but is an empty list, return \"\"\n  if(isEmpty(links))\n    return \"\"\n  \n  // Begin compiling fandoc string, cycle through links\n  doc: \"\"\n  links.each((link, n) => do\n    // If link is an empty string, skip\n    if (link==\"\") return null\n    \n    // If link is not the first, add a separation\n    if (doc != \"\") doc= doc+\" | \"\n    \n    // Add hyperlink with simple display text\n    doc= doc+\"[Link \"+(n+1).toStr()+\"]\"\n            +\"`\"+link+\"`\"\n  end)\n  \n  if (doc==\"\") return \"\"\n  \n  // If there were valid links, display them as new paragraph\n  return \"\\n\\n\"+doc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["facAhuReqIgnoresJob","facAhuClgReqIgnoresNow","facAhuHtgReqIgnoresNow"],,,,M,,,,,,"facAhuReqIgnoresJob",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Called by job app regularly to execture facAhuClgReqIgnoresNow and other\n  similar functions and write output to points specified in params.\n*/\n\n() => do\n  // B33 AHU-1 & 2 Cooling Requests to Ignore\n  try do\n    clgReqIgnoresPt: readById(@p:lbnl:r:25853024-d96ee9d1) // TEST AV1\n    clgReqIgnores: facAhuClgReqIgnoresNow(\n      read(ahu and siteRef->dis==\"33\" and navName==\"AHU-1 & 2\"),\n      30min,                      // Duration a zone request is valid\n      24hr,                       // Duration a spark disqualifies the zone requests\n      4)                          // Fixed additional number of requests ignored\n    pointWrite(clgReqIgnoresPt,          // Writable point\n               clgReqIgnores,            // Value to write (ignores)\n               16,                       // BACnet priority\n               \"facAhuReqIgnoresJob\")    // Source\n  end catch (ex) logErr(\"facAhuReqIgnoresJob\",\n                        \"Failed to calculate or write ignored cooling requests: \" + ex->dis)\n\n  // B33 AHU-1 & 2 Heating Requests to Ignore\n  try do\n    htgReqIgnoresPt: readById(@p:lbnl:r:25853035-8d285edb) // TEST AV2\n    htgReqIgnores: facAhuHtgReqIgnoresNow(\n      read(ahu and siteRef->dis==\"33\" and navName==\"AHU-1 & 2\"),\n      30min,                      // Duration a zone request is valid\n      24hr,                       // Duration a spark disqualifies the zone requests\n      4)                          // Fixed additional number of requests ignored\n    pointWrite(htgReqIgnoresPt,          // Writable point\n               htgReqIgnores,            // Value to write (ignores)\n               16,                       // BACnet priority\n               \"facAhuReqIgnoresJob\")    // Source\n  end catch (ex) logErr(\"facAhuReqIgnoresJob\",\n                        \"Failed to calculate or write ignored heating requests: \" + ex->dis)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAVOcc",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For all vav equip with tmpTest20180425 tag, integrate\n  occupancy sensor trends\n*/\n\n() => do\n  readAll(conn and bacnetConn and vavZn and siteRef->dis==\"Building 33\" and locationRef->dis!=\"B33 Floor 1\")\n  .each connector => do\n    vavEq: readAll(equip and vav and locationRef==connector->locationRef)\n           .find eq => eq->navName==connector->vavZn\n    \n    bHisRow: bacnetLearn(connector, `TREND_LOG`)\n             .find row => row[\"dis\"].contains(\"occ_sensor\")\n    \n    if (bHisRow != null) do\n      bHis: (bacnetLearn(connector, `TREND_LOG`)\n             .find row => row[\"dis\"].contains(\"occ_sensor\"))->bacnetHis\n           \n      bCur: (bacnetReadObject(connector, bHis)\n            .find row => row->propertyName==\"LOG_DEVICE_OBJECT_PROPERTY\"\n                         and row->bacnetValueType==\"ObjectId\")\n            ->value\n    \n      commit(diff(\n        null,\n        {navName: \"Occupancy Sensor\",\n         disMacro: \"\\\$equipRef \\\$navName\",\n         bacnetConnRef: connector->id,\n         bacnetCur: bCur,\n         bacnetHis: bHis,\n         connRef: connector->id,\n         equipRef: vavEq->id,\n         his,\n         kind: \"Bool\",\n         point,\n         locationRef: vavEq->locationRef->id,\n         occupancyIndicator,\n         sensor,\n         siteRef: vavEq->siteRef->id,\n         tmpTest20180426,\n         tz: \"Los_Angeles\"\n        },\n        {add}\n      ))\n    end\n  end\nend\n\n/*\n\nbacnetLearn(@p:lbnl:r:2273d3da-2d207f7e, `TREND_LOG`)\n.find row => row[\"dis\"].contains(\"occ\")\nThen read column bacnetHis to get \"TL4\" or \"TL5\", etc...\n\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viBacnetConnMiss",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  bacnetCur and bacnetHis work in conjunction with bacnetConnRef. This\n  function finds points that have a bacnetCur or bacnetHis but are\n  missing a bacnetConnRef.\n  Return grid with:\n    id:            point id\n    connRef:       ref\n    bacnetConnRef: ref\n    bacnetCur:     text\n    bacnetHis:     text\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  miss: readAll(point and (bacnetCur or bacnetHis) and not bacnetConnRef)\n        .map(row =>\n          {id: row->id,\n           connRef: row[\"connRef\"],\n           bacnetConnRef: row[\"bacnetConnRef\"],\n           bacnetCur: row[\"bacnetCur\"],\n           bacnetHis: row[\"bacnetHis\"]\n          }\n         )\n         \n  if (isEmpty(miss))\n    miss = {success: \"No missing bacnetConnRef\"}\n           .toGrid\n  \n  return miss\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"deficiencyHasResponses",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given deficiency and a given user, return true if the latest deficiency\n  note was posted by another user.\n  \n  Arguments: \n  deficiencyId\n  userDis      User's display name\n*/\n\n(deficiencyId, userDis:null) => do\n  grid: readAll(deficiencyNote and deficiencyRef==deficiencyId)\n  if (isEmpty(grid)) return false\n  \n  // Select latest\n  latest: grid.sortr((a,b) => a->timestamp <=> b->timestamp)\n              .first\n  \n  if (userDis==null) return true\n  if (latest->author == userDis) return false\n  return true\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Elec Usage (kWh)",,M,"Site electrical consumption over time period.",,,"site",,"kpiElecUsage",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(energy and delta and sensor and not hidden and equipRef->elec\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n           \n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisClip\n\n  kpiSum: his.foldCol(\"v0\", sum)\n  if (na() == kpiSum) null else {sum: kpiSum.as(1)}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecTags"],,,,M,,,,,,"viTaggingNonCompliance",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This displays points which ids are not listed in\n  `io/tagging/taggingStandardMatches.csv`, and lists their non-ignored tags\n  \n  Return grid with:\n    nonCompliantId   id of point\n    [[tags not ignored]]\n  \n  Arguments:\n  filter        text, filter to determine set of records to analyze,\n                default is \"point and not weatherPoint\"\n*/\n\n(filter: \"point and not weatherPoint\") => do\n  // Test if provided filter is valid, and create associated query\n  try\n    query : parseFilter(filter, true)\n  catch do\n    query : parseFilter(\"point and not weatherPoint\", true)\n  end\n\n  points: readAll(query)\n  compliant: ioReadCsv(`io/tagging/taggingStandardMatches.csv`)\n             .colToList(\"val\").map v => parseRef(v)\n  \n  notCompliant: points.map(pt => do\n    if (compliant.contains(pt->id)) do\n      res: {nonCompliantId: null}\n    end else do\n      res: {nonCompliantId: pt->id}\n      toolRecTags(pt->id).each(tag => do res= res.set(tag, pt[tag]) end)\n    end\n    res\n  end)\n  .findAll(pt => pt[\"nonCompliantId\"] != null)\n  \n  if (isEmpty(notCompliant)) do\n    notCompliant = {success: \"All points comply with standard\"}\n           .toGrid\n  end else do // Reorder cols\n    names: notCompliant.colNames().findAll(v => v != \"nonCompliantId\")\n    names= names.sort((a,b) => a <=> b)\n    names= names.insert(0, \"nonCompliantId\")\n    notCompliant= notCompliant.reorderCols(names)\n  end\n  \n  return notCompliant\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"intgMaintainTree",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Perform maintenance operations on the equipment tree\n  \n  Includes:\n  Create or update equipRef for submeters located in the same location\n*/\n\n() => do\n  // Create or update equipRef for submeters located in the same location\n  readAll(meter and submeterOf)\n  .each meterRec => do\n    upMeterRec: readById(meterRec->submeterOf, false)\n    if (upMeterRec!=null and meterRec->locationRef == upMeterRec->locationRef)\n      commit(diff(meterRec, {equipRef:upMeterRec->id}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgCachePointMatch",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given BACnet connector, review previously cached objects. Search\n  already-integrated points and match cached objects with points.\n*/\n\n(connRef) => do\n  // If record is passed instead of id, retrieve id\n  if (not(isRef(connRef)))\n    try connRef= connRef->id\n    catch return {error: \"Incorrect input argument. \"\n                  + \"Expected ID of a connector object.\"}\n                 .toGrid()\n                 \n  // Obtain list of cached non-TL objects for connector\n  curs: readAll(connPointCache and connRef==connRef\n                and bacnetCur)\n  \n  // Cycle through non-TL objects and search for point matches\n  curs.each cur => do\n    // Attempt match on connRef + bacnetCur\n    pt: read(point and bacnetCur==cur->bacnetCur\n             and connRef==cur->connRef, false)\n    \n    // Update bacnetCur\n    if (pt != null)\n      commit(diff(cur, {pointRef: pt->id}))\n  end\n  \n  // Obtain list of cached TL objects for connector\n  tls: readAll(connPointCache and connRef==connRef\n                and bacnetHis and not bacnetCur)\n  \n  // Cycle through TL objects and search for point matches\n  tls.each tl => do\n    // Attempt match on connRef + bacnetHis\n    pt: read(point and bacnetHis==tl->bacnetHis\n             and connRef==tl->connRef, false)\n    \n    // Update bacnetCur\n    if (pt != null)\n      commit(diff(tl, {pointRef: pt->id}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viCyclesOfConSumTable",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all makeup and blowdown meters and analyze their data over a\n  given period of time, calculating total volumes and overall cycles\n  of concentration.\n  Return grid with:\n    summary    Text, summary variable name (makeup, blowdown, cycles)\n    total      Number, summary variable value\n    meters     Number, number of meters found\n  \n  Arguments: \n  span         Date span to analyze and summarize\n*/\n\n(span) => do\n  result: {}.toGrid\n  \n  // Find blowdown water volume records\n  blowdownR: readAll(delta and volume and sensor and not hidden and\n                     equipRef->blowdown and equipRef->water and equipRef->meter)\n  \n  // Calculate total volume over span\n  blowdownT: blowdownR\n             .map(pt => {tot: pt.hisRead(span).hisClip.foldCol(\"v0\", sum)})\n             .foldCol(\"tot\", sum) \n             \n  // List of location ids for locationss with blowdown meter\n  locIds: blowdownR.colToList(\"locationRef\")\n             \n  // Find makeup water volume records\n  makeupR: readAll(delta and volume and sensor and not hidden and\n                  equipRef->makeup and equipRef->water and equipRef->meter)\n           .findAll(rec => locIds.contains(rec->locationRef))\n  \n  // Calculate total volume over span\n  makeupT: makeupR\n           .map(pt => {tot: pt.hisRead(span).hisClip.foldCol(\"v0\", sum)})\n           .foldCol(\"tot\", sum)\n  \n  // Calculate overall cycles of concentration over span\n  cc: (makeupT / blowdownT).as(\"_cycles\")\n  \n  // Format and return results table\n  result\n  .addRow({campusSummary: \"Makeup Water Volume\", total: makeupT, metersFound: makeupR.foldCol(\"id\", count)})\n  .addRow({campusSummary: \"Blowdown Water Volume\", total: blowdownT, metersFound: blowdownR.foldCol(\"id\", count)})\n  .addRow({campusSummary: \"Cycles of Concentration\", total: cc, metersFound: null})\n  .reorderCols([\"campusSummary\",\"total\",\"metersFound\"])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolSplitTrends"],,,,M,,,,,,"viB59PUEPrePostScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Given a specific date, give the baseline and last week (or selected range) data for\n  CT Fan Power, CW Pump Power and TW Pump Power. Present the data\n  as a scatter chart of combined power vs OA WB Temp data at B59 (in °F). \n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01), dateRangePost: lastWeek().toSpan(), min: null, max: null, pueNavName:null, hisInt:15min) => do\n  //Reference B59 for siteRef\n    bldgRefId: @p:lbnl:r:221f652e-4f67467f\n\n  // Default to PUE, Level 1 if no selection is made\n  if(pueNavName==null)\n    pueNavName= \"PUE, Level 1\"\n  else \n    pueNavName= \"PUE, \"+ pueNavName\n    \n  // Define full range from pre and post date ranges\n  rangeStart: dateRangePre.start().date()\n    rangeEnd: dateRangePost.end().date()\n  \n   fullRange: toDateSpan(rangeStart..rangeEnd)\n\n  // Look up B59 Data Center Computers for compute power filter\n  compRef: read(siteRef==bldgRefId and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id  \n\n  // Get compute power for given computers filter\n  compFilter: read(equipRef==compRef and compute and meter and virtual and equip)\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n\n  // Get the PUE trend for this siteRef and hisInterval\n  pue: read(siteRef==bldgRefId and navName==pueNavName and pue and point and hisInterval==hisInt)\n\n  // Default to B59 TW for wbRef\n  wbRef: read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n         // Get Outside Air Wetbulb from wbRef\n         oaWB: read(equipRef==wbRef and wetBulb)\n                //read OA WB history\n                oaWetBulb: hisRead(oaWB, fullRange, {limit:null})\n                    .renameCol(\"v0\",\"oaWB\")\n  \n  // Interpolate, filter the pue\n  pueTrend: hisRead(pue,fullRange,{limit:null})\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"pue\")\n  \n  // use toolSplitTrends to highlight the post range\n   puePost:   toolSplitTrends(pueTrend, dateRangePost)\n                   .renameCol(\"pue0\",\"postPUE\")\n                   .removeCol(\"pue\")\n                   \n  // use toolSplitTrends to highlight the pre range\n   puePre:   toolSplitTrends(pueTrend, dateRangePre)\n                  .renameCol(\"pue0\",\"prePUE\")\n                  .removeCol(\"pue\")\n   \n   pueTrend = hisJoin([puePost,puePre])\n  \n  //select columns to be used in graph and convert na values to null\n   selectCols:  pueTrend.colNames().findAll(v => v != \"ts\")\n                   .insert(0, \"oaWB\")\n\n  //define compute power filter\n   powerFilter: hisRead(compPower, fullRange, {limit:null})\n  // Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))\n  \n  // join wetbulb and total power pre trend to prep for the scatter chart\n  // add title and meta to graph\n   graphPre: hisJoin([oaWetBulb, pueTrend])\n                 .hisFindInPeriods(powerFilter)\n                 .keepCols(selectCols)\n                 .addMeta({chartType: \"scatter\",\n                          title: \"NERSC PUE (Baseline vs. Post)\"})\n                 .addColMeta(\"oaWB\", {chartMin: 40°F, chartMax: 70°F}) \n                 .addColMeta(\"postPUE\", {dis: \"Present PUE \"+dateRangePost,\n                              color: \"#DE3E30\"}) \n                 .addColMeta(\"prePUE\", {dis: \"Baseline PUE \"+dateRangePre,\n                              color: \"#7ED7DE\"})\n                                 \n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Gas Usage (therm)",,M,"Site gas consumption over time period.",,,"site",,"kpiGasUsage",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(energy and delta and sensor and not hidden and equipRef->gas\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n           \n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisMap(val => val.to(1therm)).hisClip\n\n  kpiSum: his.foldCol(\"v0\", sum)\n  if (na() == kpiSum) null else {sum: kpiSum.as(1)}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"roomPressureReportList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(siteRef, floorRef, equipRef, setPoints, alarms, control, interface) => do\n  grid: if (siteRef==null)\n          readAll(roomPressureReports)\n        else\n          readAll(roomPressureReports and siteRef==siteRef)\n          \n  if(isEmpty(grid)) return null\n  \n  \n  disCols: [\"id\", \"date\", \"building\", \"lab number\"]\n  \n  return grid.toolFormatGrid(disCols)\n             .sort((a,b) => a.dis() <=> b.dis())\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anRegElecCddApply_v1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Apply regression coefficients for daily natural elec usage versus cdd,\n  with factor of weekday / weekend (total 2 variables).\n  Return grid with timestamps and fitted values.\n  \n  Arguments: \n  meterUsageRef      Ref of elec meter usage data point to model\n  dateSpan           Span of dates to perform analysis on\n  regResults         Regression results, including calculated coeffs\n\n  Notes:\n  For degree days calculation, the weather station associated with\n  the site associated with the meter usage point is used. Function\n  will fail if weatherRef is not defined on the corresponding site.\n*/\n\n(meterUsageRef, dateSpan, regResults) => do\n  // Read outside air temperature from weather station associated with\n  //   meterUsage point, and calculate degree days\n  cdd: read(weatherRef==readById(meterUsageRef)->siteRef->weatherRef\n            and weatherPoint and air and temp  // OAT is input to degreeDays\n            and not secondary)  // Do not use secondary sensor if one exists\n       .degreeDays(dateSpan, regResults[\"ddRefTemp\"])\n       .keepCols([\"ts\",\"cool\"])\n       \n  // Calculate fitted values using coefficients\n  intercept: regResults[\"intercept\"]\n  slope: null\n  slopeWeekday: regResults[\"slopeWeekday\"]\n  slopeWeekend: regResults[\"slopeWeekend\"]\n  refValue: 1kWh  //.as(regResults[\"measuredAvg\"])\n  dataset: cdd.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->cool).as(refValue)\n    end)\n    \n  return dataset.keepCols([\"ts\", \"fittedUsage\"])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anHillGasRemainder",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  \n*/\n\n() => do\n  // Refer to monthly hill sum meter\n  sumMeter: read(gas and meter and sblids and navName==\"Gas Meter - Monthly Hill Sum, All + UC\")\n  \n  // Refer to main Hill + UC meter, then find consumption point (daily data)\n  mainMeter: read(gas and meter and navName==\"Hill & UC Gas Meter\")\n  mainMeterPt: read(delta and energy and sensor and not hidden and equipRef==mainMeter->id)\n  \n  // Refer to remainder hill gas meter\n  remMeter: read(gas and meter and navName==\"Gas Meter - Monthly Hill Remainder\")\n  \n  // Process SUM meters\n  tagU: if (sumMeter.has(\"gas\")) \"gas\" else \"elec\"\n  tUnit: if (sumMeter.has(\"gas\")) \"therm\" else \"kWh\"\n  grid: {}.toGrid()\n  g: readAll(monthlyRead)\n     .findAll(mR => do\n       mRMeter: readById(mR->meterRef)\n       return (mRMeter.has(tagU) and sumMeter->sblids.split(\",\").contains(mRMeter->sblid))\n       end)\n  g.colToList(\"readDate\").unique()\n  .each(rD => do\n    subG: g.findAll(r => r->readDate==rD)\n    // For the purpose of this remainder meter, include all ignores except \"Replaced\"\n    if (subG.all(r => (r.missing(\"ignore\") and r.missing(\"estimated\")) and r[\"consumption\"]!=null))\n      grid= grid.addRow({readDate: rD, totalizedConsumption:subG.foldCol(\"consumption\", sum)})\n    else\n      grid= grid.addRow({readDate: rD,\n                         totalizedConsumption:subG\n                           .findAll(r => r.missing(\"ignore\") or \n                                         not(reMatches(r\"Replaced.*\",r[\"ignore\"])))\n                           .foldCol(\"consumption\", sum), \n                         ignore:\"Includes ignored or estimated reads\"})\n  end)\n  grid= grid.sort((a,b) => a->readDate <=> b->readDate)\n  \n  // Add explicit start and end dates, inclusive\n  readDates: grid.colToList(\"readDate\")\n  startInc: readDates.insert(0, null).remove(-1)\n  endInc: readDates.map(v=>v-1day)\n  grid= grid.addCol(\"start\", (r,i) => startInc[i])\n            .addCol(\"end\", (r,i) => endInc[i])\n            \n  // Totalize daily reads from main meter for each monthly read\n  grid= grid.addCol(\"mainConsumption\", r =>\n    if (r.has(\"start\") and \n        r[\"start\"].dateTime(time(0,0,0), mainMeterPt->tz) >= mainMeterPt->hisStart and\n        r[\"end\"].dateTime(time(0,0,0), mainMeterPt->tz) <= mainMeterPt->hisEnd)\n      mainMeterPt\n      .hisRead(r[\"start\"]..r[\"end\"], {limit:null})\n      .hisClip\n      .foldCol(\"v0\",sum)\n    else null\n  )\n    \n  // Calculate remainder\n  grid= grid.addCol(\"remainder\", r =>\n    if(r.has(\"mainConsumption\") and r.has(\"totalizedConsumption\"))\n      r[\"mainConsumption\"] - r[\"totalizedConsumption\"]\n    else null\n  )\n  \n  // Remove old, store new monthly remainders\n  readAll(monthlyRead and meterRef==remMeter->id)\n  .each rec => commit(diff(rec, {trash}))\n  \n  grid.each r => do\n    if (r.has(\"remainder\")) do\n      dict: {\n        monthlyRead,\n        meterRef: remMeter->id,\n        readDate: r->readDate,\n        consumption: r->remainder\n      }\n      commit(diff(null, dict, {add}))\n    else return null\n  end\n  \n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anCyclesOfConcentration",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Takes a siteRef and a time period, retrieves the makeup and blowdown meter data\n  (if meters are present). Take a rollup time window, and calculates cycles of\n  concentration over the corresponding windows.\n  Return grid with:\n  ts                 Timestamp\n  cc                 Cycles of concentration, Number, no unit\n  \n  Arguments: \n  siteRef            Ref, site\n  span               Dates span to calculate daily cycles of concentration on\n  rollup             Time, default 1day, to roll up data over before calculating\n*/\n\n(siteRef, span, rollup: 1day) => do\n  // Find meters associated with site\n  makeupR: readAll(delta and volume and sensor and\n                   not hidden and\n                   equipRef->makeup and equipRef->water and equipRef->meter and \n                   siteRef==siteRef)\n  blowdownR: readAll(delta and volume and sensor and\n                     not hidden and\n                     equipRef->blowdown and equipRef->water and equipRef->meter and \n                     siteRef==siteRef)\n  \n  tsFormat: if(rollup < 1day) \"MMM DD, hh:mm\"\n            else if (rollup < 1mo) \"WWW MMM DD\"\n            else \"MMM\"\n  \n  // Return error messages as needed\n  if (isEmpty(makeupR) or isEmpty(blowdownR))\n  return {error: \"Site does not have associated makeup and/or blowdown meters\"}\n         .toGrid\n         \n  if (makeupR.foldCol(\"id\", count) > 1 or blowdownR.foldCol(\"id\", count) > 1)\n  return {error: \"Site has more than one associated makeup and/or blowdown meters\"}\n         .toGrid\n  \n  // Read and rollup historical data\n  makeup: makeupR.first.hisRead(span, {limit: null})\n          .hisClip.hisRollup(sum, rollup)\n  blowdown: blowdownR.first.hisRead(span, {limit: null})\n            .hisClip.hisRollup(sum, rollup)\n  cdd: read(weatherPoint and main and air and temp)\n       .degreeDays(span, 50°F).keepCols([\"ts\", \"cool\"])\n       .hisRollup(sum, rollup)\n\n  // Calculate cycles of concentration and return result\n  cc: hisJoin([makeup, blowdown, cdd])\n  cc = cc.map row => do\n    cycle: null\n    if (row[\"v0\"] != null and row[\"v0\"] >0 and row[\"v1\"] != null and row[\"v1\"] > 0)\n      cycle= (row->v0 / row->v1).as(\"_cycles\")\n    return {ts: row->ts,\n            cdd: row[\"cool\"],\n            cc: cycle,\n            makeup: row[\"v0\"],\n            blowdown: row[\"v1\"]\n           }\n  end\n  \n  cc= cc.addColMeta(\"cdd\", {dis: \"LBL Cooling Degree Days Base 50°F\",\n                            chartType:\"bar\", chartGroup:\"1\", color: \"#ffddcc\"})\n  cc= cc.addColMeta(\"cc\", {dis: makeupR.first->locationRef->dis\n                                + \" Cycles of Concentration\",\n                           chartType:\"bar\", chartGroup:\"2\", color: \"#000000\"})\n  cc= cc.addColMeta(\"makeup\", {dis: makeupR.first->locationRef->dis\n                                    + \" Makeup Volume\",\n                               chartType:\"bar\", chartGroup:\"3\", color: \"#1ab2ff\"})\n  cc= cc.addColMeta(\"blowdown\", {dis: makeupR.first->locationRef->dis\n                                      + \" Blowdown Volume\",\n                                 chartType:\"bar\", chartGroup:\"3\", color: \"#9933ff\"})\n  cc= cc.map(row => do\n    // Dict without ts\n    dict: row.remove(\"ts\")\n    dict= dict.set(\"ts\", row->ts.format(tsFormat))\n    return dict\n  end)\n  \n  cc= cc.reorderCols(cc.colNames().moveTo(\"ts\",0))\n                                      \n  return cc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viTaggingStandardStats",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This displays the number of points and number of compliant points\n  Return grid with columns:\n    numPoints        total number of points\n    numCompliant     total number of points compliant with tagging standard\n  \n  Arguments:\n  None\n*/\n\n() => do\n  {numPoints: readAll(point and not weatherPoint).foldCol(\"id\", count),\n   numPointsCompliantTaggingStandard: ioReadCsv(`io/tagging/taggingStandardMatches.csv`)\n                                      .foldCol(\"val\",count),\n   numPointsUntagged: readAll(point and untagged).foldCol(\"id\", count)}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"tmpMap06HHW",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_b6/b6_hhw.csv`\n to add these points to zone equips that already exist.\n  \n The file includes a match to the 2018-10-22 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(types: [0,1,2,3,4,5,19,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b6/b6_hhw.csv`)\n  \n  i: 0\n  \n  // Cycle through connectors\n  alcPtList.unique(\"connRef\").colToList(\"connRef\").each connRef => do\n    // Load bacnet info for connector\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, \"MS\", \"TL\"]\n    \n    connectorId: parseRef(connRef)\n    types.each type => do\n      learn: bacnetLearn(connectorId, type)\n      bacnetPtList= bacnetPtList.set(type, learn)\n    end\n  \n    // Cycle through points of interest on given connector\n    alcPtList.findAll(row => row->connRef == connRef).each row => do\n      // Update job message\n      jobProgress((i / alcPtList.size())*100.as(1%), row->alcDisplay)\n      i= i+1\n      \n      // Find related equip\n      eq: readById(parseRef(row->eq))\n      \n      // Get info from bacnetPtList by matching bacnetCur\n      curType: row->bacnetCur[0..1]\n      bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n      if (bacnetGrid == null) bacnetGrid= [].toGrid()\n      bacnetCurRow: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n      if (bacnetCurRow == null)\n        bacnetCurRow= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n        \n      // Find bacnetHis\n      bacnetHisGrid: bacnetPtList[20]\n      if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n      bacnetHisRow: bacnetHisGrid.find(his => his[\"dis\"]==row[\"bacnetHisName\"])\n      if (bacnetHisRow == null) bacnetHisRow= {}\n\n      // Prepare new point dict\n\t\t\tptDict: {point,\n\t\t\t\t\t disMacro: \"\\\$equipRef \\\$navName\",\n\t\t\t\t\t bacnetConnRef: connectorId,\n\t\t\t\t\t connRef: connectorId,\n\t\t\t\t\t cur,\n\t\t\t\t\t bacnetCur: row->bacnetCur,\n\t\t\t\t\t bacnetHis: bacnetHisRow[\"bacnetHis\"], //optional\n\t\t\t\t\t bacnetCurName: row->bacnetCurName,\n\t\t\t\t\t bacnetHisName: row[\"bacnetHisName\"],\n\t\t\t\t\t kind: bacnetCurRow[\"kind\"], //optional\n\t\t\t\t\t unit: bacnetCurRow[\"unit\"], //optional\n\t\t\t\t\t enum: bacnetCurRow[\"enum\"], //optional\n\t\t\t\t\t equipRef: eq->id,\n\t\t\t\t\t his,\n\t\t\t\t\t notes: row[\"alcDisplay\"], //optional\n\t\t\t\t\t locationRef: eq->locationRef,\n\t\t\t\t\t siteRef: eq->siteRef,\n\t\t\t\t\t tz: \"Los_Angeles\",\n\t\t\t\t\t tmp: today()}\n      \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      if (finalize)\n        commit(diff(null, ptDict, {add}))\n        \n    end // Cycle through points\n  end // Cycle through connectors\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"bacnetObjType",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze a given, valid BACnet object name and return the BACnet\n  object type in text and numeric format (e.g. ANALOG_INPUT, 0)\n*/\n\n(bacnetObjName: \"1:123\") => do\n  file: ioReadCsv(`io/config/bacnet_obj_types.csv`)\n  \n  // Case 0, e.g. AI123\n  if (reMatches(r\"([A-Z]{2,3})(\\d*)\",bacnetObjName)) do\n    abbr: reGroups(r\"([A-Z]{2,3})(\\d*)\",bacnetObjName)[1]\n    match: file.find(row => row[\"abbr\"]==abbr)\n    if (match==null) return null\n    return {}.set(\"learn\",match->int).set(\"dis\",match->name)\n  end\n  \n  // Case 1, e.g. 1:123\n  if (reMatches(r\"(\\d{1,2}):(\\d*)\",bacnetObjName)) do\n    index: reGroups(r\"(\\d{1,2}):(\\d*)\",bacnetObjName)[1]\n    match: file.find(row => row[\"int\"]==index)\n    if (match==null) return null\n    return {}.set(\"learn\",match->int).set(\"dis\",match->name)\n  end\n  \n  // Case 2, e.g. ANALOG_INPUT:123\n  if (reMatches(r\"([a-zA-Z_]*):(\\d*)\",bacnetObjName)) do\n    name: reGroups(r\"([a-zA-Z_]*):(\\d*)\",bacnetObjName)[1]\n    match: file.find(row => row[\"name\"]==name)\n    if (match==null) return null\n    return {}.set(\"learn\",match->int).set(\"dis\",match->name)\n  end\n  \n  return null\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
M,[],,,,M,"Apply regression coefficients for daily natural gas usage versus HDD, with factor of weekday / weekend",,,,M,"anRegGasHddApply_v1","dailyGasHDD",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Apply regression coefficients for daily natural gas usage versus HDD,\n  with factor of weekday / weekend (total 2 variables).\n  Return grid with timestamps and fitted values.\n  \n  Arguments: \n  meterUsageRef      Ref of gas meter usage data point to model\n  dateSpan           Span of dates to perform analysis on\n  regResults         Regression results, including calculated coeffs\n\n  Notes:\n  For degree days calculation, the weather station associated with\n  the site associated with the meter usage point is used. Function\n  will fail if weatherRef is not defined on the corresponding site.\n*/\n\n(meterUsageRef, dateSpan, regResults) => do\n  // Read outside air temperature from weather station associated with\n  //   meterUsage point, and calculate degree days\n  hdd: read(weatherRef==readById(meterUsageRef)->siteRef->weatherRef\n            and weatherPoint and air and temp  // OAT is input to degreeDays\n            and not secondary)  // Do not use secondary sensor if one exists\n       .degreeDays(dateSpan, regResults[\"ddRefTemp\"])\n       .keepCols([\"ts\",\"heat\"])\n       \n  // Calculate fitted values using coefficients\n  intercept: regResults[\"intercept\"]\n  slope: null\n  slopeWeekday: regResults[\"slopeWeekday\"]\n  slopeWeekend: regResults[\"slopeWeekend\"]\n  refValue: 1.as(regResults[\"measuredAvg\"])\n  dataset: hdd.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->heat).as(refValue)\n    end)\n    \n  return dataset.keepCols([\"ts\", \"fittedUsage\"])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["foldSample"],,,,M,,,,,,"toolHisGridShowGaps",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given history grid, detect data gaps longer than the\n  given threshold and insert NA() value to show gap.\n  \n  Arguments:\n  hisGrid         History grid to analyze\n  maxGap          Number (time), longest allowed gap between readings\n  tagsFilter      Only highlight gaps in points that match filter\n*/\n\n(hisGrid, maxGap:1min,\n tagsFilter:\"(not hisMode or hisMode!=\\\"cov\\\") and kind==\\\"Number\\\"\") => do\n  // Create filter from tagsFilter string\n  filterFunc: filterToFunc(tagsFilter.parseFilter)\n  \n  // Determine selected grid and remaining grid\n  selColNames: hisGrid.removeCol(\"ts\").colNames\n               // Only highlight gaps in points that match filter\n               .findAll(colName =>\n                 filterFunc(hisGrid.col(colName).meta))\n               // Unselect columns with only null or na() values\n               .findAll(colName =>\n                 hisGrid.colToList(colName)\n                        .any v => (v != null and v != na()))\n  // Selected grid is the grid in which data gaps will be analyzed\n  selGrid: hisGrid.keepCols([\"ts\"].addAll(selColNames))\n                  .findAll(row => row.remove(\"ts\").any(v => v!= null))\n  // Remaining grid columns will be passed through \"as is\"\n  remGrid: hisGrid.removeCols(selColNames)\n                  .findAll(row => row.remove(\"ts\").any(v => v!= null))\n\n  // Add NAN for detected gaps in selected grid\n  nanGrid: selGrid\n           .hisRollup(foldSample, maxGap)\n           .map(row => row.map((val, name) =>\n               if (name==\"ts\") return val\n               else if (val==null) return na()\n               else return val))\n           .findAll(row => row.any(v => v==na()))\n  selGrid= selGrid\n           .addRows(nanGrid)\n           // After adding NaN rows, resort by chronological order\n           .sort((a,b) => a[\"ts\"] <=> b[\"ts\"])\n  selGrid= selGrid.reorderCols(selGrid.colNames.moveTo(\"ts\",0))\n  \n  // Merge selected and remaining grids back and return\n  return hisJoin([selGrid,remGrid])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends","toolHisGridShowGaps","viTargetsDeficiencies","toolRecursiveSearch","foldAny","toolHisFoldColsByTags","toolHisRollupAuto"],,,,M,,,,,,"viZoneTrends_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display data trends associated with a given zone, and SAT and DSP\n  trends from the AHU associated with the first VAV equip that serves\n  that zone.\n  \n  Option to display all points in sub-equips or summary points.\n  \n  Format trends and return as chart grid.\n  \n  Arguments: \n  zoneId          Id, reference to zone equip\n  dates           DateSpan, dates of data to display\n  ptsSelect       String, \"All\" or \"Typical\", describes points to display\n  summarizeByTags Bool, if true, use pre-programmed folds by tags\n  faults          Str, if \"Summary Faults\", show one summary of all sparked rules \n                  and one summary of all deficiencies. If \"All\", show all the\n                  sparked rules and all the active deficiencies.\n  groupSelect     Str\n*/\n\n(zoneId, span: today()-3day..today()-1day,\n ptsSelect: \"Typical Points\", summarizeByTags: true,\n faults: \"Summary Faults\", groupSelect: \"Typical Groups\",\n rollupSelect: \"Auto Rollup\") => do\n  // Parameters\n  maxGap: 30min\n  \n  // Load toolFormatTrendsOptions parameters\n  defaultOpts: read(toolFormatTrendsOptions and default)\n  userOpts: try read(toolFormatTrendsOptions\n                     and username==userCur()->username)\n            catch {}\n  \n  // Options processing\n  if (rollupSelect==\"Minimum 1min\") minRollup: 1min\n  else if (rollupSelect==\"Minimum 5min\") minRollup: 5min\n  else if (rollupSelect==\"Minimum 10min\") minRollup: 10min\n  else if (rollupSelect==\"Minimum 15min\") minRollup: 15min\n  else minRollup: 0min\n \n  // Attempt to find zone, exit if no zone found\n  zone: if (isRef(zoneId)) readById(zoneId) else zoneId\n  if (not(zone.has(\"zone\")))\n    return {error: \"Selected record is not a zone\"}.toGrid()\n  \n  // Point selection\n  zonePtsStr: if (ptsSelect==\"All Points\")\n                \"point and not raw\"\n              else if (ptsSelect==\"ZAT Controls\")\n                \"((air or slab) and temp) \" +\n                \"or (water and temp and (entering or leaving))\" +\n                \"or (flow and (equipRef->supply or supply)) \" +\n                \"or (valve or ((cool or heat) and pid))\"\n              else if (ptsSelect==\"Typical Points\")\n                \"(damper or valve or ((air or slab) and temp) \" +\n                \"or (flow and not equipRef->zone) \" +\n                \"or (pressure and not cmd) \" +\n                \"or (zone and occupied and sensor))\"\n  \n  // Retrieve recs of all points in zone or sub-equips that match\n  // string filter zonePtsStr\n  subPts: toolRecursiveSearch(zone->id, zonePtsStr)\n  \n  // Find the AHU associated with the 1st supply terminal unit in zone\n  supplyTUs: readAll(supply and terminalUnit and ahuRef and equip\n                     and (equipRef==zone->id or zoneRef==zone->id))\n  if (isEmpty(supplyTUs)\n      or supplyTUs.first[\"ahuRef\"]==null\n      or ptsSelect==\"ZAT Controls\")\n    graphPts: subPts\n  else do\n    ahuId: supplyTUs.first->ahuRef\n    ahuPts: readAll(point and his and not raw\n                    and discharge and air and (temp or pressure)\n                    and equipRef==ahuId)\n    graphPts: subPts.addRows(ahuPts)\n  end\n  \n  // Load trend history and apply minimum rollup if > 0\n  hisGrid: graphPts.hisRead(span, {limit: null})\n\n  // Exit if no trends were found\n  if (isEmpty(hisGrid)) return null\n\n  // Create summary points as needed\n  if (summarizeByTags) do\n    hisGrid= hisGrid\n    .toolHisFoldColsByTags(tagsFilter: \"flow\",\n        foldFunc: sum, rollupFunc: avg, minRollup, removeMissing: true)\n    .toolHisFoldColsByTags(tagsFilter= \"temp\",\n        foldFunc= avg, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(tagsFilter= \"damper\",\n        foldFunc= max, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(tagsFilter= \"valve\",\n        foldFunc= max, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(tagsFilter= \"pressure and not request\",\n        foldFunc= avg, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(\"occupied\",           // tagsFilter\n                           foldAny, foldAny,     // foldFunc, rollupFunc\n                           minRollup, true)      // minRollup, removeMissing\n    .toolHisFoldColsByTags(\"request\",            // tagsFilter\n                           sum, avg,             // foldFunc, rollupFunc\n                           minRollup, true)      // minRollup, removeMissing\n    .toolHisFoldColsByTags(\"air and speed\",      // tagsFilter\n                           avg, avg,             // foldFunc, rollupFunc\n                           minRollup, true)      // minRollup, removeMissing\n  end\n  \n  // Show data gaps and apply minRollup\n  hisGrid= hisGrid.toolHisGridShowGaps(maxGap)\n                  .toolHisRollupAuto(minRollup)\n\n  // Add detected periods from sparkRules\n  ruHis: if (isEmpty(toolRecursiveSearch(zone->id, \"equip\"))) {}.toGrid\n         else ruleSparks(toolRecursiveSearch(zone->id, \"equip\"),\n                         span, readAll(sparkRule))\n              .ruleSparkHis()\n  \n  if (faults==\"Summary Faults\" and ruHis.colNames.size > 2) do\n    ruHisList: []\n    ruCount: ruHis.colNames.size -1\n    ruHis.removeCol(\"ts\").colNames.each colName => do\n      ruHisList= ruHisList\n        .add(ruHis.keepCols([\"ts\",colName])\n                  .findAll(row => row[colName] != null))\n    end\n    ruHisDis: hisPeriodMatrix(ruHisList)\n              .findAll(r => r->numTrue > 0)\n              .keepCols([\"ts\",\"dur\"])\n              .addColMeta(\"dur\",\n                {dis: \"Summary: \"+ruCount+\" Rules Sparked\",\n                 spark})\n  end else ruHisDis: ruHis\n  if (faults != \"Hide Faults\")\n  hisGrid= [hisGrid, ruHisDis].findAll(v => not(isEmpty(v)) and v!=null).hisJoin\n  \n  // Display active deficiencies\n  defs: viTargetsDeficiencies(\n          toolRecursiveSearch(zone->id, \"equip\"),\n          span)\n  if (defs!=null and not(isEmpty(defs))) do\n    if (faults==\"Summary Faults\" and defs.colNames.size > 2) do\n      defsList: []\n      defsCount: defs.colNames.size - 1\n      defs.removeCol(\"ts\").colNames.each colName => do\n        defsList= defsList\n          .add(defs.keepCols([\"ts\",colName])\n                   .findAll(row => row[colName] != null))\n      end\n      defsDis: hisPeriodMatrix(defsList)\n               .findAll(r => r->numTrue > 0)\n               .keepCols([\"ts\",\"dur\"])\n               .addColMeta(\"dur\",\n                 {dis: \"Summary: \"+defsCount+\" Deficiencies\",\n                  spark})\n    end else defsDis: defs.addColMeta(\"v0\", {spark})\n    if (faults != \"Hide Faults\")\n      hisGrid= hisJoin([hisGrid, defsDis])\n  end\n  \n  // Format trends\n  group: null\n  tagGroups: []\n  if (groupSelect==\"Typical Groups\") do\n    group= \"By specified tag groups\"\n    tagGroups= [\"equipRef->ahu\",\n                \"equipRef->zone and flow\"]\n    toolRecursiveSearch(zone->id, \"equip and (terminalUnit or fumeHood)\")\n    .each(tEq => do\n      tagGroups= tagGroups\n        .add(\"unit==\\\"%\\\" and (supply or equipRef==@\"+tEq->id+\")\")\n        .add(\"flow and (supply or equipRef==@\"+tEq->id+\")\")\n        .add(\"zone and air and temp and not discharge and equipRef==@\"+tEq->id)\n    end)\n    tagGroups= tagGroups.add(\"discharge and air and temp\")\n  end else\n    group= groupSelect\n  colorZones: try userOpts->colorFilters catch defaultOpts->colorFilters\n  spanFilters: try userOpts->spanFilters catch defaultOpts->spanFilters\n  hisGrid= hisGrid\n    .toolFormatTrends(group, tagGroups, colorZones, spanFilters, 2)\n  \n  return hisGrid.addMeta({title: zone.dis()+\" Trends\"})\n                .addMeta({hisStart:span.start})\n                .addMeta({hisEnd:span.end})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recTrashDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(refs) => do\n  // Normalize action input\n  refs= actionNormInput(refs, \"ids\")\n  \n  // Add \"trash\" tag to all related noted\n  if (isRef(refs)) refs=[refs]\n  refs.each ref => do\n    readAll(deficiencyNote and deficiencyRef==ref)\n      .each rec => commit(diff(rec, {trash}))\n  end\n\n  recTrash(refs)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,,,,,M,,,,,,"toolCopyright",,,"() => do\n  header:\"/*\\n  Copyright 2020 Raphael Vitti\\n  \\n  This program is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\"\n  footer:\"\\n/*\\n  Updates\\n  2020-03-30  Raphael Vitti\\n    Added copyright and license information.\\n*/\"\n\n  readAll(func)\n  .findAll(f => not(f->src.contains(\"Copyright\")))\n  .each t => commit(diff(t, {src:header+t->src+footer}))\nend\n",,
,[],,,,M,,,,,,"dbCopiesBacnetCurv2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  bacnetConnRef + bacnetCur combinations are unique, and there should\n  only be one point per such combination. This function finds duplicates,\n  which typically reflect a typo or error during the point creation.\n  \n  Stores grid as io/dbHealth/copiesBacnetCur.trio trio file with:\n    id:            point id, for all points with duplicate combinations\n    bacnetConnRef: ref \n    bacnetCur:     text\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  all: readAll(point and bacnetCur and bacnetConnRef)\n  \n  dups: all.findAll(pt =>\n      read(point and bacnetCur == pt->bacnetCur\n           and bacnetConnRef == pt->bacnetConnRef\n           and id != pt->id, false) != null)\n              \n  if (isEmpty(dups))\n    dups= {success: \"No duplicate bacnetConnRef + bacnetCur\"}\n          .toGrid\n  else          \n    dups= dups.map(pt => {id: pt->id,\n                          bacnetConnRef: pt->bacnetConnRef,\n                          bacnetCur: pt->bacnetCur,                        \n                         })\n  \n  dups.ioWriteTrio(`io/dbHealth/copiesBacnetCur.trio`)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ruChillerShortCycling",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(chiller, dates, minOffTime: 20min, minOnTime: 5min, valid: null, invalid: null) => do\n  // User variables\n  mergeHalfPeriod: 30min      // Merge sparks that are 1h apart\n  invalidExtendPeriod: 30min  // Reduce validity period by 30min on each end to reduce false positives\n  minTime: 30min              // Filter out sparks of less than 30min\n\n  status: readAll(point and sensor and run and status and hisSize and equipRef==chiller->id)\n \n  // Create dictionary of points for map\n  points: status.toRecList\n \n  cycle: points.map pt => pt.shortCycling(dates, minOffTime, minOnTime)\n \n  spark:hisPeriodUnion(cycle)\n \n  // Remove first spark if it is short and falls on midnight, because sparks are computed on 24-hour period only,\n  //  therefore missing continuity around midnight\n  if ((spark.first != null) and (spark.first->ts.hour()==0) and (spark.first->ts.minute()==0) and (spark.first->v0 < minOffTime)) do\n    spark = spark[1..-1] end\n\n  // Remove last spark if it is short and ends at midnight, because sparks are computed on 24-hour period only\n  if (spark.last != null) do\n    sparkLastEnd: spark.last->ts + spark.last->v0\n    if ((sparkLastEnd.hour()==0) and (sparkLastEnd.minute()==0) and (spark.last->v0 < minOffTime)) do\n      spark = spark[0..-2]\n    end\n  end\n  \n  // In some cases (e.g. B77) short cycling raises a spark only in certain conditions (e.g. when AHU-8 is OFF)\n  if (invalid != null) do\n    validGrid: invalid.hisRead(dates).hisFindPeriods r => not(r)\n  end else if (valid != null) do\n    validGrid: valid.hisRead(dates).hisFindPeriods r => r\n  end else do\n    validGrid: null\n  end\n  \n  if (validGrid != null) do\n    // Reduce validity period by 30min to avoid false positives e.g. shortly after AHU-8 turns OFF\n    validGrid = hisPeriodShift(validGrid, invalidExtendPeriod, -invalidExtendPeriod)\n    if (validGrid.first == null) do\n      spark = validGrid\n    end else do\n      spark = hisPeriodIntersection([spark, validGrid])\n    end\n  end\n\n  // Merge adjacent short sparks, filter out remaining short sparks\n  spark = hisPeriodShift(spark, -mergeHalfPeriod, mergeHalfPeriod)  // Expand to merge\n  spark = hisPeriodShift(spark, mergeHalfPeriod, -mergeHalfPeriod)  // Contract to get back to original periods\n  spark = spark.findAll(r => r->v0 >= minTime)                      // Filter out short sparks\n\n  return spark\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualMult",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  value of the first source point which has a virtualRef equal\n  to the id of the virtual point, multiplied by the value of the\n  multiplierNeeded tag of the source point. Both the source point\n  and the virtual point must have the same unit.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  \n  rawPt: read(virtualRef==rec->id)\n  if (rawPt.has(\"multiplierNeeded\") and \n      rawPt->unit == rec->unit) do\n    mult: rawPt->multiplierNeeded\n    rawPt.hisRead(dates, {limit: null})\n         .each(row => if (row[\"v0\"] != null)\n                        yield(row->ts, row->v0 * mult))\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptAverageZoneAirTemp",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n////////////////////////////////////////////////////////////////////\n// This function calculates history for a virtual zone temperature\n//    sensor point as the average of all zone air temp sensors in\n//    sub-equip of the equip the point belongs to\n// kW Engineering // RGV // Last Update: 2018-03-13\n\n(rec, dates, opts, yield) => do\n  temperatures: readAll(zone and air and temp and sensor\n                        and equipRef->equipRef==rec->equipRef)\n                .hisRead(dates, {limit: null})\n                .hisInterpolate()\n                .hisFoldCols(avg)\n                .each(row => yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anAhuZoneCoolingNeeds",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze terminal unit trends for all terminal units related to\n  given AHU and return one historical trend of zones that need more\n  cooling, as calculated by comparing zone air temp with the effective\n  zone cooling setpoint, plus a given tolerance.\n  \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  tolerance    number, increases ZAT cooling setpoint\n  rollup       duration, interval for rollup of ZAT\n  total        bool, if true return the total, if false return\n               the individual terminal unit trends\n*/\n\n(ahuRef, dates: yesterday(), tolerance: 1°F, rollup: 15min,\n total: true) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve a grid of all supply terminal units associated with AHU\n  tus: readAll(supply and terminalUnit and ahuRef==ahuRef)\n  \n  // Return null if no associated terminal units are found\n  if (isEmpty(tus)) return null\n  \n  // Cycle through zones and create history of cooling needs\n  needs: {}.toGrid()\n  tus.each(tu => do\n    // Find ZAT and ZAT cooling setpoint\n    coolSp: read(point and zone and air and temp\n                 and effective and cooling and sp\n                 and equipRef==tu->id, false)\n                 \n    zat: read(point and zone and air and temp\n              and sensor\n              and equipRef==tu->id, false)\n              \n    // If any point is missing, skip terminal unit\n    if (coolSp==null or zat==null) return null\n    \n    // Col name based on zone name\n    if (tu.has(\"equipRef\"))\n      colName: tu->equipRef->navName.toTagName()\n    else\n      colName: tu->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    flags: [zat, coolSp].hisRead(dates, {limit: null})\n        .hisRollup(avg, rollup)\n        .hisInterpolate()\n        .addCol(colName, row => do\n          if (row[\"v0\"]==null or row[\"v1\"]==null or\n              row[\"v0\"]==na() or row[\"v1\"]==na())\n            return na()\n          else if (row[\"v0\"] > (row[\"v1\"] + tolerance))\n            return 1\n          else return 0\n        end)\n        .keepCols([\"ts\",colName])\n        .hisFindAll(val => val != null)\n        .addColMeta(colName, {dis: tu.dis()+\" Need Cooling\"})\n        \n    // Add to needCooling summary array\n    if (isEmpty(flags)) return null\n    if (isEmpty(needs)) needs=flags\n    else needs= hisJoin([flags,needs])\n  end)\n  \n  if (isEmpty(needs)) return null\n  if (not(total)) return needs\n  \n  // Sum up all terminal units into one trend\n  tot: needs.cols.size()-1\n  disName: \"Count, terminal units need cooling (ZAT > CLG SP + \"\n           + tolerance.as(\"°F\") + \"), out of max \" + tot\n  count: needs\n      .hisFoldCols(sum)\n      .findAll(row => row[\"v0\"] != na() and row[\"v0\"] != null)\n      .addColMeta(\"v0\", {dis: disName, color:\"#ff2348\",\n                         chartMin: 0})\n      \n  return count\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgCreateVavConns",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv file and create corresponding bacnet connectors\n  The csv file should follow the same template as\n  \n  https://docs.google.com/spreadsheets/d/1mmIjeHY3Y2ezVszcpFX21FleYTYYcnW3r59MdNGoB7I/edit#gid=159080117\n  \n  In particular, the following fields are used:\n  - ahu\n  - supplyVAV\n  - floor\n  - vavIP\n  - deviceID\n  - network\n  - address\n  - controlProgram\n  - programInstance\n*/\n\n(filePath:`io/integration_b30/vav_conn.csv`, siteDis:\"30\") => do\n  siteId: read(site and dis==siteDis)->id\n\n  ioReadCsv(filePath)\n  .each row => do\n    loc: siteDis + \" Floor \" + row[\"floor\"]\n    vav: reGroups(\".*VAV-? ?([A-Za-z0-9]{1,4})\", row[\"supplyVAV\"])[1]\n    disText: loc + \" - ZN - VAV-\" + vav\n    uriText: \"bacnet://\"+row[\"vavIP\"]+\"/\"+row[\"deviceID\"]\n             +\"?dnet=\"+row[\"network\"]\n             +\"&dadr=\"+toHex(parseInt(row[\"address\"]))\n    \n    // Check if connector already exists\n    ex: read(conn and uri==uriText, false)\n    if (ex != null) return null\n    \n    // Create new connector\n    commit(diff(\n      null,\n      {dis: disText,\n       uri: parseUri(uriText),\n       conn,\n       bacnetConn,\n       siteRef: siteId,\n       vavZn: \"VAV-\" + vav},\n      {add}\n    ))\n  end\n  \n  readAll(conn and bacnetConn and siteRef==siteId)\n  .each connector => bacnetPing(connector)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viAhuEconTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find AHU data points related to the given AHU economizer.\n  Load and display historical data for all these points across\n  the given date span as a scatter plot.\n  \n  Arguments: \n  ahuRef       ref, id of the AHU\n  dates        dateSpan, dates of data to display\n*/\n\n(ahuRef, dates: yesterday(), oatRef:null, filterPtRef:null, rollup:10min,\n oatMin:null, oatMax:null, satMin:null, satMax:null) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n   \n  // Retrieve AHU OAT or weather station OAT\n  if (oatRef==null)\n    oat: read(point and outside and air and temp and sensor\n              and equipRef==ahuRef, false)\n  else oat: readById(oatRef)\n  if(oat==null) oat= read(weatherPoint and main and air and temp)\n  // Format\n  oat= oat.set(\"color\", \"limeGreen\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU RAT\n  rat: read(point and \"return\" and air and temp and sensor\n            and equipRef==ahuRef, false)\n  if(rat==null) rat={}\n  // Format\n  rat= rat.set(\"color\", \"orange\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU SAT\n  sat: read(point and discharge and air and temp and sensor\n            and equipRef==ahuRef, false)\n  if(sat==null) sat={}\n  // Format\n  sat= sat.set(\"color\", \"royalBlue\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU MAT\n  mat: read(point and (mixed or recovery) and air and temp and sensor\n            and equipRef==ahuRef, false)\n  if(mat==null) mat={}\n  // Format\n  mat= mat.set(\"color\", \"purple\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU SAT SP\n  satsp: read(point and discharge and air and temp and sp\n              and equipRef==ahuRef, false)\n  if(satsp==null) satsp={}\n  // Format\n  satsp= satsp.set(\"color\", \"lightGrey\")\n              .set(\"chartType\", \"scatter\")\n              .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU CHW valve command\n  chwv: read(point and cool and valve and cmd\n             and equipRef==ahuRef, false)\n  if(chwv==null) chwv={}\n  // Format\n  chwv= chwv.set(\"color\", \"cyan\")\n            .set(\"chartType\", \"scatter\")\n            .set(\"chartGroup\", \"pos\")\n  \n  // Retrieve AHU HHW valve command\n  hhwv: read(point and heat and valve and cmd\n             and equipRef==ahuRef, false)\n  if(hhwv==null) hhwv={}\n  // Format\n  hhwv= hhwv.set(\"color\", \"red\")\n            .set(\"chartType\", \"scatter\")\n            .set(\"chartGroup\", \"pos\")\n            \n  // Retrieve AHU economizer damper command\n  econ: read(point and outside and air and damper and cmd\n             and equipRef==ahuRef, false)\n  if(econ==null) econ={}\n  // Format\n  econ= econ.set(\"color\", \"black\")\n            .set(\"chartType\", \"scatter\")\n            .set(\"chartGroup\", \"pos\")\n            \n  // Filter point\n  if (filterPtRef==null)\n      filterPt: read(point and run and sensor\n                     and equipRef==ahuRef, false)\n  else filterPt: readById(filterPtRef)\n  \n  if (filterPt==null) filterPt={}\n  \n  // Assemble points, read history, prepare scatter\n  his: [oat, mat, rat, sat, satsp, chwv, hhwv, econ, filterPt]\n       .hisRead(dates, {limit:null})\n       .hisInterpolate()\n       .findAll(row => if (row[\"v0\"] != null and oatMin != null)\n                         row[\"v0\"] >= oatMin else true)\n       .findAll(row => if (row[\"v0\"] != null and oatMax != null)\n                         row[\"v0\"] <= oatMax else true)\n       .findAll(row => if (row[\"v3\"] != null and satMin != null)\n                         row[\"v3\"] >= satMin else true)\n       .findAll(row => if (row[\"v3\"] != null and satMax != null)\n                         row[\"v3\"] <= satMax else true)\n                         \n  if (rollup>0)\n    his= his.hisRollupAuto(rollup)\n       \n  // Return\n  return his\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB06ExpHallZone17TempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilters   Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readAll((id==@p:lbnl:r:2438edc7-7351b594 or\n           id==@p:lbnl:r:234ab37a-e9609bbe or\n           id==@p:lbnl:r:234ab3af-c17a8b36 or\n           id==@p:lbnl:r:234ab3c6-09a3d214 or\n           id==@p:lbnl:r:234ab3dd-d901f60c or\n           id==@p:lbnl:r:234ab3fc-76906146 or\n           id==@p:lbnl:r:234ab408-1c6f9a36\n         ) or (\n           equipRef==@p:lbnl:r:23480903-dbc36633 and (\n             valve or temp or (outside and air and damper)\n           )\n         ))\n  .hisRead(span, {limit:limit})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"weatherChartAirTemp",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ptRefs, span, interval: null, nlimit: 50000) => do\n  ptsHis: ptRefs.hisRead(span, {limit: nlimit})\n  \n  if (interval == null) do \n    ptsHisRolled: ptsHis\n    rollupInfo: ptRefs.map ptRef => \" \"\n  end else do\n    ptsHisRolled: ptsHis.hisRollupAuto(interval)\n    rollupInfo: ptRefs.map ptRef => \" \"+readLink(ptRef)->hisRollupFunc+\" over \"+interval\n  end\n  \n  ptsHisRolled.addMeta({title: ptRefs[0]->weatherRef->dis+\": Air Temperature\"})\n    .addColMeta(\"v0\",{chartGroup: \"1\", \n                      color:\"green\", \n                      dis:readLink(ptRefs[0])->navName+rollupInfo[0]+\" (\"+readLink(ptRefs[0])->unit+\")\", \n                      chartType: \"line\"})\n    .addColMeta(\"v1\",{chartGroup: \"1\", \n                      color:\"olive\", \n                      dis:readLink(ptRefs[1])->navName+rollupInfo[1]+\" (\"+readLink(ptRefs[1])->unit+\")\", \n                      chartType: \"line\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"chillerMalfunction",,,"(equip, dates) => do\n\n  chStatus: read(point and status and equipRef==equip->id).hisRead(dates).hisFindPeriods(x => x).hisFindAll(y => y > 10min)\n  \n  chSupply: read(point and supply and temp and equipRef==equip->id).hisRead(dates)\n  \n  chReturn: read(point and \"return\" and temp and equipRef==equip->id).hisRead(dates)\n\n  joined: hisJoin([chReturn, chSupply]).hisInterpolate()\n  \n  //mapped for difference between supply and return\n  mapped: joined.map row => do\n            {\n            ts: row->ts,\n            val: abs(row.get(\"v0\") - row.get(\"v1\"))\n            }\n          end\n\n  //Finds periods of 5 degrees difference or less between supply and return\n  spark1: mapped.hisFindPeriods(x => x < 5)\n  \n  spark2: chStatus\n\n  hisPeriodIntersection([spark1, spark2])\n  \n  \nend",,
,["anHunting"],,"Valve Hunting",,M,"Valve command rate of change exceeded a given threshold (default 5%/min) for longer than a given time period (default 30min)",,,,,"ruValveHunting",,"terminalUnit","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates, maxChangePerMinute: 5%, mergePeriod: 30min, minTime: 30min) => do\n  // Get valve cmd point, return null if not found\n  valve: read(point and valve and cmd and equipRef==equip->id, false)\n  if (valve == null) return null\n  \n  // Get history data, and use exterior function anHunting\n  data: valve.hisRead(dates, {limit: null})\n  if (isEmpty(data)) return null\n  \n  // Sparks from returned periods\n  sparks: anHunting(data, maxChangePerMinute, mergePeriod, minTime)\n  \n  if (sparks==null or isEmpty(sparks)) return null\n  else return sparks\n\n end\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"psySaturationPressure",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate water vapor saturation pressure in kPa\n    at a given temperature,\n    from ASHRAE Fundamentals (2009) p 1.2, equations 5 and 6\n  \n  Arguments (unit conversions applied as first step):        \n  temp               Dry bulb temperature [°F]\n\n  Notes:\n  Valid from -100C to 200 C\n*/\n\n(temp) => do\n  // Parameters\n  minValid: -100°C\n  maxValid: 200°C\n  \n  // Apply conversions\n  temp = temp.to(\"°C\")\n  \n  // Test validity\n  if (temp < minValid or temp > maxValid) return null\n  \n  // Convert to Kelvin and drop units\n  tempK: temp.to(\"K\").as(1)\n  \n  // Calcs and return with unit (kPa)\n  if (tempK <= 273.15) do\n    c1: -5674.5359\n    c2: 6.3925247\n    c3: -0.009677843\n    c4: 0.00000062215701\n    c5: 2.0747825E-09\n    c6: -9.484024E-13\n    c7: 4.1635019\n    satPressure: exp(c1/tempK + c2 + tempK*(c3 + tempK*(c4 + tempK*(c5 + c6*tempK))) + c7*logE(tempK)) / 1000\n    return satPressure.as(1kPa)\n  end else do\n    c8: -5800.2206\n    c9: 1.3914993\n    c10: -0.048640239\n    c11: 0.000041764768\n    c12: -0.000000014452093\n    c13: 6.5459673\n    satPressure: exp(c8/tempK + c9 + tempK*(c10 + tempK*(c11 + tempK*c12)) + c13*logE(tempK)) / 1000\n    return satPressure.as(1kPa)\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viOccAlwaysOff",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of occupancy sensor data from\n zones where occupancy is never detected over the given time period;\n grid is optimized for use as a chart.\n \n Arguments:\n span      dateSpan, span of dates for which to return data\n*/\n\n(span) => do\n  // Check inputs, prepare filters\n  span= span.toDateSpan\n  timeThreshold: 1min\n\n  data: readAll(occupied and zone and sensor and point and not virtual)\n          .findAll(row => hisRead(row->id, span, {limit: null})\n                            .hisFindPeriods(p => p)\n                            .foldCol(\"v0\", sum) < timeThreshold)\n          .hisRead(span)\n\n  // Chart group by site\n  data.colNames()[1..-1].each colName => do\n    data = data.addColMeta(colName, {chartGroup: data.col(colName).meta->siteRef->dis})\n  end\n  \n  if (isEmpty(data)) data= read(zone and occupied and sensor and point)\n                             .hisRead(span)\n                             .addColMeta(\"v0\", {dis: \"All Occ Sensors OK\"})\n  \n  data= data.addMeta({title: \"Occupancy sensors that are always OFF\"})\n  \n  return(data)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toAhuHeat",,,"(ahu, checked:true) => do\n  heats: readAll(heat and cmd and equipRef == ahu->id)\n\n  if (heats.size > 1) heats = heats \n  if (heats.isEmpty) do\n    if (checked) throw \"No 'heats' points defined: \" + dis(ahu)\n    return null\n  end\n  heats\nend\n",,
,["viMissingRecentHistory"],,,,M,,,,,,"viStalePoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function finds points with stale history and returns their id\n  and the stale value. Currently skips points of \"Str\" kind.\n    staleHisId    point id\n    staleVal      value of point during span\n  \n  Arguments:\n  filter     text, filter expression of points to work with\n             default is \"point and kind==Number\"\n  span       dateSpan to cheeck histories on\n             default is pastWeek\n  noZero     bool, if true exclude numeric points stale at zero\n*/\n\n(filter: \"point and kind==\\\"Number\\\"\", span: pastWeek.toDateSpan,\n noZero: false) => do\n  // Test if provided filter is valid, and create associated query\n  try do\n    filter = filter + \" and hisEnd\"\n    query : parseFilter(filter, true)\n  end catch do\n    return {\"error\":\"Invalid filter\"}.toGrid()\n    //filter = \"point and kind==\\\"Number\\\" and hisEnd\"\n    //query : parseFilter(filter, true)\n  end\n  \n  readAll(query)\n  .findAll(row => not row.has(\"connRef\")\n                  or not readById(row->connRef).has(\"disabled\"))\n  .map pt => do\n    hisTrend: pt.hisRead(span).hisClip()\n                \n    if (isEmpty(hisTrend))\n      return {staleHisId: null, staleVal: null}\n      // Case is captured in viMissingRecentHistory\n      \n    if (pt->kind==\"Str\")\n      return {staleHisId: null, staleVal: null}\n      // Skips such points for now\n      \n    if (pt->kind==\"Bool\")\n      hisTrend = hisTrend.hisMap v => if(v) 1 else 0\n    \n    if (pt->kind!=\"Number\" and pt->kind!=\"Bool\")\n      return {staleHisId: null, staleVal: null}\n    \n    hisTrend= hisTrend\n              .hisMap(v => if (v==na()) null else v) // Remove NA() values\n              .findAll(row => row[\"v0\"] != null)\n\n    // If not empty before but empty now, stale with NA()\n    if (isEmpty(hisTrend))\n      return {staleHisId: pt->id, staleVal: na()}\n\n    // Stale points\n    if (hisTrend.foldCol(\"v0\", max) == hisTrend.foldCol(\"v0\", min))\n      if (pt->kind==\"Number\") do\n        staleVal: hisTrend.foldCol(\"v0\", min)\n        if (noZero and staleVal==0)\n          return {staleHisId: null, staleVal: null}\n        else\n          return {staleHisId: pt->id, staleVal: staleVal}\n      end\n      if (pt->kind==\"Bool\")\n        return {staleHisId: pt->id,\n                staleVal: if(hisTrend.foldCol(\"v0\", min) > 0) true\n                          else false}\n      \n    return {staleHisId: null, staleVal: null}\n  end\n  .findAll(pt => pt[\"staleHisId\"] != null)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d9bce9-061451a1 "dbHisHealth",
,["toolFormatGrid"],,,,M,,,,,,"viTasksList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(siteRef, state, assignedTo:\"\", filter:\"\") => do \n  grid: if(siteRef==null)\n          readAll(task)\n        else\n          readAll(task and siteRef==siteRef)\n  \n  if(isEmpty(grid)) return null\n  \n  grid= grid.findAll(row => if(state==\"Any\") true\n                            else row->state==state)\n                            \n  grid= grid.findAll(row =>\n      if (assignedTo==\"\") return true\n      else if (row[\"assignedTo\"]==null) false\n           else reMatches(\".*\"+assignedTo+\".*\", row[\"assignedTo\"]))\n  \n  grid= grid.findAll(row => reMatches(\".*\"+filter+\".*\",\n                                      row.dis()))\n                \n  if(isEmpty(grid)) return null\n  \n  disCols: [\"id\",\"state\",\"assignedTo\",\n            \"priority\"]\n  return grid.toolFormatGrid(disCols)\n             .sort((a,b) => a.dis() <=> b.dis())\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viTUELine",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  builds a simple chart for B59 with compute power and the min and max \n  compute power filter along with \n    \n  Arguments: \n  dates            Span of dates we want to calculate the metric on\n  min              minimum compute power filter\n  max              maximum compute power filter\n*/\n\n\n(dates: today, min: null, max: null) => do\n  \n  //assign CRAY Fan power as bonusPower\n  bonusPower: readById(@p:lbnl:r:2444488c-91d0bc7b)\n  \n  //hisRead bonus power\n  bonusTrend: bonusPower.hisRead(dates,{limit:null})\n             .renameCol(\"v0\",\"bonus\")\n\n  //look up compute power\n  compute: readById(@p:lbnl:r:2444485c-4d9af430)\n\n    \n    //hisRead compute power  \n    powerTrend:  compute.hisRead(dates,{limit:null})\n        .addColMeta(\"v0\",{unit:\"kW\",\n                    chartGroup: \"all\",\n                    color: \"#BF2796\"})\n    //ignore compute loads less than 10kW (preventing two left y-axes)\n        .hisFindAll(v => v > 10kW)\n        .addCol(\"minFilter\", v => v= min)\n          .addColMeta(\"minFilter\",{unit:\"kW\",\n                    chartGroup: \"all\",\n                    dis: \"Min Compute Power (kW)\",\n                    color: \"#96BF27\"})\n        .addCol(\"maxFilter\", v => v= max.as(\"kW\"))\n          .addColMeta(\"maxFilter\",{unit:\"kW\",\n                    chartGroup: \"all\",\n                    dis: \"Max Compute Power (kW)\",\n                    color: \"#4B6014\"})\n        \n      //combine wb and power trends\n      trends: hisJoin([bonusTrend,powerTrend])\n          .addColMeta(\"bonus\",{unit: \"kW\",\n                     chartGroup: \"all\",\n                     dis: \"CRAY Fan Power (kW)\",\n                     color: \"#F1C40F\"})\n          .findAll(row => row.all(v => v != null))\n  \n  return trends\n\n end\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Compared History",,M,,M,,,,"hisTimeCompare_v3",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(point, dates, duration) => do\n  // Read data from current historian display, get meta info needed for proper display\n  r_current: point.hisRead(dates)\n  his_meta: r_current.meta\n  \n  // Read data from earlier, shift timestamps to current historian display, make grid\n  r: point.hisRead(dates - duration)\n  list_ts: colToList(r,\"ts\")\n  list_v1: colToList(r,\"v0\")\n  list_ts0: list_ts.map s => s + duration\n  r_past: list_ts0.toGrid.map( (row,index) => {ts:row->val, v1:list_v1[index]} )\n  \n  // Merge current and past grids and set meta information for proper display\n  r_past_meta: r_past.addMeta(his_meta)\n  r_joined: hisJoin([r_current, r_past_meta])\n  \n  point_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"navName\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  r_out: r_joined.addColMeta(\"v0\", {dis: point_dis})\n                    .addColMeta(\"v1\", {dis: duration+\" earlier: \"+point_dis})\n                    .addMeta({dis: \"LAGGED \"+duration+\" \"+point_dis})\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["deficiencyHasResponses","toolFormatGrid"],,,,M,,,,,,"viDeficienciesPublicList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a table of deficiencies formatted for display.\n  \n  Arguments: \n  siteRefs            Ref<site>[], siteRef filter\n  sprintRefs          Ref<sprint>[], sprintRef filter\n  deficiencyGroupRef  Ref<deficiencyGroup>, group filter\n  state               Str, state filter, can be \"Any\", \"Active\", \"Not Closed\"\n                      or any specific deficiency state string\n  filter              Str, filter on deficiency dis and group dis, case insensitive\n*/\n\n(siteRefs, sprintRefs:null, state:\"Any\", deficiencyGroupRef:null, filter:\"\") => do\n  // Determine current and previous sprints\n  sortedSpr: readAll(sprint)\n             .sortr((a,b) => a->sprint <=> b->sprint)\n  currentSpr: sortedSpr[0]\n  previousSpr: sortedSpr[1]\n  // Process sprintRefs\n  if (sprintRefs != null)\n    sprintRefs= sprintRefs\n    .map(sId => if (readById(sId)->sprint==-1) previousSpr->id\n                else if (readById(sId)->sprint==0) currentSpr->id\n                else sId)\n\n  // Build title\n  title: \"\"\n  if (deficiencyGroupRef!=null)\n    title= title+readById(deficiencyGroupRef).dis()+\" deficiencies \"\n  else title= title+\"Deficiencies\"\n  if (siteRefs!=null) do\n    siteNames: siteRefs.map(v => do\n      siteDis: readById(v)->dis\n      prefix: if (parseNumber(siteDis,false)!=null) \"B\" else \"\"\n      return prefix + siteDis\n    end)\n    title= title + \", \" + siteNames.concat(\", \")\n  end\n  title= title+\" (\" + state + \")\"\n  if (sprintRefs!=null) do\n    sprintNums: sprintRefs.map(v => readById(v)->sprint.toStr)\n    if (sprintNums.size > 1) title= title + \", Sprints \"\n    else title= title + \", Sprint \"\n    title= title+ sprintNums.concat(\", \")\n  end\n\n  // Initialize grid\n  grid: if(siteRefs==null)\n          readAll(deficiency)\n        else\n          readAll(deficiency).findAll(r => r.has(\"siteRef\") and siteRefs.contains(r->siteRef))\n  \n  // Escape if no deficiencies are found, to avoid grid manipulation errors\n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n  \n  // Apply deficiency group filter\n  grid= grid.findAll(row => if(deficiencyGroupRef==null) true\n                            else row[\"deficiencyGroupRef\"]==deficiencyGroupRef)\n  \n  // Apply deficiency state filter\n  grid= grid.findAll(row => if(state==\"Any\") true\n                            else if(state==\"Active\")\n                              [\"To Do\",\"In Progress\"].contains(row->state)\n                            else if(state==\"Not Closed\")\n                              not([\"Closed\",\"Abandoned\"].contains(row->state))\n                            else if(state==\"Closed or Resolved\")\n                              [\"Closed\",\"Resolved\"].contains(row->state)\n                            else row->state==state)\n  \n  // Apply deficiency sprint filter\n  grid= grid.findAll(row => if(sprintRefs==null) true\n                            else sprintRefs.contains(row[\"sprintRef\"]))\n  \n  // Apply deficiency display name + group display name filter\n  grid= grid.findAll(row => do\n    groupDis: if(row[\"deficiencyGroupRef\"]!=null)\n                readById(row[\"deficiencyGroupRef\"]).dis()\n              else \"\"\n    // regex with ?i flag is NOT case sensitive\n    return reMatches(\"(?i).*\"+filter+\".*\", row.dis() + groupDis)\n  end)\n                \n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n  \n  // Add responses column\n  grid= grid.addCol(\"hasResponses\", row => do\n    if(deficiencyHasResponses(row->id, userCur()->dis)) return marker()\n    else return null\n  end)\n  \n  // Add deficiencyRef (hidden) for note creation action\n  grid= grid.addCol(\"deficiencyRef\", row => row->id)\n  \n  // Convert mod to Los_Angeles tz\n  grid= grid.map(row => row.map((v,n) => if (n==\"mod\") v.toTimeZone(\"Los_Angeles\") else v))\n  \n  // Add title as id column display name\n  grid= grid.addColMeta(\"id\", {dis:title})\n  \n  // Add link column\n  grid= grid.addCol(\"link\", row => uiLink({view: \"deficiencyView\",\n                                           state:{deficiencyRef:row->id}}))\n  \n  disCols: [\"id\",\"state\",\"sprintRef\",\"size\",\"endDate\"]\n  statusSort: [\"Closed\",\"Resolved\",\"In Progress\",\"To Do\",\"In Consideration\",\n               \"Pending\",\"Backlog\",\"New\",\"Abandoned\"]\n\n  return grid.toolFormatGrid(disCols)\n  // Sort by sprint, then by status, then by display name\n             .sort((a,b) => a.dis() <=> b.dis())\n             .sort((a,b) => statusSort.index(a->state) <=> statusSort.index(b->state))\n             .sortr((a,b) => (if (a.has(\"sprintRef\")) a->sprintRef->sprint else -1) <=> \n                             (if (b.has(\"sprintRef\")) b->sprintRef->sprint else -1))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viDeficienciesPlanning"],,,,M,,,,,,"repClosedDeficiencies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function retrieves the deficiency planning grid showing all closed items,\n  formats it, stores it and transfers it to a CSV file publicly available on google drive\n  \n  Arguments:\n  N/A\n*/\n\n() => do\n  cols: [\"dis\",\"sprint\",\"size\",\"assignedTo\",\"state\",\"endDate\"]\n\n  viDeficienciesPlanning(\"Closed\")\n  .findAll(r => r.missing(\"deficiencyGroupRef\") or \n                r[\"deficiencyGroupRef\"]->navName!=\"Skyspark Feature Requests\")\n  .addCol(\"sprint\",row => if (row.has(\"sprintRef\"))\n                            readById(row[\"sprintRef\"]).dis)\n  .keepCols(cols)\n  .reorderCols(cols)\n  .addColMeta(\"sprint\", {dis:\"Sprint\"})\n  .addColMeta(\"size\", {dis:\"Size (WU)\"})\n  .addColMeta(\"assignedTo\", {dis:\"Assigned To\"})\n  .addColMeta(\"state\", {dis:\"Status\"})\n  .addColMeta(\"endDate\", {dis:\"Date Resolved\"})\n  .ioWriteCsv(`io/tmp/ocxClosed.csv`)\n  \n  sfxGoogleDriveUpdate(\"ocxClosed.csv\",`io/tmp/ocxClosed.csv`)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"boilerShortCycling",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(boiler, dates, minOffTime: 10min, minOnTime: 10min) => do\n\n status: readAll(point and run and cmd and hisSize and equipRef==boiler->id)\n \n cycle: shortCycling(status, dates, minOffTime, minOnTime)\n \n\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"tmpGraphWithTagging",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  readAll(\n    siteRef->dis==\"67\"\n    and equipRef->ahu\n    and equipRef->navName==\"AHU-01\"\n    and ((discharge and air and temp) or\n         (outside and air and temp) or\n         (cool and valve and cmd) or\n         (damper and cmd)))\n  .hisRead(today)\n  .toolFormatTrends(\"By unit\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolZonePts",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Query zone points, points can be at zone or terminalUnit level\n  Points at zone level supercede points at TU level.\n*/\n\n(equipFilter: \"equip and zone\",\n ptFilter:\"zone and air and temp and sensor\") => do\n  eqs: readAll(parseFilter(equipFilter))\n  if(isEmpty(eqs)) return null\n  \n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends","toolHisGridShowGaps","viTargetsDeficiencies","toolRecursiveSearch"],,,,M,,,,,,"viFormattedTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays trends for selected equipment and points, with formatting.\n  \n  Arguments:\n  equipRef       Ref to an equip, if provided display trends of all its points\n  pointsRefs     list of point IDs or point recs, display history for those points\n  span           period to display\n  rollup         time rollup to use for all trends\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n  deficiencies   Bool, whether to show deficiencies on graph\n  rules          Bool, whether to display results of sparkrules\n  gaps           Number, if > 0 show gaps greater than provided time\n  chartMinStr    Str, \"No Minimum,Minimum 0,Minimum 1\"\n*/\n\n(equipRef:null, refsList:[], span:today()-3day..today()-1day, rollup:0,\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null, deficiencies:true, rules:true, gaps:0min, chartMinStr:null) => do\n  if (refsList==null) refsList=[]\n  \n  gridE: try toolRecursiveSearch(equipRef, \"point and his\")\n         catch {}.toGrid()\n  \n  gridP: {}.toGrid()\n  refsList.each ref => do\n    rec: readById(ref)\n    if (rec.has(\"site\")) null\n    if (rec.has(\"location\")) null\n    if (rec.has(\"equip\")) gridP= gridP.addRows(toolRecursiveSearch(ref, \"point and his\"))\n    if (rec.has(\"point\")) gridP= gridP.addRow(rec)\n  end\n         \n  gridA: if(isEmpty(gridP)) gridE else gridE.addRows(gridP)\n  grid: gridA.hisRead(span, {limit:limit})\n\n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  // Process chartMinStr\n  chartMin: if(chartMinStr==\"Minimum 0\") 0\n            else if(chartMinStr==\"Minimum 1\") 1\n            else null\n\n  // Format trends\n  grid= grid.toolFormatTrends(group, tagGroups, colorFilters, [], width, chartMin)\n  // Show gaps\n  if (isNumber(gaps) and gaps>0)\n    grid= grid.toolHisGridShowGaps(gaps)\n\n  // Display active deficiencies\n  if (deficiencies) do\n    defs: viTargetsDeficiencies(gridA.colToList(\"id\"), span)\n    if (defs!=null and not(isEmpty(defs)))\n      grid= hisJoin([grid, defs])\n  end\n  \n  // Display active sparkRules results\n  if (rules) do\n    targets: [equipRef]\n    refsList.each ptRef =>\n      targets= targets.add(readById(ptRef)[\"equipRef\"])\n    targets= targets.findAll(v => v!= null).unique()\n    \n    ruHis: ruleSparks(targets, span, readAll(sparkRule))\n           .ruleSparkHis()\n    \n    grid= hisJoin([grid, ruHis])\n  end\n\n  return grid\nend\n\n/*\n  Updates\n  2020-03-17  Raphael Vitti\n    Added gaps input and toolHisGridShowGaps processing.\n  2020-03-24  Raphael Vitti\n    Added chartMinStr and related processing to cap display minimum\n*/",,
,[],,"Zone Airflow > Min Unnecessarily",,M,"MEasured zone airflow is greater than the minimum setpoint, despite the zone cooling PID loop output being at zero, for a given amount of time (default 4h)",,,,,"ruZoneOvercooling",,"equip and ((terminalUnit and supply) or zone)","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns periods when a terminal unit's airflow is\n  above its minimum setpoint by more than a given percentage (def. 20%)\n  while the cooling PID command is 0%.\n  \n  Arguments:\n  equip           equip record of equip to test airflow on\n  span            dateSpan, span of dates to run analysis on\n  tolerance       number, default 20%, applied to min airflow setpoint\n  minTime         duration, filter out periods shorter than minTime\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n*/\n\n(equip, dates, tolerance: 20%, minTime: 4h, mergePeriod: 30min) => do\n  // Check tolerance number\n  if (unit(tolerance)==\"%\") mult: tolerance.as(1)/100 + 1\n  else return null\n  \n  coolPID: read(point and cool and pid and cmd\n                and equipRef==equip->id, false)\n                \n  sAf: read(point and air and flow\n            and sensor\n            and equipRef==equip->id, false)  \n            \n  minAf: read(point and min and flow\n              and sp\n              and equipRef==equip->id, false)  \n            \n  // If any of these three points is missing, stop testing\n  if (coolPID==null or sAf==null or minAf==null) return null\n  \n  // Read history, combine, apply condition\n  flagPeriods: [sAf, minAf, coolPID].hisRead(dates, {limit: null})\n      .hisInterpolate()\n      .addCol(\"flag\", row => do\n        if (row[\"v0\"]==null or row[\"v1\"]==null or row[\"v2\"]==null)\n          return null\n        else if ((row[\"v0\"] > (row[\"v1\"]*mult))\n                 and row[\"v2\"] == 0%)\n          return 1\n        else return 0\n      end)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindAll(val => val != null)\n      .hisFindPeriods(val => val == 1)\n      \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip->navName + \" airflow > minimum while cooling PID is zero\"\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmp_facAhuClgReqIgnores",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU and a given time span, scan all zones for cooling requests to\n  ignore and return one calculated trend of total number of cooling requests\n  to ignore.\n  See:\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  ahuRef       Id of an ahu equip\n  span         Time span to run analysis on\n*/\n(ahuRef, span, rollup:15min) => do\n  // Normalization\n  ahuId: if (isRef(ahuRef)) ahuRef else ahuRef->id\n  ahu: readById(ahuId)\n  \n  // Locate all zones served by the AHU\n  tus: readAll(terminalUnit and equip and ahuRef==ahuId)\n  zones: tus.colToList(\"equipRef\")\n            .unique\n            .findAll(v => readById(v).has(\"zone\"))\n  \n  // Combine ignored requests from all zones\n  grid: hisJoin(zones.map(z => facZoneClgReqIgnores(z, span, rollup)))\n  \n  // Fold\n  return grid.hisFoldCols(sum)\n             .addColMeta(\"v0\", {dis:ahu.dis+\" Ignored Requests - Colder Supply Air\"})\n             .hisRollup(min, rollup)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viPointHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This creates a heat map chart for a given point of type Number,\n  for the given dates, at the given rollup, with the given rollup\n  function, and with optional min and max clipping.\n  \n  Arguments: \n  N/A\n*/\n\n(ptRef, span, rollupMinutes, rollupFuncStr, clipMin:null, clipMax:null) => do\n  // Process parameters\n  if (isRef(ptRef)) pt: readById(ptRef)\n  else pt: ptRef\n  try ptUnit: pt->unit\n  catch return {error:\"Provided point has no unit\"}.toGrid()\n  span= span.toSpan()\n  rollup: rollupMinutes.as(\"min\")\n  rollupFunc: eval(\"x:\" + rollupFuncStr)\n  clipMin= if(clipMin==null) null else clipMin.as(ptUnit)\n  clipMax= if(clipMax==null) null else clipMax.as(ptUnit)\n  \n  // Load and process point's history\n  grid: pt.hisRead(span, {limit:null})\n  if (isEmpty(grid))\n    return {error:\"No available history across selected dates\"}.toGrid()\n  \n  grid= grid\n  .hisRollup(rollupFunc, rollup)\n  .hisClip()\n  .hisMap(v => do\n    if (v == null) return nan()\n    if (clipMin!=null) v= max(v, clipMin)\n    if (clipMax!=null) v= min(v, clipMax)\n    return v\n  end)\n\n  grid= grid\n  .addColMeta(\"v0\", {chartMin: if (clipMin==null) null else clipMin,\n                     chartMax: if (clipMax==null) null else clipMax})\n  .addMeta({chartType: \"heatMap\", colors: \"green, yellow, red\",\n            title: pt.dis()})\n  \n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"sqlTestScript2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val, D.QuantityID as quantityId\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND S.Name = '\" + \"LBL_ION_06.33_639A1A1A\" + \"'\" +\n       \" AND D.TimestampUTC >= '\" + \"2018-03-20 23:00:00\" + \"'\" +\n       \" AND D.TimestampUTC < '\" + now().toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: read(sqlConn and dis==\"ionDB\").sqlQuery(sql)\n\n  mapped: data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                .toTimeZone(\"Los_Angeles\"),\n                            val: row->val,\n                            quantityId: row->quantityId}\n  \n  //read(sqlConn and dis==\"ionDB\").sqlQuery(\"SELECT * FROM ION_Data.dbo.Source WHERE Name = 'LBL_ION_06.30_650A'\")\n  //read(sqlConn and dis==\"ionDB2019\").sqlQuery(\"SELECT * FROM Source WHERE Name LIKE '%91%'\").findAll(r => r->name.contains(\"671A12A\") or r->displayName.contains(\"671A12A\"))\n  //read(sqlConn and dis==\"ionDB2019\").sqlQuery(\"SELECT * FROM SourceQuantity WHERE SourceID = 1035\")\n  //read(sqlConn and dis==\"ionDB2019\").sqlQuery(\"SELECT * FROM INFORMATION_SCHEMA.TABLES\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualComputeEnergy",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  difference between the total energy (D' + E' + F' at B59) and\n  the total CRAY Unit fan energy. It rolls up the data into 15 min\n  and it excludes NA values.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisRollup(sum, rec->hisVirtualInterval)  // Must sum for energy values, NAs will roll up\n         .hisMap((val, ts, his) => if (val==null) na() else\n                                   val * his->virtualWeight)\n         .hisFoldCols(sum)\n         .each(row => yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["facAhuResetSpNow","facAhuRequestsNow"],,,,M,,,,,,"facAhuResetSpNow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given sp point, check the type of point (cool / heat / pressure), and the related AHU\n  (currently hardcoded until integration to BMS). Use appropriate function to compile\n  related zone requests. Use guideline 36 trim and respond to reset the setpoint and write to it.\n\n  Should be run every 5 minutes, as a recurring job.\n\n  See:\n  https://docs.google.com/document/d/1N4GbHF4PvBYiJrxrfcE4FQK1JjH_Pak3svAbK1-fp2Q/\n  \n  Arguments: \n  spRef        Id of a writable sp point to reset\n  ahuRef       Id of the associated AHU (if null, use equip of spRef)\n  hystTime     Time, period considered in the hysteresis of the request generation\n  offlineTime  Time, allowed gap between latest data point and now(), restart sp calc\n               if latest sp value is older than offlineTime\n*/\n(spRef:@p:lbnl:r:25d85556-a76f3c05, ahuRef:@p:lbnl:r:22dc02cf-fb26e410,\n hystTime: 3hr, offlineTime: 30min) => do\n  // Normalization\n  spId: if (isRef(spRef)) spRef else spRef->id\n  sp: readById(spId)\n  ahuId: if (ahuRef==null) sp->equipRef\n         else if (isRef(ahuRef)) ahuRef\n              else ahuRef->id\n  ahu: readById(ahuId)\n  \n  // Retrieve reset settings\n  rs: read(resetSettings and spRef==spId, false)\n  if (rs==null) return null\n  // Process trim and respond settings\n  baseIgnores: rs->ignore\n  spRes: rs->spRes\n  spTrim: rs->spTrim\n  spResMax: rs->spResMax\n  resSign: spRes/abs(spRes)\n  if (resSign != spResMax/abs(spResMax))\n    throw \"spRes and spResMax signs must be the same\"\n  \n  // Retrieve latest setpoint value or re-initialize\n  // Work with unitless numbers and convert at the end\n  spHis: sp.hisRead(now()-offlineTime..now())\n  spLast: if (isEmpty(spHis)) rs->sp0\n          else spHis.colToList(\"v0\").last.as(1)\n  \n  // Determine zone points to look at based on setpoint type\n  ptTags: if (sp.has(\"cool\")) \"cool and pid and cmd\"\n          else if (sp.has(\"heat\")) \"heat and valve and cmd\"\n          else if (sp.has(\"pressure\")) \"damper and cmd\"\n          else throw \"Setpoint type not identified\"\n  \n  // Retrieve requests and ignores\n  reqsDict: facAhuRequestsNow(ahuId, ptTags, hystTime, offlineTime)\n  requests: reqsDict->requests\n  ignores: baseIgnores + reqsDict->ignores\n  \n  // If appropriate points exist, store data\n  zonesReportingPt: read(reporting and zones and sensor and equipRef==sp->equipRef, false)\n  requestsPt: read(request and sensor and equipRef==sp->equipRef, false)\n  ignoresPt: read(ignore and cmd and equipRef==sp->equipRef, false)\n  \n  if (zonesReportingPt!=null and jobIsRunning())\n    hisWrite({ts:now(), val:reqsDict->reportingZones.as(1)}, zonesReportingPt)\n  if (requestsPt!=null and jobIsRunning())\n    hisWrite({ts:now(), val:requests.as(1)}, requestsPt)\n  if (ignoresPt!=null and jobIsRunning())\n    hisWrite({ts:now(), val:ignores.as(1)}, ignoresPt)\n\n  // Determine new setpoint\n  effRequests: max(0, requests - ignores)\n  if (effRequests > 0)\n    // Respond\n    spNext: spLast + resSign * min(abs(spResMax), abs(spRes * effRequests))\n  else\n    // Trim\n    spNext: spLast + spTrim\n    \n  // Apply bounds\n  spNext= min(max(spNext,rs->spMin),rs->spMax)\n  // Apply unit\n  spNext= spNext.as(sp->unit)\n  \n  // Write new setpoint to history and to BACnet point if writable\n  {ts:now(), val:spNext}.hisWrite(sp)\n  if (sp.has(\"writable\"))\n    pointWrite(sp,                       // Writable point\n               spNext,                   // Value to write (ignores)\n               16,                       // BACnet priority\n               \"facAhuResetSpNow\")       // Source\n               \n  // If setpoint's equip has a watchdog accumulator, increment\n  watchdogPt: read(watchdog and accumulator and cmd and equipRef==sp->equipRef,false)\n  if (watchdogPt!=null) do\n    watchdogHis: watchdogPt.hisRead(now()-offlineTime..now())\n    watchdog: if (isEmpty(watchdogHis)) 0\n              else (watchdogHis.colToList(\"v0\").last.as(1) + 1)\n    {ts:now(), val:watchdog}.hisWrite(watchdogPt)\n    if (watchdogPt.has(\"writable\"))\n    pointWrite(watchdogPt,               // Writable point\n               watchdog,                 // Value to write (ignores)\n               16,                       // BACnet priority\n               \"facAhuResetSpNow\")       // Source\n  end\nend\n\n/*\n  Updates\n  2020-02-28   Added storage of total incoming requests, incoming ignores and number\n               of zones reporting. Added management of base ignores + addtl ignores.\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"initWeatherLBNL1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  DEPRECATED, use synchronization script with init_start_date\n\n This script is meant to be run once to initially populate\n LBNL weather station point histories using a large query\n from mesowest. A different function will be used to synchronize\n recent history on a regular basis.\n \n parseFloat is used by default on all values, script will need to be\n modified if importing strings or other types.\n \n For large imports, script should be run as a job.\n*/\n() => do\n  // Set parameters: range of dates to import\n  start_date: 2013-01-01\n  end_date: 2017-11-08\n  start_date= 2017-11-01\n  \n  // Set parameters: csv column names of interest, converted to legal tag names,\n  //   and associated weather points of interest, by id\n  datetime_t: toTagName(\"Date_Time\")\n  pt_list: [\n    {tagName: toTagName(\"air_temp_set_1\"), link: readById(@p:lbnl:r:21954442-d84f76af)},\n    {tagName: toTagName(\"air_temp_set_2\"), link: readById(@p:lbnl:r:2194e058-3f3ac56d)},\n    {tagName: toTagName(\"pressure_set_1\"), link: readById(@p:lbnl:r:21954521-a510f570)},\n    {tagName: toTagName(\"relative_humidity_set_1\"), link: readById(@p:lbnl:r:219543f4-55d8f4c0)},\n    {tagName: toTagName(\"dew_point_temperature_set_1d\"), link: readById(@p:lbnl:r:2195488b-f8b89630)},\n    {tagName: toTagName(\"wind_speed_set_1\"), link: readById(@p:lbnl:r:2195460a-3039caf5)},\n    {tagName: toTagName(\"wind_gust_set_1\"), link: readById(@p:lbnl:r:21954730-b9e48c6e)},\n    {tagName: toTagName(\"wind_direction_set_1\"), link: readById(@p:lbnl:r:219546a6-a3325fb6)},\n    {tagName: toTagName(\"precip_accum_fifteen_minute_set_1\"), link: readById(@p:lbnl:r:219547ab-f705db2e)},\n    {tagName: toTagName(\"solar_radiation_set_1\"), link: readById(@p:lbnl:r:21954364-2304a444)}\n  ]\n  \n  // Prepare query\n  start_string: start_date.format(\"YYYYMMDD\")+\"0000\"  // Start query at midnight on start day\n  end_string: end_date.format(\"YYYYMMDD\")+\"2359\"      // End query at 23:59 on end day\n  q_base: \"\"\"https://api.mesowest.net/v2/stations/timeseries?\"\"\"\n  q_station: \"\"\"stid=LBNL1\"\"\"\n  q_start: \"\"\"&start=\"\"\" + start_string\n  q_end: \"\"\"&end=\"\"\" + end_string\n  q_token: \"\"\"&token=ad9d3c454bfc41df91c40d7f8ea6acdd\"\"\"\n  q_output: \"\"\"&output=csv\"\"\"\n  q_units: \"\"\"&units=temp|F,speed|mph,pres|mb,precip|in,ENGLISH\"\"\"\n  q_tz: \"\"\"&obtimezone=local\"\"\"\n  query: q_base + q_station + q_start + q_end + q_token + q_output + q_units + q_tz\n  return query //TMP\n  \n  // Execute query\n  raw: ioReadLines(``+query)\n\n  // Headers are in line 7 (index 6)\n  h_str: raw[6]\n  h_list: h_str.split(\",\")\n  h_list_safe: h_list.map(str => toTagName(str))\n\n  // Iterate on remaining rows, parse and store data\n  raw[8..-1].map line => do\n    v_list: line.split(\",\")\n    rec_dict: {}\n    v_list.each((rec, i) => rec_dict = rec_dict.set(h_list_safe[i],v_list[i]))\n    // Parse date and time: adding Los_Angeles to end of string to properly recognize \"2017-11-05T01:00:00-08:00\" as PST\n    rec_dict = rec_dict.set(datetime_t,\n                            parseDateTime(rec_dict[datetime_t]+\" Los_Angeles\", \"YYYY-MM-DDThh:mm:SSz zzzz\", \"Los_Angeles\"))\n    \n    // Iterate through list of points of interest and write records if value is available\n    pt_list.each pt => do\n      pt_val: parseFloat(rec_dict[pt[\"tagName\"]], checked: false)\n      if (pt_val != null) do\n        {ts: rec_dict[datetime_t], val: pt_val}.hisWrite(pt[\"link\"])\n      end\n    end\n  end\n  \n  /*\n  if (number>30) do percentile:30\n  end else if (number<0) do percentile:0\n  end else do percentile:number end\n  */\n  \n  // Test references\n  //ioReadLines(`https://api.mesowest.net/v2/stations/timeseries?stid=LBNL1&start=201312010000&end=201312011200&token=ad9d3c454bfc41df91c40d7f8ea6acdd&output=csv&units=ENGLISH`)[6..-1]\n  //(ioReadLines(`https://api.mesowest.net/v2/stations/timeseries?stid=LBNL1&start=201312010000&end=201312011200&token=ad9d3c454bfc41df91c40d7f8ea6acdd&output=csv&units=ENGLISH`)[8..-1]).first.ioReadCsv({noHeader})\n  //parseDateTime(\"2017-11-05T01:00:00-07:00\", \"YYYY-MM-DDThh:mm:SSz\", \"Los_Angeles\") // PDT\n  //parseDateTime(\"2017-11-05T01:00:00-08:00\", \"YYYY-MM-DDThh:mm:SSz\", \"Los_Angeles\") // PST but displayed as GMT+8? Probably because it doesn't know if the input is indeed Los_Angeles tz\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toAhuCool",,,"(ahu, checked:true) => do\n  cools: readAll(cool and cmd and not enable and equipRef == ahu->id)\n\n  if (cools.size > 1) cools = cools \n  if (cools.isEmpty) do\n    if (checked) throw \"No 'cool' points defined: \" + dis(ahu)\n    return null\n  end\n  cools\nend\n",,
,["ptVirtualPowerIntegrator"],,,,M,,,,,,"tmp59VirtualEnergyPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  locationRef: @p:lbnl:r:2415b3de-7366c056 // B59 Data Center\n  powerPts: readAll(locationRef==@p:lbnl:r:2415b3de-7366c056 and power and sensor and point)\n  \n  // For each power point, create a virtual energy point\n  powerPts.each pt => do\n    ptDict: {navName: pt->navName+ \" Energy\",\n             disMacro: \"\\\$equipRef \\\$navName\",\n             equipRef: pt->equipRef,\n             his,\n             kind: \"Number\",\n             locationRef: pt->locationRef,\n             point,\n             sensor,\n             energy,\n             delta,\n             siteRef: pt->siteRef,\n             tz: \"Los_Angeles\",\n             unit: \"kWh\",\n             virtual,\n             hisMaxGap: 5min,\n             hisFunc:\"ptVirtualPowerIntegrator\",\n             pointRef: pt->id}\n             \n    commit(diff(null, ptDict, {add}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptMetricsCoolingSystemPpue",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This virtual point function (hisFunc) calculated the cooling system\n  pPUE of the CRAY computers at B59, comparing the cooling systems (including \n  CRAY fan kW) with the CRAY compute kW.\n  \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n\n  computerRef: rec->equipRef\n  computeMeter: read(meter and compute and equipRef==computerRef, false)\n  computePowerPt: read(power and sensor and equipRef==computeMeter->id, false)\n  fanMeter: read(meter and fan and equipRef==computerRef, false)\n  fanPowerPt: read(power and sensor and equipRef==fanMeter->id, false)  \n  \n  interval: rec->hisVirtualInterval\n  \n  //Name the locations for additional power trends needed\n  twLocRef: @p:lbnl:r:22dbdae2-0f98c395\n  cwLocRef: @p:lbnl:r:2322ff61-f91a05fc\n  \n  \n  //Grab specific power trends for B59\n  towerPumpPowerPts:readAll(locationRef==twLocRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  towerFanPowerPts:readAll(locationRef==twLocRef\n                    and equipRef->fan\n                    and power\n                    and sensor)\n  cwPumpPowerPts:readAll(locationRef==cwLocRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n  //hisRead and rollups for these histories\n  towerPumpPower: towerPumpPowerPts.hisRead(dates, {limit:null})\n                                   .hisRollup(avg, interval)\n                                   .hisFoldCols(sum)\n                                   .renameCol(\"v0\",\"twPump\")\n                                  \n  towerFanPower: towerFanPowerPts.hisRead(dates, {limit:null})\n                                 .hisRollup(avg, interval)\n                                 .hisFoldCols(sum)\n                                 .renameCol(\"v0\",\"twFan\")\n                                   \n  cwPumpPower: cwPumpPowerPts.hisRead(dates, {limit:null})\n                             .hisRollup(avg, interval)\n                             .hisFoldCols(sum)\n                             .renameCol(\"v0\",\"cwPump\")\n  \n  computePower: computePowerPt.hisRead(dates, {limit:null})\n                              .hisRollup(avg, interval)\n                              .renameCol(\"v0\",\"compute\")\n  \n  fanPower: fanPowerPt.hisRead(dates, {limit:null})\n                      .hisRollup(avg, interval)\n                      .renameCol(\"v0\",\"fan\")\n  \n  grid: hisJoin([towerPumpPower, towerFanPower, cwPumpPower, computePower, fanPower])\n        .addCol(\"ppue\", row => do\n          if (row.any(v => v==null or v==na() or v==0)) return na()\n          else return ((row->compute + row->fan + row->twPump + row->twFan + row->cwPump) / row->compute).as(1)\n        end)\n        .each(row => yield(row->ts, row->ppue))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"findBacnetTrend",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given connector, this function uses bacnetName or bacnetCurName of\n  existing points which use this connector and attempts to find an associated\n  trend by looking up all existing trends and matching them by name.\n*/\n\n(connRef) => do\n  trendsGrid: bacnetLearn(connRef, 20)\n  \n  // Exit if no trends are found on connector\n  if (isEmpty(trendsGrid)) return null\n\n  points: readAll(point and bacnetConnRef==connRef)\n  points.each pt => do\n    if (pt[\"bacnetCurName\"] != null) do  // Primary way of storing bacnet dis\n      curName: pt[\"bacnetCurName\"]\n    end else if (pt[\"bacnetName\"]  != null) do // Secondary way\n      curName: pt[\"bacnetName\"]\n    end else curName: null\n    \n    // Skip point if no bacnet name available\n    if (curName == null) return null\n    \n    // Use regex to find corresponding trend (if several exist,\n    // only one will be used)\n    validTrend: trendsGrid.find(row => reFind(curName + \".Trend\", row->dis) != null)\n    \n    if (validTrend == null) return null\n    \n    hisName: validTrend->dis\n    his: validTrend->bacnetHis\n    \n    commit(diff(pt, {bacnetCurName: curName, bacnetHisName: hisName, bacnetHis: his, -bacnetName, tmp: today()}))\n  end  // points.each pt\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["hisFormula"],,,,M,,,,,,"hisFormula",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given timestamp, determine formula defined by hisFormula\n  database records associated with pointRef.\n\n  Arguments:\n  ts          DateTime\n  pointId     Target point id\n*/\n\n(ts, pointId) => do\n  readAll(hisFormula and pointRef==pointId)\n  .findAll(\n      row => (ts > row->startDateTime) and \n      (row[\"endDateTime\"]==null or ts <= row[\"endDateTime\"]))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB34CHWPressControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236278c5-3e59eb7a,\n             @p:lbnl:r:23639805-481e46e3,\n             @p:lbnl:r:23639805-6c1add95,\n             @p:lbnl:r:23639805-a5a9a9d7,\n             @p:lbnl:r:23639805-4964dba3,\n             @p:lbnl:r:23639805-05ae3932,\n             @p:lbnl:r:23639805-b9d8e55a,\n             @p:lbnl:r:23639805-eea6c79e,\n             @p:lbnl:r:23639805-903e2c0e])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB34TRWPressControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:23514801-c3638d61,\n             @p:lbnl:r:235149c6-a9dad121,\n             @p:lbnl:r:23514953-bdc7aa1b,\n             @p:lbnl:r:23514c11-a9c9453f,\n             @p:lbnl:r:23514b45-db3fb47b,\n             @p:lbnl:r:23514cbf-4be05b97,\n             @p:lbnl:r:23514cbf-3ffc6b86])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74Tsi8682",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point, add these points to zone and to equips that already exist.\n \n The file includes a match to the 2018-11-28 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(file: `io/integration_b74/tsi_8682.csv`,\ntypes: [2,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(file)\n  \n  siteId: read(site and dis==\"74\")->id\n  failedList: []\n\n  // Cycle through existing terminal units\n  tus: readAll(supply and terminalUnit and equip\n               and controls==\"lbnl74_tsi_8682_bacnet\"\n               and siteRef==siteId)\n  \n  tus.each((tu, i) => do\n    jobProgress(round(i/tus.size()*100).as(\"%\"), tu.dis())\n    locationId: tu->locationRef\n    zoneId: tu->equipRef\n    connectorId: tu->connRef\n    instance: tu->connInstance\n    \n    // Find exhaust TU if it exists\n    etu: read(exhaust and terminalUnit and equip and equipRef==zoneId,\n              false)\n    \n    // Prepare list of bacnet grids containing all bacnet info for given types\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"TL\"]\n    \n    try do\n      types.each type => do\n        learn: bacnetLearn(connectorId, type)\n        bacnetPtList= bacnetPtList.set(type, learn)\n      end\n    end catch (ex) do\n      failedList= failedList.add(tu.dis())\n      // Skip terminal unit\n      return null\n    end\n\n    // Cycle through given points of interest, find and integrate\n    alcPtList.each pt => do\n      // Find corresponding tag set info in tagging standard\n      tagRow: tagStd.find(tag => tag->index==pt->indexTagStandard)\n    \n      // Initialize found bacnet rows to null\n      bacnetCurRow: null\n      bacnetHisRow: null\n    \n      // If bacnetCur is available, retrieve corresponding info\n      if (pt[\"bacnetCurName\"] != null) do\n        curType: bacnetObjMap.index(pt[\"bacnetCurType\"])\n        curName: pt->bacnetCurName + \"_\" + instance\n        \n        // Find available BACnet point info\n        bacnetCurGrid: bacnetPtList[curType]\n        if (bacnetCurGrid == null) bacnetCurGrid= [].toGrid()\n        bacnetCurRow= bacnetCurGrid.find(row => row[\"dis\"]==curName)\n        \n        // If point not found in BACnet, it is hidden or does not\n        // exist for this zone. Skip point only if bacnetHis also missing\n      end // If bacnetCur is available\n      \n      // If bacnetHis is available, retrieve corresponding info\n      if (pt[\"bacnetHisName\"] != null) do\n        hisName: pt->bacnetHisName + \"_\" + instance\n        \n        // Find available BACnet point info\n        bacnetHisGrid: bacnetPtList[20]\n        if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n        bacnetHisRow= bacnetHisGrid.find(row => row[\"dis\"]==hisName)\n      end\n\n      // If we did not find BACnet info for either Cur or His, skip point\n      if ((bacnetCurRow == null) and (bacnetHisRow == null)) return null\n      \n      // Check equipment type to determine proper equipRef\n      equipId: if (pt->eq==\"supply\") tu->id\n               else if (pt->eq==\"exhaust\") etu->id\n               else zoneId\n          \n      // If point already exists, skip\n      ptFilter: \"point and equipRef==@\" + equipId + \" and \"\n                + tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n      if (read(parseFilter(ptFilter),false) != null) return null\n          \n      // Prepare polling variables as needed (null if bacnetHis)\n      hisCollectCov: if (pt[\"hisCollectCov\"]==null) null else marker()\n      hisCollectInterval: if (pt[\"hisCollectCov\"]==null) null else 12h\n      \n      // Prepare new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: if (bacnetCurRow != null) bacnetCurRow[\"bacnetCur\"],\n               bacnetHis: if (bacnetHisRow != null) bacnetHisRow[\"bacnetHis\"],\n               bacnetCurName: if(pt[\"bacnetCurName\"] != null) pt->bacnetCurName + \"_\" + instance,\n               bacnetHisName: if(pt[\"bacnetHisName\"] != null) pt->bacnetHisName + \"_\" + instance,\n               bacnetDesc: if (bacnetCurRow != null) bacnetCurRow[\"bacnetDesc\"], //optional\n               kind: if (bacnetCurRow != null) bacnetCurRow[\"kind\"] else pt[\"kind\"],\n               unit: if (pt[\"unit\"] != null or bacnetCurRow == null) pt[\"unit\"]\n                     else bacnetCurRow[\"unit\"],\n               enum: if (bacnetCurRow != null) bacnetCurRow[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               hisCollectCov: hisCollectCov,\n               hisCollectInterval: hisCollectInterval,\n               notes: pt[\"alcDisplay\"], //optional\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp2: today()}\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n    end  // alcPtList.each pt\n  end)  // each tu\n  \n  return failedList\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"anAirChangeRate",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given zone, retrieve info regarding area, ceiling height, min air change\n  rate requirements and measured airflow (supply or exhaust), then calculate\n  achieved air change rate over time.\n  \n  Return history grid with achieved ACR (achievedACR) and minimum ACR (minACR)\n  \n  Arguments: \n  zoneRef            Reference of zone equip\n  dates              Span, dates to run analysis on\n  exhaust            Bool, if true use exhaust side,\n                           if false use supply side\n*/\n\n(zoneRef: @p:lbnl:r:239c4b07-57f483a7, dates: pastWeek(),\n exhaust: false, filterZero:true) => do\n  // Retrieve zone record\n  zone: readById(zoneRef)\n  \n  // Check that provided reference is for a zone equip and that the zone\n  // equip has the required info\n  if (not(zone.has(\"zone\") and zone.has(\"equip\") and zone.has(\"area\")\n          and zone.has(\"height\") and zone.has(\"minAirChangeRate\")))\n    return null\n  \n  // Retrieve needed values\n  area: zone->area.to(1ft²)\n  height: zone->height.to(1ft)\n  minAcr: zone->minAirChangeRate\n  if (minAcr.unit() != \"_ach\") return null\n  volume: area * height\n  \n  // Retrieve airflow points on supply or exhaust\n  if (exhaust)\n    airflows: toolRecursiveSearch(zoneRef,\n        \"point and air and flow and sensor and \"\n        + \"(equipRef->exhaust or equipRef->fumeHood)\")\n  else\n    airflows: toolRecursiveSearch(zoneRef,\n        \"point and air and flow and sensor and \"\n        + \"equipRef->supply\")\n  \n  grid: airflows.hisRead(dates, {limit:null}).hisInterpolate().hisFoldCols(sum)\n                .renameCol(\"v0\", \"airflow\")\n                .addCol(\"achievedACR\", row => do\n                  if(filterZero and row->airflow != null and row->airflow != na()\n                     and round(row->airflow) == 0) return na()\n                  if(row->airflow == null) return null\n                  if(row->airflow == na()) return na()\n                  return (row->airflow.to(1cfm) * 60 / volume).as(\"_ach\")\n                end)\n                .addCol(\"minACR\", row => minAcr)\n                .addColMeta(\"achievedACR\",\n                    {dis:zone.dis()+\" achieved ACR\",\n                     equipRef: zone->id,\n                     airChangeRate, sensor, virtual,\n                     kind:\"Number\", unit:\"_ach\",\n                     chartMin:0})\n                .addColMeta(\"minACR\", {dis:zone.dis()+\" minimum ACR\"})\n                .keepCols([\"ts\",\"achievedACR\",\"minACR\"])\n  \n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Gas Demand (therm/h)",,M,"Site natural 1-hour average gas demand min, max, average over time period.",,,"site",,"kpiGasPower",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(power and sensor and equipRef->gas and \n           equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisMap(val => val.to(1therm/h))\n                                       .hisRollup(avg, 1h)\n  \n  if (his.isEmpty or\n      his.meta[\"hisEnd\"] < pt[\"hisStart\"] or\n      his.missing(\"v0\")) return null\n\n  kpi: {min: his.foldCol(\"v0\", min),\n        max: his.foldCol(\"v0\", max),\n        avg: his.foldCol(\"v0\", avg)}\n\n  if (kpi.any v => na() == v ) null else kpi.map v => v.as(1)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHierarchy"],,,,M,,,,,,"toolHierarchy",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given point or equip, return a list of ids of all the \n  records above it, including potential chain of equips, e.g.\n  [siteId, locationId, equipId, equipId, equipId]\n  \n  Arguments: \n  N/A\n*/\n\n(recId, result:[]) => do\n  if (recId==null) return [null]\n  \n  if (isRef(recId)) rec: readById(recId)\n  else rec: recId\n  \n  result= result.add(rec->id)\n  \n  if(rec.has(\"equipRef\"))\n    result= toolHierarchy(rec->equipRef, result)\n  else if(rec.has(\"locationRef\"))\n    result= toolHierarchy(rec->locationRef, result)\n  else if(rec.has(\"siteRef\"))\n    result= toolHierarchy(rec->siteRef, result)\n  else return result\n  \n  return result\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridGapsPeriods"],,,,M,,,,,,"gapExists",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function gives a boolean answer to the question:\n  \n    Does a data gap exist in this period?\n  \n  It will evaluate TRUE if a gap exists and FALSE if a gap does\n  not exist.\n  \n  Arguments:\n  hisGrid                  Grid\n  year (optional)          Desired calendar year. Default is year\n                           previous to current year.\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2019-10-08 //\n*/\n\n(hisGrid,maxGap:12hr) => do\n  gapsPeriods: hisGrid.toolHisGridGapsPeriods(maxGap)\n  \n  gaps: gapsPeriods.map row => do\n    {gap: row[\"gap\"]}\n  end\n  \n  existenceOfGaps: gaps.any row => row->gap==true\n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolExportView","toolExportFunc"],,,,M,,,,,,"toolExportView",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given view name or list of names, load view records \n  as well as any func dependencies. Remove transient tags. Export results\n  to `io/tmp/view.zinc`\n  \n  Arguments: \n  tNamesList     List of Str, names of target functions and views\n                 Can also be one Str, will be converted to [Str]\n  level          Number, used for recursiveness, 0 is main call\n*/\n\n(tNamesList, level:0) => do\n  // If single name given, convert to list\n  if (isStr(tNamesList)) tNamesList= [tNamesList]\n  // Remove duplicates\n  tNamesList= tNamesList.unique()\n  // Initialize updated list of tNames to keep track of changes\n  tNamesListU: tNamesList\n  \n  // Go through list and add dependencies within list\n  tNamesList.each tName => do\n    // Find target by name\n    t: read((view==tName) or (func and name==tName), false)\n    // Remove name from list if target not found\n    if (t==null) tNamesListU= tNamesListU.findAll(v => v!=tName)\n    // Add dependencies if function found\n    else if (t.has(\"depends\"))\n      tNamesListU= tNamesListU.addAll(t->depends)\n  end\n  \n  // Remove duplicates from new list\n  tNamesListU= tNamesListU.unique()\n\n  // Compare lists to determine if any changes were made\n  noChanges: tNamesListU.all(tName => tNamesList.contains(tName))\n             and\n             tNamesList.all(tName => tNamesListU.contains(tName))\n\n  // If changes were made, call function again to evaluate\n  // dependencies of the functions that were added\n  if (not(noChanges))\n    tNamesListFinal: toolExportView(tNamesListU, level+1)\n  else\n    tNamesListFinal: tNamesListU\n  \n  // Recursive calls return\n  if (level > 0) return tNamesListFinal\n  // Main call continues (level == 0), if list is empty exit\n  if (tNamesListFinal.size==0) return null\n \n  // Load functions, views and all dependencies\n  ts: readAll(func or view)\n      .findAll(r => (r.has(\"func\") and tNamesListFinal.contains(r->name)) or\n                    tNamesListFinal.contains(r[\"view\"]))\n  \n  // Remove empty columns\n  nullColNames: ts.colNames.findAll colName => do\n    ts.all row => row[colName] == null\n  end\n  ts= ts.removeCols(nullColNames)\n\n  // Remove transient tags\n  ts= ts.removeCols([\"id\",\"mod\"])\n  \n  // Store results\n  ts.ioWriteZinc(`io/tmp/view.zinc`)\nend\n\n/*\n  Updates\n  2020-03-11   Raphael Vitti\n    Function created using toolExportFunc as starting point.\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viAvgProfileByDayOfWeek",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays daily averages for the given point over the given period,\n  one daily profile per day of the week.\n  \n  Arguments: \n  ptRef     ref (dict) for selected point\n  span      period to use to calculate profiles\n  interval  time interval to roll up and align data\n  chartType string, either \"area\", \"scatter\" or \"line\"\n*/\n\n(ptRef: readById(@p:lbnl:r:22757154-51128bbf), span: pastYear(),\n interval: 10min, chartType: \"area\") => do\n  data: ptRef\n        .hisRead(span, {limit:null})\n        \n  if (ptRef->kind==\"Bool\")\n    data= data.hisMap(val => if (val) 100% else 0%)\n              .hisRollup(covAvg, interval)\n  else\n    data= data.hisRollup(avg, interval)\n    \n  data= data.flatMap(row => [{\n                ts:row->ts,\n                monday: if(weekday(row->ts)==1) row[\"v0\"] else null,\n                tuesday: if(weekday(row->ts)==2) row[\"v0\"] else null,\n                wednesday: if(weekday(row->ts)==3) row[\"v0\"] else null,\n                thursday: if(weekday(row->ts)==4) row[\"v0\"] else null,\n                friday: if(weekday(row->ts)==5) row[\"v0\"] else null,\n                saturday: if(weekday(row->ts)==6) row[\"v0\"] else null,\n                sunday: if(weekday(row->ts)==0) row[\"v0\"] else null}])\n            .hisDailyProfile(avg)\n            .addMeta({chartType: chartType, chartLegendNoSort})\n            .addColMeta(\"saturday\", {color: \"#555555\"})\n            .addColMeta(\"sunday\", {color: \"#000000\"})\n            .addMeta({title: readById(ptRef->id).dis\n                      + \", Average Daily Profile by Day of Week\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anReadMeterMonthly"],,,,M,,,,,,"viMeterGasHillRemainder",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display Hill+UC and Remainder monthly gas consumption on a bar chart.\n  \n  Arguments: \n  N/A\n*/\n() => do\n  // Variables\n  hillSumMeterRef: @p:lbnl:r:25accd6c-ba82fce2\n  hillRemainderMeterRef: @p:lbnl:r:258acb00-b0389f89\n  \n  // Get monthly consumption grids\n  hillSumReads: anReadMeterMonthly(hillSumMeterRef, 65°F, 55°F, true)\n  hillRemainders: anReadMeterMonthly(hillRemainderMeterRef, 65°F, 55°F, true)\n  \n  // Rename columns and add display names\n  hillSumReads= hillSumReads\n  .keepCols([\"readDate\",\"cons\",\"consumptionPerDay\",\"heat\",\"cool\"])\n  .renameCol(\"consumptionPerDay\", \"hillSumAvgDaily\")\n  .addColMeta(\"hillSumAvgDaily\",\n              {dis: \" Sum of Hill Submeters and UC Submeters, Avg Daily Consumption\"})\n  .renameCol(\"cons\", \"hillSumCons\")\n  .addColMeta(\"hillSumCons\",\n              {dis: \" Sum of Hill Submeters and UC Submeters, Consumption\"})\n  \n  hillRemainders= hillRemainders\n  .keepCols([\"readDate\",\"cons\",\"consumptionPerDay\"])\n  .renameCol(\"consumptionPerDay\", \"hillRemainderAvgDaily\")\n  .addColMeta(\"hillRemainderAvgDaily\",\n              {dis: \"Calculated Remainder, Avg Daily Consumption\"})\n  .renameCol(\"cons\", \"hillRemainderCons\")\n  .addColMeta(\"hillRemainderCons\",\n              {dis: \"Calculated Remainder, Consumption\"})\n\n  // Join grids\n  disGrid: join(hillSumReads, hillRemainders, \"readDate\")\n  \n  // Add percent submetered and unmetered\n  disGrid= disGrid\n  .addCol(\"percentUnmetered\",\n    r => if(r.missing(\"hillRemainderCons\")) null\n         else ((r[\"hillRemainderCons\"] / (r[\"hillRemainderCons\"] + r[\"hillSumCons\"]))*100).as(\"%\"))\n  .addCol(\"percentSubmetered\",\n    r => if(r.missing(\"hillRemainderCons\")) null\n         else ((r[\"hillSumCons\"] / (r[\"hillRemainderCons\"] + r[\"hillSumCons\"]))*100).as(\"%\"))\n  \n  // Format for display\n  disGrid= disGrid\n  .addMeta({view:\"chart\",\n            title:\"Sum of Monthly Gas Submeter Reads (Hill & UC) and Unmetered Remainder Calculated from Daily Hill+UC Meter Reads\"})\n  .addColMeta(\"hillSumAvgDaily\",\n              {color: \"crimson\",\n               chartGroup:\"1\",\n               chartType:\"stackedBar\"})\n  .addColMeta(\"hillRemainderAvgDaily\",\n              {color: \"black\",\n               chartGroup:\"1\",\n               chartType:\"stackedBar\"})\n  .addColMeta(\"hillSumCons\",\n              {color: \"crimson\",\n               chartGroup:\"2\",\n               chartType:\"stackedBar\"})\n  .addColMeta(\"hillRemainderCons\",\n              {color: \"black\",\n               chartGroup:\"2\",\n               chartType:\"stackedBar\"})\n  .addColMeta(\"percentUnmetered\",\n              {dis: \"Unmetered Consumption as Percentage of Main Hill+UC Meter Consumption\",\n               color: \"orange\",\n               chartGroup:\"3\",\n               chartType:\"stackedBar\",\n               chartMin:0%,\n               chartMax:100%})\n  .addColMeta(\"percentSubmetered\",\n              {dis: \"Submetered Consumption\",\n               color: \"forestGreen\",\n               chartGroup:\"3\",\n               chartType:\"stackedBar\",\n               chartMin:0%,\n               chartMax:100%})\n  .addColMeta(\"heat\",\n              {dis:\"Avg Daily Heating Degree Days, Base: \"+65°F,\n               color:\"red\",\n               chartGroup:\"4\",\n               chartType:\"bar\"})\n  .addColMeta(\"cool\",\n              {dis:\"Avg Daily Cooling Degree Days, Base: \"+55°F,\n               color:\"blue\",\n               chartGroup:\"4\",\n               chartType:\"bar\"})                  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateDataQuality"],,,,M,,,,,,"recDuplicateDataQuality",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Record duplication action for meter data quality records\n  \n  Arguments:\n  dataQualityDict      Dict containing only changes to the original\n                       selected record duplication is based on.\n*/\n\n(dataQualityDict) => do\n  // Normalize action input\n  dataQualityDict= actionNormInput(dataQualityDict, \"dict\")\n  \n  // Load original dictionary based on id, this dict will contain\n  // all fields\n  originalDict: readById(dataQualityDict->id)\n  \n  // Initialize new dictionary for our new record\n  newDict: originalDict\n  \n  // Any record present in dataQualityDict represents a change\n  // from the originalDict. Apply change to newDict.\n  dataQualityDict.each((v,n) => do\n    newDict= newDict.set(n, v)\n  end)\n\n  // This will be a new record, remove \"id\" and \"mod\" fields\n  newDict= newDict\n  .remove(\"id\")\n  .remove(\"mod\")\n  \n  // Validate record\n  newDict= recValidateDataQuality(newDict)\n  \n  // Save record\n  recNew(newDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["scrapeConvertStrToNum"],,,,M,,,,,,"scrapePgeGas",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function scrapes gas meter data from the PG&E website by\n accessing the website, finding the the csv that contains the\n data, and parsing through that csv for relevant values.\n\n Arguments:\n restartDate (optional)   Date to scrape history from. Must be\n                          a dateTime, not a date. If no date is\n                          given, default will be the last time\n                          data was scraped.\n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-08-13 //\n*/\n\n(restartDate:null) => do\n  // Read the website.\n  //website_text: ioReadLines(`https://gts.pge.com/gts/oib/queryUsage.do`)\n  \n  // ioReadLines(`https://gts.pge.com/gts/export/oib/queryUsage.do?queryCriteria.endDate=07%2F31%2F2018&submit=&queryCriteria.usageContract.locationName=PG%26E+Ctygte+Distrb+Intercon&queryCriteria.usageContract.contractTypeID=&queryCriteria.usageContract.contractCodeTypeShortName=NGSA&d-49653-e=1&submitButtonPressed=submit&queryCriteria.usageContract.contractCode=0678684&queryCriteria.usageContract.contractID=1153&queryCriteria.usageContract.locationCode=CTYG&businessPartnerInfo.code=0678684&6578706f7274=1&queryCriteria.startDate=07%2F01%2F2018&queryCriteria.usageContract.contractCodeName=US+DOE%2FLAWRENCE+BERKELEY+NATIO`)\n  \n  pge_sample: readById(@p:lbnl:r:22f34b54-3d5e353f)\n  grid: ioReadCsv(pge_sample)\n  // Turn each row of the grid from string into a date and number.\n  new_grid: grid.map row => do\n    gas_usage: row->gasUsageDth\n    gas_usage= scrapeConvertStrToNum(gas_usage)\n    gas_usage= gas_usage*10therm\n    date_string: row->gasDay\n    \n    if (date_string.size == 10) do // First possible parseDate format.\n      date: parseDate(date_string,\"MM/DD/YYYY\")\n    end else if (date_string.size == 9) do \n      try date: parseDate(date_string,\"M/DD/YYYY\") // Second possible parseDate format.\n      catch date: parseDate(date_string,\"MM/D/YYYY\") // Third possible parseDate format.\n    end else if (date_string.size == 8) do\n      date: parseDate(date_string,\"M/D/YYYY\") // Fourth possible parseDate format.\n    end else do // Not important, but for now keep it.\n      date: \"Total\"\n    end\n    {date: date, gasUsage: gas_usage}\n  end\n  //filtered_grid: new_grid.findAll row => isDate(row->date)\n  new_grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHierarchy"],,,,M,,,,,,"viTargetsDeficiencies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given list of targets (points or equips), and a given span,\n  return a timeline of deficiencies that apply at or above each\n  target.\n  \n  Arguments: \n  recsIds      List of target ids\n  span         Datespan\n*/\n\n(recsIds:[null, @p:lbnl:r:235126e0-5461ac88], span:pastMonth()) => do\n  // Input check\n  span= span.toDateSpan()\n  \n  // All records above in the equip hierarchy are valid targets\n  listTargets: []\n  recsIds.each recId =>\n    listTargets= listTargets.addAll(toolHierarchy(recId))\n  listTargets= listTargets.unique()\n  \n  // Find deficiencies that apply to any of the targets\n  deficiencies:\n    readAll(deficiency and equipRef)\n    // Filter out deficiencies not related to targets\n    .findAll(def => listTargets\n                    .any(target => target==def->equipRef))\n    // Filter out deficiencies that ended before span's start or\n    // started after span's end\n    .findAll(def => do\n      if (def.has(\"endDate\") and (def->endDate < span.start()))\n        return false\n      if (def.has(\"startDate\") and (def->startDate > span.end()))\n        return false\n      return true\n    end)\n  \n  if(isEmpty(deficiencies)) return null\n  \n  // Chart deficiencies\n  chart: {}.toGrid()\n  deficiencies.each def => do\n    dstart: if(def.has(\"startDate\")\n               and (def->startDate > span.start()))\n              def->startDate\n            else\n              span.start()\n    dend: if(def.has(\"endDate\")\n               and (def->endDate < span.end()))\n              def->endDate\n            else\n              span.end()\n    dspan: (dstart..dend).toSpan()\n    defTrend: hisSlidingWindows(dspan,1h,1h)\n              .addColMeta(\"v0\", {dis: \"Deficiency - \"+def.dis()+\" - \"+def->state,\n                                 color: \"#b3b300\",\n                                 spark})\n    if (isEmpty(chart)) chart= defTrend\n    else chart= hisJoin([chart, defTrend])\n  end\n  \n  return chart.addMeta({view:\"chart\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualAverageNan",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  average value of all points which have a virtualRef equal\n  to the id of the virtual point, and it excludes NA values.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .addCol(\"nanAvg\", row => do\n           n: row.remove(\"ts\")\n                 .findAll(v => (v != na()) and (v != null))\n                 .size\n           s: row.remove(\"ts\")\n                 .map(x => if (x==null or x==na()) 0 else x)\n                 .fold(sum)\n           return if(n==0) na() else s / n\n         end)\n         .each(row => yield(row->ts, row->nanAvg))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB34TWTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:23639806-73d18a92,\n             @p:lbnl:r:23639805-61d4cb5e,\n             @p:lbnl:r:23639806-3da295f4,\n             @p:lbnl:r:232a2a24-62719162,\n             @p:lbnl:r:232c261e-1a9ec21f,\n             @p:lbnl:r:232a2a24-b6a3ca4d,\n             @p:lbnl:r:232c261e-0c2defb4,\n             @p:lbnl:r:23639805-a57efa11,\n             @p:lbnl:r:23639805-0b79f454,\n             @p:lbnl:r:23639806-567f926e,\n             @p:lbnl:r:23639805-0b53740c])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  grid.colNames.remove(0).each colName => do\n    his: grid.col(colName).meta\n    if (his.has(\"sp\") or his.has(\"cmd\"))\n      grid= grid.addColMeta(colName, {strokeWidth:2})\n    if (his->kind==\"Number\" and\n        (readById(his->equipRef).has(\"fan\") or\n         readById(his->equipRef).has(\"coolingTower\")\n        ))\n      grid= grid.addColMeta(colName, {chartGroup:\n          reGroups(\".*(Plant CT-\\\\d).*\", his.dis())[1]})\n  end\n*/\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["psySaturationPressure","psyHumidityRatio","psyHumidityRatioPw"],,,,M,,,,,,"psyHumidityRatio",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate humidity ratio from dry bulb and wet bulb temps,\n    from ASHRAE Fundamentals\n  \n  Arguments (unit conversions applied as first step):\n  tempDryBulb         Dry bulb temperature [°F]\n  tempWetBulb         Wet bulb temperature [°F]\n  ambientPressure     Ambient pressure [kPa]\n*/\n\n(tempDryBulb, tempWetBulb, ambientPressure) => do\n  // Unit conversions\n  tempDryBulb = tempDryBulb.to(\"°C\")\n  tempWetBulb = tempWetBulb.to(\"°C\")\n  ambientPressure = ambientPressure.to(\"kPa\")  \n\n  // Calculate saturation pressure of water vapor in the absence of air\n  pressureWaterSat: psySaturationPressure(tempWetBulb)\n  humidityRatioSat: psyHumidityRatioPw(pressureWaterSat, ambientPressure)\n  \n  // Drop units for calculations\n  tempDryBulb = tempDryBulb.as(1)\n  tempWetBulb = tempWetBulb.as(1)\n  humidityRatioSat = (humidityRatioSat/1000).as(1) // From gH20/kgAir to kgH2O/kgAir\n  \n  // Calcs and return with unit\n  if (tempDryBulb >= 0) do // Equation 35, p6.9\n    humidityRatio: (((2501 - 2.326*tempWetBulb)*humidityRatioSat - 1.006*(tempDryBulb - tempWetBulb)) / (2501 + 1.86*tempDryBulb - 4.186*tempWetBulb))\n    return (humidityRatio*1000).as(1gH₂O/kgAir)\n  end else do // Equation 37, p6.9\n    humidityRatio: (((2830 - 0.24*tempWetBulb)*humidityRatioSat - 1.006*(tempDryBulb - tempWetBulb)) / (2830 + 1.86*tempDryBulb - 2.1*tempWetBulb))\n    return (humidityRatio*1000).as(1gH₂O/kgAir)\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"ruSetpointLimit",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of periods a zone setpoint exceeds its limit.\n The zone setpoint is selected through a provided set of tags. The limit is\n provided as a text argument and can be overriden by a specific tag on the\n zone equip.\n \n Arguments:\n equip           equip record of zone to test\n span            dateSpan, span of dates to run analysis on\n tagsFilter      Str, e.g. \"zone and air and temp and effective and heating\"\n limitStr        Str, e.g. \">70\"\n minTime         duration, filter out periods shorter than minTime\n mergePeriod     duration, merge flagged periods separated by less than\n                 mergePeriod\n*/\n\n(equip:readById(@p:lbnl:r:2288e636-f4e5d1da), span:pastWeek(),\n tagsFilter: \"zone and air and temp and effective and heating\",\n limitStr: \">70\", minTime: 30min, mergePeriod: 15min) => do\n  // Use recursive search to find setpoints that match tags, keep first\n  equipId: if (isRef(equip)) equip else equip->id\n  grid: toolRecursiveSearch(equipId, tagsFilter+\" and sp\")\n  if (isEmpty(grid)) return null\n  sp: grid.first\n\n  // Load history\n  hisGrid: sp.hisRead(span, {limit:null})\n  \n  // Detect when setpoint exceeds limit conditions\n  flagPeriods: hisGrid\n      .addCol(\"flag\", row => if (row.has(\"v0\") and row->v0!=na())\n                               eval(row->v0 + limitStr)\n                             else\n                               null)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindPeriods(flag => if (flag != null) flag else false)\n\n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip.dis() + \" has \" + tagsFilter + \" setpoint \" + limitStr\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06RingAHUs",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point stored in `io/integration_b6/storage_ring_ahus.csv`\n to add these points to existing ahu equips. Create new SF and Raw equips\n as needed.\n \n This file includes a match to the 2018-09-28 tagging standard for the\n purpose of associating the proper tags and navName to each point.\n Also includes equip id.\n*/\n\n(filePath: `io/integration_b6/storage_ring_ahus.csv`, finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(filePath)\n  \n  siteId: @p:lbnl:r:211cc8a4-6dc3ebdd\n  locationId: @p:lbnl:r:23133031-d5f4f137\n  \n  cos: readAll(bacnetConn and siteRef==siteId)\n       .findAll(co => co->dis.startsWith(\"06 Storage Ring\"))\n  \n  cos.each co => do\n\t  bacnetPtList: [null, null, null, null, null, null]\n\t  bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\"]\n\t  \n\t  [0,1,2,3,4,5].each type => do\n\t\t  bacnetLearn(co->id)\n\t\t  learn: bacnetLearn(co->id, type)\n\t\t  bacnetPtList= bacnetPtList.set(type, learn)\n\t  end\n\t  \n\t  alcPtList.each row => do\n      // Find ahu\n      ahuName: reGroups(r\"06 Storage Ring - (AHU-\\d\\d) - Device \\d{5}\", co->dis)[1]\n      ahuId: read(equip and ahu and navName==ahuName and locationRef==locationId)->id\n      \n      // Create SF and Mode equips if they don't exist\n      sf: read(discharge and air and fan and equip and equipRef==ahuId, false)\n      raw: read(rawPoints and equip and equipRef==ahuId, false)\n      \n      if (sf == null) do\n        sfDict: {navName: \"Supply Fan\",\n                 disMacro: \"\\\$equipRef \\\$navName\",\n                 equip,\n                 equipRef: ahuId,\n                 locationRef: locationId,\n                 siteRef: siteId,\n                 discharge,\n                 air,\n                 fan,\n                 tmp: today()}\n        commit(diff(null, sfDict, {add}))\n        sf= read(discharge and air and fan and equip and equipRef==ahuId)\n      end\n      \n      if (raw == null) do\n        rawDict: {navName: \"Alarms & Codes\",\n                 disMacro: \"\\\$equipRef \\\$navName\",\n                 equip,\n                 equipRef: ahuId,\n                 locationRef: locationId,\n                 siteRef: siteId,\n                 rawPoints,\n                 tmp: today()}\n        commit(diff(null, rawDict, {add}))\n        raw= read(rawPoints and equip and equipRef==ahuId)\n      end\n      \n      sfId: sf->id\n      rawId: raw->id\n\t\t\t\n\t\t\t// Get info from bacnetPtList by matching bacnetCur\n\t\t\tcurType: row->bacnetCur[0..1]\n\t\t\tbacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n\t\t\tif (bacnetGrid == null) bacnetGrid= [].toGrid()\n\t\t\t  ptRowMatch: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n\t\t\tif (ptRowMatch == null)\n\t\t\t  ptRowMatch= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n\t\t\t\n      // Determine what equip to commit to based on tag index\n      index: row->indexTagStandard.parseNumber()\n      if (index > 244) equipId: rawId\n      else if (index < 52) equipId: ahuId\n      else if (index < 63) equipId: sfId\n      else equipId: ahuId\n      \n\t\t\t// Prepare new point dict\n\t\t\tptDict: {point,\n\t\t\t\t\t disMacro: \"\\\$equipRef \\\$navName\",\n\t\t\t\t\t bacnetConnRef: co->id,\n\t\t\t\t\t connRef: co->id,\n\t\t\t\t\t cur,\n\t\t\t\t\t bacnetCur: row->bacnetCur,\n\t\t\t\t\t bacnetHis: row[\"bacnetHis\"], //optional\n\t\t\t\t\t bacnetCurName: row->bacnetCurName,\n\t\t\t\t\t bacnetHisName: row[\"bacnetHisName\"],\n\t\t\t\t\t kind: ptRowMatch[\"kind\"], //optional\n\t\t\t\t\t unit: ptRowMatch[\"unit\"], //optional\n\t\t\t\t\t enum: ptRowMatch[\"enum\"], //optional\n\t\t\t\t\t equipRef: equipId,\n\t\t\t\t\t his,\n\t\t\t\t\t notes: row[\"alcDisplay\"], //optional\n\t\t\t\t\t locationRef: locationId,\n\t\t\t\t\t siteRef: siteId,\n\t\t\t\t\t tz: \"Los_Angeles\",\n\t\t\t\t\t tmp: today()}\n\t\t\t\t\t   \n\t\t\t// Set collection interval / cov if no bacnetHis\n\t\t\tif (row[\"bacnetHis\"] == null)\n\t\t\t  if (ptRowMatch[\"kind\"] == \"Bool\") do\n\t\t\t\t  ptDict= ptDict.set(\"hisCollectCov\", marker())\n\t\t\t\t  ptDict= ptDict.set(\"hisCollectInterval\", 12h)\n\t\t\t  end else do\n\t\t\t\t  ptDict= ptDict.set(\"hisCollectInterval\", 15min)\n\t\t\t  end\n\n\t\t\t// Add navName and meaningful tags from standard\n\t\t\ttagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n\t\t\tptDict= ptDict.set(\"navName\", tagRow->dis)\n\t\t\ttagSet: tagRow->tagsPtOnly.split(\",\")\n\t\t\ttagSet.each tag => do\n\t\t\t  ptDict= ptDict.set(tag, marker())\n\t\t\tend\n\n\t\t\t// Commit if finalize == true\n\t\t\tif (finalize) do\n\t\t\t  commit(diff(null, ptDict, {add}))\n\t\t\tend\n\n\t\t\treturn ptDict\n\t  end // alcPtList.each row\n  end  // cos.each co\nend\n \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridShowGaps","viSystemPowerAndWetBulb"],,,,M,,,,,,"viSystemPrePostScatter_v2",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of 15-minute of the sum of CT Fan Power, \n  CW Pump Power and TW Pump Power vs OA WB Temp data at B59 (in °F)\n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01),\n dateRangePost: lastWeek().toSpan(),\n minCompPower: null, maxCompPower: null,\n timeSeries:false, rollup:15min) => do\n  // Params\n  binWidth: 3\n \n  // Load desired data from both date ranges\n  gridPre: viSystemPowerAndWetBulb(dateRangePre, minCompPower, maxCompPower,\n                                   rollup, \"Pre\")\n  gridPost: viSystemPowerAndWetBulb(dateRangePost, minCompPower, maxCompPower,\n                                    rollup, \"Post\")\n  \n  // Sum the component system power for gridPre and gridPost \n  gridPre = gridPre.foldCols([\"twPumpPre\", \"ctFanPre\", \"trwPumpPre\"],\n                             \"totSysPowerPre\",sum)\n  gridPost = gridPost.foldCols([\"twPumpPost\", \"ctFanPost\", \"trwPumpPost\"],\n                             \"totSysPowerPost\",sum)\n                             \n  // Bin gridPre\n  binned: {}.toGrid()\n  gridPre\n  .colToList(\"oaWetBulb\")\n  .findAll(v => v!=null)\n  .map(v => round(v)).unique() // OA WB Bins\n  .each(oaWbBin => do\n    basePowers: gridPre.findAll(r => r[\"oaWetBulb\"]>=(oaWbBin-binWidth/2) and\n                                     r[\"oaWetBulb\"]<(oaWbBin+binWidth/2) and\n                                     r.has(\"totSysPowerPre\"))\n                       .colToList(\"totSysPowerPre\")\n    samples: basePowers.size\n    binned= binned.addRow(\n      {oaWetBulb: oaWbBin,\n       avg: basePowers.fold(avg),\n       percentile95: basePowers.sort((a,b) => a <=> b)[round(95 / 100 * (samples-1))]\n      })\n  end)\n  binned= binned\n  .removeCols([\"avg\"])\n  .sort((a,b) => a->oaWetBulb <=> b->oaWetBulb)\n\n  // For time series, calculate target in post range\n  if (timeSeries) do\n    gridPost= gridPost\n    .addCol(\"bin\", r => round(r->oaWetBulb))\n    .addCol(\"target\", row => do\n      targetBin: binned.find(r => r->oaWetBulb==row->bin, false)\n      if (targetBin==null) return na() else return targetBin->percentile95\n    end)\n    .removeCol(\"bin\")\n    \n    // Format chart\n    graph: gridPost\n           .addMeta({title: \"Cooling Plant, Recent Total System Power Time Series\"})\n           .toolHisGridShowGaps(15min, \"point or not point\")\n  end else do\n    // Concatenate both history grids and remove timestamps\n    allGrid: addRows(gridPre, gridPost).removeCol(\"ts\")\n    .addRows(binned)\n    colNames: allGrid.colNames\n    allGrid= allGrid.reorderCols(colNames.moveTo(\"oaWetBulb\", 0)) \n    \n    // Format chart\n    graph: allGrid\n           .addMeta({title: \"Cooling Plant, Recent and Baseline Total System Power Scatter\"})\n           .addColMeta(\"oaWetBulb\", {chartMin: 40°F, chartMax: 70°F})\n  end\n         \n  if (graph.has(\"totSysPowerPre\"))\n    graph= graph\n    .addColMeta(\"totSysPowerPre\", \n                {dis: \" Total Power, Baseline \"+dateRangePre,\n                 color: \"#7ED7DE\",\n                 chartType: if (timeSeries) \"line\" else \"scatter\",\n                 chartGroup: \"all\"})\n                 \n  if (graph.has(\"totSysPowerPost\"))\n    graph= graph\n    .addColMeta(\"totSysPowerPost\", \n               {dis: \" Total Power, Recent \"+dateRangePost,\n                color: \"#DE3E30\",\n                chartType: if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n  if (graph.has(\"avg\"))\n    graph= graph\n    .addColMeta(\"avg\", \n               {dis: \"Binned Average Baseline\",\n                color: \"black\",\n                chartType:if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n  if (graph.has(\"percentile95\"))\n    graph= graph\n    .addColMeta(\"percentile95\", \n               {dis: \"Binned 95th Percentile Baseline\",\n                color: \"black\",\n                chartType: if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n  if (graph.has(\"target\"))\n    graph= graph\n    .addColMeta(\"target\", \n               {dis: \"Target, Based on Binned 95th Percentile Baseline\",\n                color: \"black\",\n                chartType: if (timeSeries) \"line\" else \"scatter\",\n                chartGroup: \"all\"})\n                \n   return graph\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"boilerMalfunction",,,"(hotWaterPlant, dates) => do\n\np46: \"GP46-STS\"\np47: \"GP47-STS\"\n\n  //finds boiler status point\n  b1Status: read(point and run and pump and navName==p46).hisRead(dates).hisFindPeriods(v=>v)\n  \n  //finds boiler status point\n  b2Status: read(point and run and pump and navName==p47).hisRead(dates).hisFindPeriods(v=>v)\n  \n  boilerOn: hisPeriodUnion([b2Status, b1Status])\n  \n  //finds return temp point\n  rTemp: read(point and temp and entering and equipRef==hotWaterPlant->id).hisRead(dates)\n  \n  //finds supply temp point\n  sTemp: read(point and temp and leaving and not sp and equipRef==hotWaterPlant->id).hisRead(dates)\n\n  //joins supply and return\n  joined: hisJoin([rTemp, sTemp]).hisInterpolate()\n  \n  //finds difference in supply and return\n  mapped: joined.map row => do\n            {\n            ts: row->ts,\n            v0: abs(row.get(\"v0\") - row.get(\"v1\"))\n            }\n          end\n  \n  //finds periods where difference is less than 5 degrees\n  spark1: mapped.hisFindPeriods(x => x <10)//.hisFindPeriods(y => y > 10min)\n  \n  //finds periods when boiler status is on\n  spark2: boilerOn.hisFindPeriods(y => y > 15min)\n  \n  //sparks when both parameters are met\n  sparkFinal: hisPeriodIntersection([spark1, spark2])\n\nend\n",,
,["toolFormatTrends"],,,,M,,,,,,"viB34CHWTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236278c5-3e59eb7a,\n             @p:lbnl:r:23639805-71ea9dfa,\n             @p:lbnl:r:23639805-f3150841,\n             @p:lbnl:r:232a2a24-b48db0c7,\n             @p:lbnl:r:232a2a24-ac1beec0,\n             @p:lbnl:r:232a2a24-cd20f5b3,\n             @p:lbnl:r:2351251a-75b66653,\n             @p:lbnl:r:2351265a-889cf480,\n             @p:lbnl:r:235126e0-5461ac88,\n             @p:lbnl:r:2319e133-9726cf03,\n             @p:lbnl:r:2319e133-2e692fa9,\n             @p:lbnl:r:232a2a24-587c8cb3])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ahuFilterDPtoStatus",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec, dates, opts, yield) => do\n  threshold:rec->filterDiffPressureThreshold\n\n  read(filter and delta and pressure and sensor and equipRef==rec->equipRef)\n    .hisRead(dates, opts)\n    .each(row => yield(row->ts, (row->v0)>=threshold))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,M
,["bacnetLearnCached","toolRecursiveSearch","bacnetObjConvert"],,,,M,,,,,,"bacnetAutoComplete_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site, location or equip, review all existing points under that\n  site / location / equip, and take the following actions for each point:\n  - If bacnetConnRef or connRef are missing, skip point\n  - If bacnetCur is valid:\n  --- Load corresponding BACnet info from connector\n  ------ If bacnetCurName is missing or bacnetCurNameOverride is true, fill out\n         point's bacnetCurName tag using BACnet OBJECT_NAME\n  ------ If unit is missing or unitOverride is true, fill out\n         point's unit tag using BACnet UNITS and io/config/bacnet_units.csv\n  ------ If bacnetDesc is missing or bacnetDescOverride is true, fill out\n         point's bacnetDesc using BACnet DESCRIPTION\n  - If bacnetHis is missing or bacnetHisOverride is true, search trend log\n   objects on same connector for a match in LOG_DEVICE_OBJECT_PROPERTY\n   ->value->objId and fill out point's bacnetHis accordingly\n  - If bacnetHis is valid:\n  --- Load corresponding BACnet info from connector\n  ------ If bacnetHisName is missing or bacnetHisNameOverride is true, fill out\n         point's bacnetHisName tag using BACnet OBJECT_NAME\n  \n  Only commit changes is finalize is true, otherwise just return table showing\n  existing and proposed values.\n  \n  Could add additional actions, e.g. fill out tags based on navName, etc.\n  \n  Arguments: \n  startRef        Ref or site / location / equip whose points to autocomplete\n  finalize        Bool, if true, commit changes\n  unitOverride\n  bacnetCurNameOverride\n  bacnetDescOverride\n  bacnetHisOverride\n  bacnetHisNameOverride\n*/\n\n(startRef: null, finalize:false, unitOverride:false, bacnetCurNameOverride:true,\n bacnetDescOverride:true, bacnetHisOverride:true, bacnetHisNameOverride:true\n) => do\n  // Load dependencies\n  try bacnetUnits: ioReadCsv(`io/config/bacnet_units.csv`)\n  catch\n    return {error: \"io/config/bacnet_units.csv could not be loaded\"}.toGrid()\n\n  try curNameTohisName: ioReadCsv(`io/config/curName_hisName.csv`)\n                        .colToList(\"regex\")\n  catch\n    return {error: \"io/config/curName_hisName.csv could not be loaded\"}.toGrid()\n\n  // Load points list\n  try\n    start: readById(startRef)\n  catch\n    return {error: \"startRef not valid\"}.toGrid()\n    \n  if (start.has(\"site\"))\n    points: readAll(point and not virtual and siteRef==startRef)\n  else if (start.has(\"location\"))\n    points: readAll(point and not virtual and locationRef==startRef)\n  else if (start.has(\"equip\"))\n    points: toolRecursiveSearch(startRef, \"point and not virtual\")\n  else return {error: \"startRef not valid\"}.toGrid()\n  \n  if (isEmpty(points)) return {error: \"No points found\"}.toGrid()\n  \n  // Search and record all trend objects from listed connectors\n  connectors: points.colToList(\"bacnetConnRef\").unique()\n                    .sort((a,b) => a->id <=> b->id)\n  \n  bacnetTrends: connectors\n      .map(co =>\n          {bacnetConnRef:co,\n           // For each trend log, map LOG_DEVICE_OBJECT_PROPERTY\n           objects: bacnetLearnCached(co, 20)\n                    .map(tl => do\n                        bacnetCurRow: bacnetLearnCached(co,\"all\")\n                                   .find(row => row[\"bacnetHis\"]==tl[\"bacnetHis\"]\n                                                and row.has(\"bacnetCur\"))\n                        if (bacnetCurRow==null) return tl\n                        bacnetCur: bacnetCurRow[\"bacnetCur\"]\n                        if (bacnetCur==null) return tl\n                        return tl.set(\"bacnetCur\", bacnetCur\n                                                   .bacnetObjConvert())\n                    end)\n          }) \n  \n  // Cycle through points and create summary table with pre / post info\n  points= points\n    .keepCols([\"id\",\"bacnetConnRef\",\"bacnetCur\",\"bacnetCurName\",\n                   \"bacnetHis\",\"bacnetHisName\",\"bacnetDesc\",\"connRef\",\n                   \"unit\"])\n    .map(pt => do\n    // Initialize change dictionary\n    changes: {}\n    \n    // If bacnetConnRef or connRef are missing, skip point\n    if (pt[\"bacnetConnRef\"]==null or pt[\"connRef\"]==null)\n      return pt\n    \n    // If bacnetCur is valid, research related BACnet info\n    bacnetCurObject: bacnetLearnCached(pt[\"bacnetConnRef\"],\"all\")\n                     .find(row => row.has(\"bacnetCur\")\n                                  and row[\"bacnetCur\"]==pt[\"bacnetCur\"])\n    if (bacnetCurObject!=null) do\n      // bacnetCurName is missing or bacnetCurNameOverride is true\n      if (bacnetCurNameOverride or pt[\"bacnetCurName\"]==null\n                                or pt[\"bacnetCurName\"]==\"\") do\n        // Retrieve BACnet OBJECT_NAME\n        objName: bacnetCurObject[\"dis\"]\n        if (objName != null) do\n          pt= pt.set(\"bacnetCurName_New\",\n                     if (objName==pt[\"bacnetCurName\"]) \"No Change\"\n                     else objName)\n          changes= changes.set(\"bacnetCurName\", objName)\n        end\n      end\n      \n      // bacnetDesc is missing or bacnetDescOverride is true\n      if (bacnetDescOverride or pt[\"bacnetDesc\"]==null\n                                or pt[\"bacnetDesc\"]==\"\") do\n        // Retrieve BACnet DESCRIPTION\n        objDesc: bacnetCurObject[\"bacnetDesc\"]\n        if (objDesc != null) do\n          pt= pt.set(\"bacnetDesc_New\",\n                     if (objDesc==pt[\"bacnetDesc\"]) \"No Change\"\n                     else objDesc)\n          changes= changes.set(\"bacnetDesc\", objDesc)\n        end\n      end\n      \n      // unit is missing or unitOverride is true\n      if (readById(pt->id)[\"kind\"]==\"Number\"\n          and (unitOverride or pt[\"unit\"]==null or pt[\"unit\"]==\"\")) do\n        // Retrieve BACnet UNITS\n        objUnit: bacnetCurObject[\"unit\"]\n        if (objUnit != null) do\n          // Match with record of BACnet units\n          unit: objUnit\n          pt= pt.set(\"unit_New\",\n                     if (unit==pt[\"unit\"]) \"No Change\"\n                     else unit)\n          changes= changes.set(\"unit\", unit)\n        end\n      end\n    end // If bacnetCur is valid\n      \n    // bacnetHis is missing or bacnetHisOverride is true,\n    // bacnetCur or bacnetCurName can be used for matching\n    if ((pt[\"bacnetCur\"]!=null or pt[\"bacnetCurName\"]!=null)\n        and (bacnetHisOverride or pt[\"bacnetHis\"]==null\n             or pt[\"bacnetHis\"]==\"\")) do\n      // Attempt to match a trend object to available bacnetCur\n      // Load table of trends associated with point's connector\n      trends: bacnetTrends\n              .find(row => row[\"bacnetConnRef\"]==pt[\"bacnetConnRef\"])\n      if (trends==null) trends= {}.toGrid else trends= trends[\"objects\"]\n      \n      // Attempt match on bacnetCur or bacnetCurName\n      trendMatches: trends.findAll(row => do\n        if ((row[\"bacnetCur\"] != null) and (row[\"bacnetCur\"]==pt[\"bacnetCur\"]))\n          return true\n        regexMatch: false\n        // bacnetCurName matches use a config file where regular expressions\n        // are defined to run on \"bacnetCurName:bacnetHisName\"\n        curNameTohisName.each(regex =>\n            if (regex.reMatches(pt[\"bacnetCurName\"]+\":\"+row[\"dis\"]))\n              regexMatch= true\n        )\n        return regexMatch\n      end)\n      \n      // Pick first matched trend object\n      if (not(isEmpty(trendMatches))) trend: trendMatches.first[\"bacnetHis\"]\n      else trend: null\n      pt= pt.set(\"bacnetHis_New\",\n                 if (trend==pt[\"bacnetHis\"]) \"No Change\"\n                 else trend)\n      changes= changes.set(\"bacnetHis\", trend)\n      \n      // Display list of additional matches\n      if (size(trendMatches) > 1)\n        pt= pt.set(\"bacnetHis_Others\",\n                   trendMatches.colToList(\"bacnetHis\")[1..-1].concat(\", \"))\n      \n    end // bacnetHis from bacnetCur or bacnetCurName\n    \n    // If bacnetHis_New or bacnetHis is valid, research related BACnet info\n    bacnetHis: if (changes[\"bacnetHis\"] != null\n                   and changes[\"bacnetHis\"] != \"No Change\")\n                 changes[\"bacnetHis\"]\n               else pt[\"bacnetHis\"]\n    bacnetHisObject: bacnetLearnCached(pt[\"bacnetConnRef\"],20)\n                     .find(row => row.has(\"bacnetHis\")\n                                  and row[\"bacnetHis\"]==bacnetHis)\n    if (bacnetHisObject != null) do\n      // bacnetHisName is missing or bacnetHisNameOverride is true\n      if (bacnetHisNameOverride or pt[\"bacnetHisName\"]==null\n                                or pt[\"bacnetHisName\"]==\"\") do\n        // Retrieve BACnet OBJECT_NAME\n        hisObjName: bacnetHisObject[\"dis\"]\n        if (hisObjName != null) do\n          pt= pt.set(\"bacnetHisName_New\",\n                     if (hisObjName==pt[\"bacnetHisName\"]) \"No Change\"\n                     else hisObjName)\n          changes= changes.set(\"bacnetHisName\", hisObjName)\n        end\n      end\n    end\n    \n    changes= diff(readById(pt->id), changes)\n    pt= pt.set(\"changes\", changes)\n    return pt\n  end)\n  \n  if (finalize)\n    points.each pt => if (pt[\"changes\"] != null) commit(pt->changes)\n  \n  return points.reorderCols(points.colNames.sort((a,b) => a <=> b)\n                                           .moveTo(\"id\", 0)\n                                           .moveTo(\"changes\", -1))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["scrapeConvertStrToNum"],,,,M,,,,,,"backfillJace",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function parses a csv downloaded from BuildingOS and writes\n its data to a point.\n \n ***Before running this script, a csv whose name must be the same\n    as the navName of the point must be uploaded to Folio. (Ex.\n    navName==\"33 Gas\" and 33 Gas.csv)\n\n Arguments:\n navName     navName (string) is the navName of the point you\n             want to backfill. As stated above, it must match\n             the csv name. *** no longer an input ***\n pt          pt (rec) is the point you are backfilling data for.\n csv         csv (string) is the name of the csv. It must be\n             uploaded in folio.\n col         col (number) is the number column of the csv from\n             which you are getting data. The first column of\n             the csv is column 0, and it has ts. If looked at in\n             an Excel spreadsheet, it would be column A. Therefore,\n             col must be an integer greater than 0.\n unitCSV     unitCSV (string) is the unit of the csv data.\n             The csv and point don't have to have the same unit\n             (the function will take care of it).\n                          \n \n // Sustainable Berkeley Lab // AMP // Last Update: 2019-12-16 //\n*/\n\n\n(csv, pt, col, unitCSV:null) => do\n  if(unitCSV!=null) unitCSV= pt[\"unit\"] // assume unit is same as point unless something is typed into the function input\n  csvGrid: ioReadLines(read(dis==csv))\n  \n  // Gather metadata from the first few rows, but only need to do\n  // this if the tag does not already exist\n  if (pt[\"facility\"]==null or pt[\"meterName\"]==null or pt[\"pointName\"]==null) do\n    row0: csvGrid[0].split(\",\")\n    facility: row0[col]         // The first (zeroth) row gives the Facility\n    row1: csvGrid[1].split(\",\")\n    meterName: row1[col]\n    row2: csvGrid[2].split(\",\")\n    meterId: row2[col]\n    row4: csvGrid[4].split(\",\")\n    pointName: row4[col]\n    \n    dict: {}\n    tagName1: \"facility\"\n    tagVal1: facility\n    tagName2: \"meterName\"\n    tagVal2: meterName\n    tagName3: \"pointName\"\n    tagVal3: pointName\n    dict= dict.set(tagName1, tagVal1)\n    dict= dict.set(tagName2, tagVal2)\n    dict= dict.set(tagName3, tagVal3)\n    commit(diff(pt, dict))\n  end\n  \n  csvGrid= csvGrid[5..-1] // data begins in row 5\n  \n  // Process each row iteratively\n  dataGrid: csvGrid.map row => do\n    data: split(row, \",\")\n    dateTimeString: data[0]\n    valueString: data[col]\n    \n    // Convert dateTimeString to date and timeString to dateTime\n    dateTime: parseDateTime(dateTimeString,\"YYYY-MM-DD hh:mm\",\"Los_Angeles\")//\"UTC\")\n    dateTime= dateTime.toTimeZone(pt[\"tz\"])\n    \n    if (dateTime<pt[\"hisStart\"] or pt[\"hisStart\"]==null) do // Only do this work on points before hisStart\n      // Convert valueString to value. Then add unit.\n      value: scrapeConvertStrToNum(valueString)\n      value= value.as(unitCSV)\n      //value= value.to(unitCSV)\n    end else do\n      value: null\n    end\n    \n    {ts: dateTime, val: value}\n  end\n  dataGrid= dataGrid.toGrid\n  \n  // Filter redundant data. Get or assign hisEnd, then find\n  // all rows where new data is greater than that hisEnd.\n  backfillEnd: dataGrid[-1][\"ts\"] // this is currently unused\n  \n  if (pt[\"hisStart\"]!=null) filteredGrid: dataGrid.findAll row => row->ts < pt[\"hisStart\"]\n  if (pt[\"hisStart\"]==null) filteredGrid: dataGrid\n  filteredGrid= filteredGrid.findAll row => row[\"val\"] != null\n  filteredGrid= filteredGrid.findAll row => row[\"val\"] != na()\n  \n  // Write filteredGrid to point.\n  hisWrite(filteredGrid,pt)\n  return {written: filteredGrid.size, status: \"OK\"}\n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anRegElecCddApply_v1","anRegElecCddCalculate_v1"],,,,M,,,,,,"anRegElecCddAvoided_v1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate avoided energy usage over a given post-install period,\n  and calculate corresponding statistics.\n  Return dictionary with:\n    avoidedUsageResults:  dict of avoided energy usage statistics\n    postResults:          dict of post-install model coefficients\n                            and fit statistics\n    graph:                chart grid for measured & adjusted usage\n    dataset:              grid of post dataset, plus adjusted usage\n  \n  Arguments: \n  meterUsageRef      Ref of elec meter usage data point\n  dateSpanBase       Span of baseline dates to create model from\n  dateSpanPost       Span of post-install dates to calculate avoided usage on\n  ddRefTemp          Reference temp for calculation of degree days\n\n  Notes:\n  Uncertainty currently does not account for autocorrelation and\n  will therefore be underestimated if autocorrelation is significant\n*/\n\n(meterUsageRef, dateSpanBase, dateSpanPost, ddRefTemp,\n titlePrefix:\"POST: \") => do\n  // Associate functions\n  calcModel: anRegElecCddCalculate_v1\n  applyModel: anRegElecCddApply_v1\n\n  // Perform base and post regressions\n  baseModel: calcModel(meterUsageRef, dateSpanBase, ddRefTemp, \"BASE: \")\n  postModel: calcModel(meterUsageRef, dateSpanPost, ddRefTemp, titlePrefix)\n  \n  // Calculate adjusted baseline\n  adjustedBase: applyModel(meterUsageRef, dateSpanPost, baseModel->results)\n                  .renameCol(\"fittedUsage\", \"adjustedBaseUsage\")\n  \n  // Prepare post dataset including adjusted base\n  postDataset: hisJoin([postModel->dataset, adjustedBase])\n                 // Filter out dates with missing data\n                .findAll(row => row.has(\"usage\"))\n                // Add avoided energy usage\n                .addCol(\"avoidedUsage\",\n                        row => row->adjustedBaseUsage - row->usage)\n                        \n  //Calculate statistics\n  avoidedUsage: postDataset.foldCol(\"avoidedUsage\", sum)\n  adjustedTotal: postDataset.foldCol(\"adjustedBaseUsage\", sum)\n  f: avoidedUsage / adjustedTotal\n  m: postModel->results[\"n\"]\n  n: baseModel->results[\"n\"]\n  baseMse: baseModel->results[\"mse\"]\n  baseAvg: baseModel->results[\"measuredAvg\"]\n  avoidedUncertainty68: 1.26 * 1 / (m * baseAvg * f)\n                             * sqrt(baseMse * (1 + 2 / n) * m)\n                             \n  // Compile results\n  avoidedUsageResults: {\n    avoidedUsage: avoidedUsage,\n    avoidedUsageRelative: (f*100).as(1%),\n    adjustedTotal: adjustedTotal,\n    uncertainty68: (avoidedUncertainty68*100).as(1%)\n  }\n  \n  // Modify post graph to add adjusted baseline\n  baseIntercept: baseModel->results[\"intercept\"]\n  baseSlopeWeekday: baseModel->results[\"slopeWeekday\"]\n  baseSlopeWeekend: baseModel->results[\"slopeWeekend\"]\n  postGraph: postModel->graph\n    .addCol(\"adjustedBaseWeekday\", row => if(row.has(\"cool\"))\n      (baseIntercept + baseSlopeWeekday*row->cool).as(1kWh)\n      else null)\n    .addCol(\"adjustedBaseWeekend\", row => if(row.has(\"cool\"))\n      (baseIntercept + baseSlopeWeekend*row->cool).as(1kWh)\n      else null)\n    // Add meta data to control graph display\n    .addColMeta(\"adjustedBaseWeekday\", {chartType:\"scatter\", chartGroup:\"main\",\n                                        color:\"#F18E1D\", chartMin: 0.as(1kWh)})\n    .addColMeta(\"adjustedBaseWeekend\", {chartType:\"scatter\", chartGroup:\"main\",\n                                        color:\"#B56B16\", chartMin: 0.as(1kWh)})\n    // Rename post regression columns and reorder for clarity\n    .renameCol(\"regressionWeekday\", \"postRegressionWeekday\")\n    .renameCol(\"regressionWeekend\", \"postRegressionWeekend\")\n    .reorderCols([\"cool\",\"adjustedBaseWeekend\",\"adjustedBaseWeekday\",\n                  \"postRegressionWeekend\",\"postRegressionWeekday\",\n                  \"usageWeekend\",\"usageWeekday\"])\n  \n  return {avoidedUsageResults: avoidedUsageResults,\n          postResults:postModel->results,\n          graph:postGraph,\n          dataset:postDataset}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Airflow Setpoint Not Met",,M,"Airflow deviates from setpoint by a given relative tolerance (default 10%) and a given absolute tolerance (default 50 cfm) for longer than a given time period (default 1h)",,,,,"ruAirflowSpNotMet",,"terminalUnit","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of periods an equip with an air flow sensor\n and an air flow sp does not meet its setpoint.\n \n Arguments:\n equip           equip record of equip to test airflow on\n span            dateSpan, span of dates to run analysis on\n tolerance       number, between 0 and 1 (0% and 100%). Airflow is not met if\n                 it is more than +/-toleance% different from setpoint\n andAbsTolerance number, absolute tolerance in cfm. Both tolerances need\n                 to be exceeded for an issue to be flagged\n minTime         duration, filter out periods shorter than minTime\n mergePeriod     duration, merge flagged periods separated by less than\n                 mergePeriod\n*/\n\n(equip:readById(@p:lbnl:r:2324cceb-e30a4c1a), span:pastWeek(),\n tolerance:0.1, andAbsTolerance:50cfm,\n minTime: 1h, mergePeriod: 15min) => do\n  // Check inputs, prepare filters\n  if (tolerance > 1) tolerance= 1\n  if (tolerance <0) tolerance= 0\n  tolerance= tolerance.as(1) // Remove unit if any\n  \n  // If equip does not have both an air flow sensor and an air flow effective sp,\n  // return null\n  sen: read(point and air and flow and sensor and equipRef==equip->id, false)\n  sp: read(point and air and flow and effective and sp and equipRef==equip->id, false)\n  if (sen == null or sp == null)\n    return null\n  \n  // Read history for both sensor and sp, calculate difference\n  data: [sp, sen].hisRead(span, {limit: null}).hisInterpolate().hisClip()\n                 // Remove null and na() values\n                 .findAll(row => row[\"v0\"] != null and row[\"v1\"] != null\n                                 and  row[\"v0\"] != na() and row[\"v1\"] != na())\n\n  // Reference setpoint is max sp during period, in order to reflect how\n  // large the box is, particularly important for periods of sp==0cfm\n  refSp: data.foldCol(\"v0\", max)\n\n  diff: data.addCol(\"diff\", row => \n          ((if (abs(row->v0 - row->v1) > andAbsTolerance)\n              abs(row->v0 - row->v1)\n            else\n              0\n           ) / refSp\n          ).as(1))\n        .keepCols([\"ts\",\"diff\"])\n        \n  // Find periods airflow setpoint is not met\n  flagPeriods: diff.hisFindPeriods(diff => diff > tolerance)\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->diff >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: sp->navName + \" is not met\"\n  return flagPeriods.addColMeta(\"diff\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-02   Changed denominator in %diff from row->v1 (airflow read from sensor)\n               to refSp. Added refSp reference airflow setpoint based on max sp during\n               period, to properly reflect how large the TU is.\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptRateToDelta"],,,,M,,,,,,"intgCreateMeterDeltas",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Review all load meters. For meters that don't have an energy delta sensor,\n  if the meter has a power sensor, create a virtual energy delta sensor.\n*/\n\n() => do\n  // Grid of meters for which an energy delta sensor point will be added\n  metersGrid: readAll(meter and load and equip)\n  .findAll(meterRow =>\n    read(energy and delta and sensor and equipRef==meterRow->id, false)==null)\n  .findAll(meterRow =>\n    read(power and sensor and equipRef==meterRow->id, false)!=null)\n    \n  // For each meter in grid, create new virtual delta sensor point\n  metersGrid.each(meter => do\n    powerSensor: read(power and sensor and equipRef==meter->id and hisFunc, false)\n    if (powerSensor==null)\n      powerSensor= read(power and sensor and equipRef==meter->id)\n    newPtDict: {\n      navName: \"Energy\",\n      disMacro: \"\\\$equipRef \\\$navName (\\\$unit)\",\n      chartGroup: \"delta\",\n      chartType: \"scatter\",\n      delta,\n      energy,\n      equipRef: meter->id,\n      his,\n      hisFunc: \"ptRateToDelta\",\n      kind: \"Number\",\n      locationRef: meter->locationRef,\n      point,\n      pointRef: powerSensor->id,\n      sensor,\n      siteRef: meter->siteRef,\n      tmp: today(),\n      tz: \"Los_Angeles\",\n      unit: \"BTU\",\n      virtual\n    }\n    commit(diff(null, newPtDict, {add}))\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDailyProfiles",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays daily averages for the given point over two given periods,\n  on the same graph. Averages either weekdays or weekends. For use\n  in Meter Analysis app to display daily meter power profiles.\n\n  Arguments: \n  ptRef\n  span1\n  span2\n  weekday\n  interval\n*/\n\n(ptRef, span1, span2, weekday: true, interval: 15min) => do\n  ptHis1: ptRef.hisRead(span1, {limit: null})\n  ptHis2: ptRef.hisRead(span2, {limit: null})\n  unitRef: unit(ptHis1.first->v0)\n  \n  if (weekday) do\n    ptHisFiltered1: ptHis1.findAll(row => isWeekday(row->ts))\n    ptHisFiltered2: ptHis2.findAll(row => isWeekday(row->ts))\n  end else do\n    ptHisFiltered1: ptHis1.findAll(row => isWeekend(row->ts))\n    ptHisFiltered2: ptHis2.findAll(row => isWeekend(row->ts))\n  end\n  \n  ptHisProfile1: ptHisFiltered1.hisRollup(avg, interval).hisDailyProfile(avg)\n  ptHisProfile2: ptHisFiltered2.hisRollup(avg, interval).hisDailyProfile(avg)\n  \n  ptHisProfile1= ptHisProfile1.renameCol(\"v0\",\"v1\")\n  ptHisProfile2= ptHisProfile2.renameCol(\"v0\",\"v2\")\n\n  ptsProfiles: join(ptHisProfile1, ptHisProfile2, \"time\")\n  \n  maxChart: max(ptHis1.foldCol(\"v0\",max), ptHis2.foldCol(\"v0\",max))\n  \n  dayType: if (weekday) \"Weekday\" else \"Weekend\"\n  ptName: ptRef->siteRef->dis + \" \" + ptRef->equipRef->navName + \" \" +\n                                           ptRef->navName + \" (\"+ptRef->unit+\")\"\n  ptsProfiles= ptsProfiles.addMeta({title: dayType+\" Profiles, \"+readById(ptRef->equipRef).dis()})\n  ptsProfiles= ptsProfiles.addColMeta(\"v1\", {chartMin: 0.as(unitRef),\n                                             chartMax: maxChart,\n                                             dis: span1 + \" Avg \" + ptName})\n  ptsProfiles= ptsProfiles.addColMeta(\"v2\", {chartMin: 0.as(unitRef),\n                                             chartMax: maxChart,\n                                             dis: span2 + \" Avg \" + ptName})\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"meterFormulaLinks",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meter formula, return list of meter links\n  used in formula\n  \n  Arguments: \n  formula        Dict, virtual meter formula\n*/\n\n(formula) => do\n  list: []\n  \n  // Determine what meter columns contain data\n  meterColNames: (0..8).map(v => \"meter\"+v.toStr)\n  meterColNames.each colName => do\n    if (formula[colName] != \"\")\n      list= list.add(reGroups(r\"-?(\\d*.\\d*)\",formula[colName])[1])\n  end\n  \n  return list\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldHisSample",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, ts, acc) => do\n  if (val == foldStart()) return {v0: na()}\n  if (val == foldEnd()) return acc->v0\n  if (val == na()) return na()\n  if (val == null) return null\n  return {v0: val}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06VAVConn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with location, uri, device, and vav number,\n  and create corresponding bacnet connector\n*/\n\n() => do\n  ioReadCsv(`io/integration_b6/b6_alc_floor_2_vav_bacnet_connectors.csv`)\n  .each row => do\n    loc: row[\"location\"]\n    disText: loc + \" - ZN - VAV-\" + row[\"vav\"] + \" - Device \" + row[\"device\"]\n    uriText: row[\"uri\"]\n    \n    commit(diff(\n      null,\n      {dis: disText,\n       uri: parseUri(uriText),\n       conn,\n       bacnetConn,\n       sadieTemp,\n       siteRef: read(site and dis==\"06\")->id\n      },\n      {add}\n    ))\n  end\n  \n  readAll(conn and bacnetConn and siteRef->dis==\"06\")\n  .each connector => bacnetPing(connector)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anHillGasRemainder","jobMetering","meterMonthlyRead"],,,,M,,,,,,"jobMetering",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Compilation job for metering activities, including logging\n*/\n\n() => do\n  // Import Monthly Meter Reads\n  jobProgress(1%, \"meterMonthlyRead...\")\n  try meterMonthlyRead()\n  catch (ex) log(\"err\", {name:\"jobMetering\"}, \"meterMonthlyRead failed\", ex)\n\n  // Monthly Hill Remainder Calc\n  jobProgress(50%, \"anHillGasRemainder...\")\n  try anHillGasRemainder()\n  catch (ex) log(\"err\", {name:\"jobMetering\"}, \"anHillGasRemainder failed\", ex)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74AlcPath",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  // For all points with bacnetHis at B74, add device / instance\n  grid: readAll(point and connRef and bacnetHis and siteRef->dis==\"74\")\n  .addCol(\"device\", row =>\n    reGroups(\"device(\\\\d*)\",\n             readById(row->connRef)[\"bacnetDeviceName\"])[1])\n  .addCol(\"instance\", row =>\n    reGroups(\".*_(\\\\d+)\\\$\",row[\"bacnetHisName\"])[1])\n  .addCol(\"objName\", row => do\n    name: reGroups(\"(.*?)(_trend_log)?_\\\\d+\\\$\",\n                   row[\"bacnetHisName\"])[1]\n    if (reMatches(\"(air_flow_)?(flow_input.*\\\$)\", name))\n      name= \"air_flow/\" + reGroups(\"(air_flow_)?(flow_input.*\\\$)\", name)[2]\n    if (reMatches(\"(rstat_)?(zone_temp.*\\\$)\", name))\n      name= \"rstat/\" + reGroups(\"(rstat_)?(zone_temp.*\\\$)\", name)[2]\n    return name\n  end)\n \n  // Load file that links device / instance pairs with the\n  // roots of ALC paths\n  rootsGrid: ioReadCsv(`io/integration_b74/alc_server_roots.csv`)\n\n  // Cycle through each point\n  grid= grid.addCol(\"root\", row => do\n    match: rootsGrid.find(entry => (entry->device == row->device) and\n                                   (entry->instance == row->instance), false)\n    return match[\"root\"]\n  end)\n  \n  // Store new alcPath\n  grid.each pt => commit(diff(pt, {alcPath: pt->root + \"/\" + pt->objName}))\n  \n  //return grid.keepCols([\"id\",\"device\",\"instance\",\"root\",\"objName\",\"connRef\",\"bacnetHisName\",\"bacnetCurName\"])\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"testReport",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(reportRec, siteName, dateRangeStr, email) => do\n  \n  returnGrid: createReport(siteName, dateRangeStr, reportRec)\n  \n  filename: returnGrid->fileName\n  \n  emailSend([email], \"Test\", \" \", parseUri(\"io/\"+filename))\n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ruDamperControl"],,,,M,,,,,,"viDamperControl",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns a grid of damper cmd data from\n  terminal units for which the damper is less than x% open\n  more than y% of the time during the given time period; \n  grid is optimized for use as a chart.\n \n  Arguments:\n  siteRef        site to analyze\n  span           dateSpan, span of dates for which to return data\n  pbRange         list of min and max position, defining a range\n                  that the damper cmd shouldn't stay in for too long\n  timeTolerance   number, between 0 and 1 (0% and 100%). Issue is flagged\n                  if total issue time covers at least this percentage of\n                  the total analysis span duration.\n*/\n\n(siteRef: @p:lbnl:r:225ffa71-7758e5e3, span:pastWeek(),\n pbRange: [99%,100%], timeTolerance:0.9) => do\n  // Find all terminal units or zones with damper cmd\n  testedEquips: readAll(siteRef==siteRef and equip and (terminalUnit or zone))\n                .findAll(eq => read(damper and cmd and point\n                                    and equipRef==eq->id, false) != null)\n  \n  // Find equips with damper always closed\n  pbEquips: testedEquips.findAll(eq => do\n      flagPeriods: ruDamperControl(eq, span, pbRange, timeTolerance)\n      \n      // Filter out equips with no issue\n      if (flagPeriods == null) return false\n      else return true\n  end)  \n  \n  if (isEmpty(pbEquips))\n      return {success: \"None of the \"\n                       + testedEquips.foldCol(\"id\", count)\n                       + \" tested dampers are too often in range \"\n                       + pbRange[0] + \" - \" + pbRange[1]\n             }.toGrid\n\n  // Show desired trends from the equips with detected issues\n  hisPts: readAll(point and damper and cmd and siteRef==siteRef)\n    .findAll(pt => pbEquips.colToList(\"id\").contains(pt->equipRef))\n    .sort((a,b) => a.dis() <=> b.dis)\n\n  vi: hisPts.hisRead(span, {limit: null})\n  \n  // Chart group by floor\n  vi.colNames()[1..-1].each colName => do\n    vi= vi.addColMeta(colName,\n      {chartGroup: readById(vi.col(colName).meta->locationRef->id)\n                   .dis()\n      })\n  end\n  \n  vi= vi.addMeta({title: \"B\" + siteRef->dis\n                      + \" dampers that are commanded in range \"\n                      + pbRange[0] + \" - \" + pbRange[1]\n                      + \", more than \" + timeTolerance*100\n                      + \"% of the time (\" + testedEquips.foldCol(\"id\", count)\n                      + \" dampers tested at site)\"\n                 })\n  \n  return(vi)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptPowerIntegrator",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function takes in power data at seemingly random intervals,\n  and integrates it into an energy usage trend, weighing the data points\n  based on the gap before and after the point.\n\n  Arguments:\n  powerPtId         Id of source point with power data\n  span              Datespan to calculate energy data over\n  maxGap            Number (time), maximum length of data gap above which na() is returned\n*/\n\n(powerPtId:@p:lbnl:r:23d4fc7f-6db76065, span:2019-03-01,\n maxGap: 5min) => do\n  power: readById(powerPtId)\n         .hisRead(span, {limit:null})\n\n  tm: null\n  t0: null\n  t1: null\n  vm: null\n  v0: null\n  v1: null\n  \n  energy: power\n    .findAll(row => row.has(\"ts\") and row.has(\"v0\"))\n    .map(row => do\n      tm= t0\n      vm= v0\n      t0= t1\n      v0= v1\n      t1= row->ts\n      v1= row->v0\n      \n      if (([tm, t0, t1].any(v => v==null))\n          or ([vm, v0, v1].any(v => v==null)))\n        return null\n      else do\n        deltaT: ((t1 - tm)/2).to(\"hr\")\n        return {ts: t0,\n                v0: if (((t1 - t0) > maxGap) or ((t0 - tm) > maxGap)) na()\n                    else v0 * deltaT}\n      end\n    end)\n    \n  return energy\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ruAirflowSpNotMet"],,,,M,,,,,,"viAirflowSpNotMet",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns a grid ready for display as a graph and containing\n  relevant data from terminal units that did not meet their airflow setpoints\n  during the analyzed time period. Makes use of ruAirflowSpNotMet.\n \n  Arguments:\n  siteRef         site to test terminal unit airflows on\n  span            dateSpan, span of dates for which to return data\n  tolerance       number, between 0 and 1 (0% and 100%). Airflow is not met\n                  if it is more than +/-toleance% different from setpoint\n  andAbsTolerance number, absolute tolerance in cfm. Both tolerances need\n                  to be exceeded for an issue to be flagged\n  timeTolerance   number, between 0 and 1 (0% and 100%). Issue is flagged\n                  if total issue time covers at least this percentage of\n                  the total analysis span duration.\n*/\n\n(siteRef:@p:lbnl:r:225ffa71-7758e5e3, span:yesterday(),\n tolerance:0.1, andAbsTolerance:50cfm, timeTolerance: 0.1) => do\n  // Parameters\n  minTime: 30min\n  mergePeriod: 15min\n \n  // Check inputs, prepare filters\n  if (timeTolerance > 1) timeTolerance= 1\n  if (timeTolerance <0) timeTolerance= 0\n  timeTolerance= timeTolerance.as(1) // Remove unit if any\n  if (tolerance > 1) tolerance= 1\n  if (tolerance <0) tolerance= 0\n  tolerance= tolerance.as(1) // Remove unit if any\n  span= span.toDateSpan\n  timeThreshold: (span.end - span.start + 1day) * timeTolerance\n\n  // Find all terminal units that have both an air flow sensor and a sp\n  testedEquips: readAll(siteRef==siteRef and equip and terminalUnit)\n      .findAll(eq => read(air and flow and sensor and point\n                          and equipRef==eq->id, false) != null and\n                     read(air and flow and effective and sp and point\n                          and equipRef==eq->id, false) != null)\n\n  // Find equips with airflow issues\n  pbEquips: testedEquips.findAll(eq => do\n      flagPeriods: ruAirflowSpNotMet(eq, span, tolerance, andAbsTolerance,\n                                     minTime, mergePeriod)\n      \n      // Filter out equips with no issue\n      if (flagPeriods == null) return false\n                                     \n      // Check if total of flagged periods exceeds timeThreshold\n      if (flagPeriods.foldCol(\"diff\",sum) > timeThreshold)\n          return true\n      else\n          return false\n  end)\n  \n  if (isEmpty(pbEquips)) return {success: \"No airflow issue\"}.toGrid\n\n  // Show desired trends from the equips with detected issues\n  hisPts: readAll(point and air and flow and ((effective and sp) or sensor)\n                  and siteRef==siteRef)\n    .findAll(pt => pbEquips.colToList(\"id\").contains(pt->equipRef))\n    .sort((a,b) => a.dis() <=> b.dis)\n\n  vi: hisPts.hisRead(span, {limit: null})\n\n  // Chart group by equip\n  vi.colNames()[1..-1].each colName => do\n      vi= vi.addColMeta(colName,\n          {chartGroup: readById(vi.col(colName).meta->equipRef->id).dis()})\n  end\n  \n  vi= vi.reorderCols(\n          vi.colNames\n            .sort((a,b) => vi.col(a).meta().dis() <=> vi.col(b).meta().dis)\n            .findAll(i => i != \"ts\")\n            .insert(0, \"ts\"))\n  \n  vi= vi.addMeta({title: \"B\" + readById(siteRef)->dis\n                             + \"Airflows that deviate from setpoint by \"\n                             + tolerance*100 + \"% or more AND by \"\n                             + andAbsTolerance + \" or more, \"\n                             + timeTolerance*100 + \"% of the time (\"\n                             + testedEquips.foldCol(\"id\",count)\n                             + \" pairs tested)\"\n                 })\n  \n  return(vi)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,,,,,M,,,,,,"toolFunctionUsage",,,"(funcName) => do\n  readAll(func or view or rule or job)\n  .findAll(r => (r.has(\"src\") and r->src.contains(funcName)) or\n                (r.has(\"ruleFunc\") and r->ruleFunc.contains(funcName)) or\n                (r.has(\"job\") and r->job.contains(funcName)))\nend\n",,
,["recValidateTagSet"],,,,M,,,,,,"recNewTagSet",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(tagSetDict) => do\n  // Normalize action input\n  rec: actionNormInput(tagSetDict, \"dict\")\n  \n  // Remove spaces from tag strings\n  if (rec.has(\"ptTags\")) rec= rec.set(\"ptTags\", rec->ptTags.replace(\" \",\"\"))\n  if (rec.has(\"eqTags\")) rec= rec.set(\"eqTags\", rec->eqTags.replace(\" \",\"\"))\n  \n  // Validate record\n  tagSetDict= recValidateTagSet(rec)\n\n  recNew(rec)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"chillerFail",,,"(chiller, dates) => do\n\n//Find when any alarm point = true \nspark: readAll(point and alarm and hisSize and equipRef==chiller->id).hisRead(dates).hisFindPeriods(x => x)\n\nend\n",,
,[],,,,M,,,,,,"recValidateDeficiencyGroupNote",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  if (not(rec.has(\"deficiencyGroupRef\")) or rec[\"deficiencyGroupRef\"]==\"\")\n    throw \"Reference to associated deficiency group is required\"\n    \n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"viTagSets",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a table of tagSets formatted for display.\n  \n  Arguments: \n  tagCategoryRef      Ref<tagCategory>, optional filter\n*/\n\n(tagCategoryRef:null, ptTagsFilter:\"\") => do\n  // Build title\n  title: \"\"\n  if (tagCategoryRef!=null)\n    title= title+readById(tagCategoryRef).dis()+\" tagSets\"\n  else title= title+\"All tagSets\"\n\n  // Initialize grid\n  grid: if(tagCategoryRef==null)\n          readAll(tagSet)\n        else\n          readAll(tagSet and tagCategoryRef==tagCategoryRef)\n  \n  // Apply ptTags text filter\n  grid= grid.findAll(row => do\n    // regex with ?i flag is NOT case sensitive\n    return reMatches(\"(?i).*\"+ptTagsFilter+\".*\", row->ptTags)\n  end)\n  \n  // Escape if no tagSets are found, to avoid grid manipulation errors\n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n  \n  // Convert mod to Los_Angeles tz\n  grid= grid.map(row => row.map((v,n) => if (n==\"mod\") v.toTimeZone(\"Los_Angeles\") else v))\n  \n  // Add title as id column display name\n  grid= grid.addColMeta(\"id\", {dis:title})\n  \n  disCols: [\"id\",\"eqTags\",\"ptTags\",\"tagCategoryRef\",\"mod\"]\n\n  return grid.toolFormatGrid(disCols)\n             .sort((a,b) => a.dis() <=> b.dis())\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"hisRemoveModhoppers",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n   points: readAll(point and his and modhopperDevAddr and \n   equipRef==@p:lbnl:r:239c2df6-df69fec7)\n   points.each pt => do\n     hisRemove(pt, pt->hisStart..\"now\")\n     end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuDuctGain"],,,,M,,,,,,"viAhuZeroReheat",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Review data from all terminal units served by a given AHU and returns\n  the discharge air temperatures of zones with no reheat and zones with\n  reheat whose valve has been closed for a given amount of time.\n  \n  Arguments: \n  ahuId      id of ahu to analyze\n  span       dates to analyze\n  rhDelay    allowed time delay for residual heat to leave heat coil\n*/\n\n(ahuId: read(ahu and equip and siteRef->dis==\"67\" and navName==\"AHU-01\")->id,\n span:yesterday(),\n rhDelay: 90min, pctSensor: 10, pctTime: 80) => do\n  tus: readAll(terminalUnit and equip and ahuRef==ahuId)\n  \n  eats: tus.map tu => do\n    dat: read(discharge and air and temp and sensor and equipRef==tu->id,\n              false)\n    rh: read(heat and valve and cmd and equipRef==tu->id,\n             false)\n    \n    // If DAT is missing, skip\n    if (dat==null) return null\n    // If terminal unit has reheat coil but valve cmd is missing, skip\n    if (rh==null and tu.has(\"hotWaterHeat\")) return null\n    \n    // If terminal unit has no reheat, then entire period is valid\n    if (rh==null) norh: dat.hisRead(span, {limit: null})\n                           .hisFindPeriods(v => true)\n    // Otherwise, period is valid only when reheat valve has been closed\n    // for at least rhDelay\n    else do\n      extSpan: span.toDateSpan().start-1day..span.toDateSpan().end+1day\n      norh: rh.hisRead(extSpan, {limit: null})\n              .hisFindPeriods(v => v == 0%)\n              .hisPeriodShift(rhDelay, 0min)\n    end\n    \n    eat: dat.hisRead(span, {limit: null})\n            .hisFindInPeriods(norh)\n            .addColMeta(\"v0\", {dis: readById(dat->equipRef).dis()\n                                    + \" Calcd Entering Air Temp\",\n                               chartType: \"scatter\",\n                               chartGroup: \"temps\",\n                               chartMin: 50°F,\n                               chartMax: 100°F,\n                               strokeWidth: 1})\n    {eat: eat}\n  end\n  \n  eats= hisJoin(eats.colToList(\"eat\"))\n  \n  heatGain: anAhuDuctGain(ahuId, span, rhDelay, pctSensor, pctTime)\n  sat: read(discharge and air and temp and sensor and equipRef==ahuId)\n       .hisRead(span, {limit: null})\n       .addColMeta(\"v0\", {chartGroup: \"temps\",\n                          chartMin: 50°F,\n                          chartMax: 100°F,\n                          strokeWidth: 5})\n       .addCol(\"eat\", row => row[\"v0\"] + heatGain)\n       .addColMeta(\"eat\", {dis: \"SAT + duct heat gain\",\n                           chartGroup: \"temps\",\n                           chartMin: 50°F,\n                           chartMax: 100°F,\n                           strokeWidth: 5})\n  \n  temps: hisJoin([sat, eats])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"ztrash_ptVirtualSumFormula",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point using sums and\n  fixed multipliers specified in pointFormula records with pointRef\n  equal to the target virtual point.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n \n   Tags:\n  - virtual\n  --- hisFunc\n  --- hisRollup function with (val, acc) arguments\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  // Load params from target point record\n  rollupFunc: eval(\"(val,acc)=>\"+rec->hisRollup+\"(val,acc)\")\n  \n  // Find all source points that might be needed in formula\n  sourcePts: readAll(pointFormula and pointRef==rec->id)\n             .colToList(\"sourcePointRef\")\n             \n  // Load and align source data\n  hisGrid: sourcePts\n           .hisRead(dates, {limit:null})\n           .toolHisAlign(rollupFunc,\n                         min,            // intervalFunc\n                         true,           // removeMissing\n                         0min)           // minRollup\n  \n  // store key between column name and point id\n  refKey: hisGrid.removeCol(\"ts\").colNames\n          .map(colName => \n              {colName:colName,\n               id:hisGrid.col(colName).meta->id})\n  \n  // Row by row, process history grid of source points\n  // and apply appropriate formula\n  hisGrid= hisGrid.addCol(\"val\", row => do\n    appropriateFormula: pointFormula(row->ts, rec->id)\n    result: 0\n    \n    appropriateFormula.each(coeff => do\n      multiplier: coeff->multiplier\n      sourcePointRef: coeff->sourcePointRef\n      sourceColName: refKey.find(key => key->id==sourcePointRef)->colName\n      result= result + multiplier * row[sourceColName]\n    end)\n    \n    return result\n  end)\n  \n  // Yield results\n  hisGrid.each(row => if(row[\"val\"] != null) yield(row->ts, row->val))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap67VAVEquip",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  file: ioReadCsv(`io/b67_vav_equip.csv`)\n  siteId: read(site and dis==\"Building 67\")->id\n  \n  file.each row => do\n    floor: \"B67 Floor \" + row->floor\n    floorId: read(location and siteRef->dis==\"Building 67\" and\n                  dis==floor)->id\n    room: \"Rm \" + row->equip\n    exist: readAll(siteRef==siteId and \n                   locationRef==floorId and\n                   equip and\n                   navName==room)\n                   \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: room,\n         disMacro: \"\\\$locationRef \\\$navName\",\n         vav,\n         equip,\n         locationRef: floorId,\n         siteRef: siteId,\n         tmpTest20180511\n        },\n        {add}\n      ))\n    end\n    \n    eq: read(siteRef==siteId and \n             locationRef==floorId and\n             equip and\n             navName==room)\n    \n    if (row->zone != \"0\") do         \n      commit(diff(eq, {untZone: row->zone,\n                       untController: row->controller}))\n    end else do\n      commit(diff(eq, {controller: row->controller}))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","toolRecTags"],,,,M,,,,,,"ptVirtualEquipAverageNan",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  average value of all points which are in the same equip or\n  in a subequip and which share the same set of tags with the\n  virtual point. It excludes NA values from calculation.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  tagsList: toolRecTags(rec)\n  equipId: rec->equipRef\n  filterStr: tagsList.concat(\" and \") + \" and point and not virtual\"\n  \n  pts: toolRecursiveSearch(equipId, filterStr)\n  \n  pts.hisRead(dates, {limit: null})\n     .hisInterpolate()\n     .addCol(\"nanAvg\", row => do\n         n: row.remove(\"ts\")\n               .findAll(v => (v != na()) and (v != null))\n               .vals.size\n         s: row.remove(\"ts\")\n               .map(x => if (x==null or x==na()) 0 else x)\n               .vals.fold(sum)\n         return if(n==0) na() else s / n\n         end)\n     .each(row => yield(row->ts, row->nanAvg))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualMult2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  value of the point referenced by pointRef, multiplied by the \n  pointMultiplier tag of the virtual point. Both the source point\n  and the virtual point must have the same unit.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  \n  origPt: readById(rec->pointRef)\n  if (rec.has(\"pointMultiplier\") and \n      origPt->unit == rec->unit) do\n    mult: rec->pointMultiplier\n    origPt.hisRead(dates, {limit: null})\n         .each(row => if (row[\"v0\"] != null)\n                        yield(row->ts, row->v0 * mult))\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Original Function Time Compare",,M,,,,,,"hisTimeCompare_v00",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(point, dates, duration) => do\n  start_date: toDateSpan(dates - duration).start\n  r_current: point.hisRead(dates)\n  hisCompare(r_current, start_date)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toPlantLoad"],,,,M,,,,,,"plantStagingMalfunction",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(plant, dates, minTime: 30min) => do\n \n  // calculate plant load using supply, return and GPM\n  // also collect the plant stageUp sp\n  joined: toPlantLoad(plant->id, dates)\n  if (joined == null) return null\n  else\n    \n  //compare calculated load to stageUp sp\n  loadCompare: joined.map row => do\n            {\n            ts: row->ts,\n            val: row[\"v3\"]-row[\"load\"]\n            }\n          end  \n  \n  //determine periods when only one chiller/boiler should be running based on load and stageUp sp\n  onlyOneNeeded: loadCompare.hisFindPeriods(x => x > 0)\n    \n  runPeriods: []\n \n    supplyDevices: readAll(equipRef==plant->id and equip and (chiller or boiler))\n    supplyDevices.each device => do \n    \n      equipId: device->id\n      pts: readAll(point and cmd and enable and navName == \"CMD\" and hisSize and equipRef==equipId)\n      pts.each rec => do\n        //find all run periods for each chiller/boiler\n        runPeriods = runPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v != false))\n      end\n    \nend\n// find when multiple chillers are running at the same time\ntwoOn: hisPeriodMatrix(runPeriods).findAll r => r->numTrue > 1\n         \n // spark is created when two chillers are running and calculated load is below stageUp sp\n spark: hisPeriodIntersection([twoOn, onlyOneNeeded]).findAll(r => r->v0 >= minTime)\n \nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolUpdateSchedules",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(sourceFile:`io/config/schedules.trio`) => do\n  grid: ioReadTrio(`io/config/schedules.trio`)\n  \n  grid.each row => do\n    scheduleName: row->navName\n    exRec: read(schedule and navName==scheduleName, false)\n    \n    if (exRec != null)\n      commit(diff(exRec, row))\n    else\n      commit(diff(null, row, {add}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viAhuZoneAirflows",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, load supply terminal unit airflow for all TUs\n  served by that AHU then display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDis       number, cap airflow at this number\n  rollup       duration, interval for rollup\n  colors       Str, colors for heat map\n*/\n\n(ahuRef, dates: yesterday(), maxDis:null, rollup: 15min, colors: \"green, yellow, red\") => do\n  pts: readAll(air and flow and sensor\n               and equipRef->supply and equipRef->terminalUnit\n               and equipRef->ahuRef==ahuRef)\n               \n  if(isEmpty(pts)) return null\n  \n  if (maxDis==0) maxDis= null\n  \n  try do\n    pos: pts.hisRead(dates, {limit:null})\n    \n    if (rollup>0)\n      pos= pos.hisRollup(avg, rollup)\n    else\n      pos= pos.toolHisAlign(avg, max)\n    \n    pos=pos.hisFlatten((val, ts, his) => do\n        eq: readById(his->equipRef)\n        room: if (eq.has(\"equipRef\"))\n                readById(eq->equipRef)\n              else\n                eq\n        dis: if (readAll(supply and terminalUnit and equipRef==room->id).size >= 2)\n               room->navName + \" \" +\n               reGroups(\"\"\"(Supply,? )?(.*)\"\"\", eq->navName)[2]\n             else room->navName\n        {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n         rm: dis,\n         v0: val}\n    end)\n    .reorderCols([\"ts\",\"rm\",\"v0\"])\n    .addColMeta(\"v0\", {chartMin: 0cfm,\n                       chartMax: maxDis.as(\"cfm\")})\n    .addMeta({view: \"chart\", chartType:\"heatMap\", \n              title: \"Supply airflows, zones served by \"\n                     + readById(ahuRef).dis() + \", \"\n                     + pos.meta[\"hisRollupInterval\"],\n              colors: colors})\n  catch (ex) do\n    pos: null\n  end\n  return pos\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"viMeterDataQualityList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays formatted grid of data quality records.\n  \n  Arguments:\n  meterRef        Ref to a specific meter (optional)\n  disColNames     Str[], specifies names and order of columns\n                  to display (optional)\n*/\n\n(meterRef:null,\n disColNames: [\"id\",\"dataQuality\",\"qualityNote\",\"startDate\"]\n) => do\n  // Retrieve data quality records\n  grid: if(meterRef==null) readAll(dataQuality and meterRef)\n        else readAll(dataQuality and meterRef==meterRef)\n  \n  // Format grid\n  grid= toolFormatGrid(grid, disColNames)\n  \n  // Order by display string\n  grid= grid.sort((a,b) => a.dis() <=> b.dis())\n\n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHierarchy"],,,,M,,,,,,"viTargetDeficiencies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given target (point or equip), and a given span, return a\n  timeline of deficiencies that apply at or above target.\n  \n  Arguments: \n  recId        Target id\n  span         Datespan\n*/\n\n(recId:@p:lbnl:r:235126e0-5461ac88, span:pastMonth()) => do\n  // All records above in the equip hierarchy are valid targets\n  listTargets: toolHierarchy(recId)\n  \n  // Find deficiencies that apply to any of the targets\n  deficiencies:\n    readAll(deficiency and equipRef)\n    // Filter out deficiencies not related to targets\n    .findAll(def => listTargets\n                    .any(target => target==def->equipRef))\n    // Filter out deficiencies that ended before span's start or\n    // started after span's end\n    .findAll(def => do\n      if (def.has(\"endDate\") and (def->endDate < span.start()))\n        return false\n      if (def.has(\"startDate\") and (def->startDate > span.end()))\n        return false\n      return true\n    end)\n  \n  if(isEmpty(deficiencies)) return null\n  \n  // Chart deficiencies\n  chart: {}.toGrid()\n  deficiencies.each def => do\n    dstart: if(def.has(\"startDate\")\n               and (def->startDate > span.start()))\n              def->startDate\n            else\n              span.start()\n    dend: if(def.has(\"endDate\")\n               and (def->endDate < span.end()))\n              def->endDate\n            else\n              span.end()\n    dspan: (dstart..dend).toSpan()\n    defTrend: hisSlidingWindows(dspan,1h,1h)\n              .addColMeta(\"v0\", {dis: \"Deficiency - \"+def.dis()+\" - \"+def->state})\n    if (isEmpty(chart)) chart= defTrend\n    else chart= hisJoin([chart, defTrend])\n  end\n  \n  return chart.addMeta({view:\"chart\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptPowerIntegrator"],,,,M,,,,,,"ptVirtualPowerIntegrator",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function is a hisFunc wrapper around the custom function\n  ptPowerIntegrator\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  maxGap: rec->hisMaxGap\n  hisGrid: ptPowerIntegrator(rec->pointRef, dates, maxGap)\n  hisGrid.each(row => yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualCopy",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function replicates history for a virtual point, based on\n  the history of a point marked as pointRef in the virtual point.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readById(rec->pointRef)\n  .hisRead(dates, {limit: null})\n  .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB37TWTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236ce97f-2572a261,\n             @p:lbnl:r:23663539-04ee4eea,\n             @p:lbnl:r:23663539-28e222b1,\n             @p:lbnl:r:23663539-ab2ceaea,\n             @p:lbnl:r:23663539-ccd8ca7f,\n             @p:lbnl:r:23663539-f28acfdd,\n             @p:lbnl:r:23663539-177ecc0f,\n             @p:lbnl:r:23663539-f774c483,\n             @p:lbnl:r:23663539-f2a89dea,\n             @p:lbnl:r:23663539-b6efa6da,\n             @p:lbnl:r:23663539-37599169,\n             @p:lbnl:r:219d5a20-35792ce9])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (his.has(\"equipRef\") and\n        readById(his->equipRef).has(\"load\") and \n        his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDailyGasHillHolidaysTime",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return time series chart of daily gas usage on hill (in therm)\n  Compare 2017 end-of-year holiday with other periods\n*/\n\n() => do\n  tHolidays: 2017-12-22..2018-01-01\n  //xHolidays: read(weather and dis==\"LBNL Weather Station\").degreeDays(tHolidays, 65°F)\n  yHolidays: read(locationRef->dis==\"SBLID 79 (TOT HILL) Utility\" and equipRef->gas\n              and delta and energy and sensor and not virtual and not hidden)\n              .hisRead(tHolidays, {limit:null})\n  //joinedHolidays: hisJoin([xHolidays, yHolidays]).hisClip()\n  seriesHolidays: yHolidays.renameCol(\"v0\",\"gasUsageHolidays\").hisClip()\n  \n  //xPrev: read(weather and dis==\"LBNL Weather Station\").degreeDays(pastMonth() - 7day, 65°F)\n  //yPrev: (read(siteRef->dis==\"Building 33\" and equipRef->gas and volume and rate and not virtual).hisRead(pastMonth() - 7day, {limit:null})\n  //         .hisRollup(avg, 1hr).hisInterpolate().hisMap pt => pt*60)\n  //       .hisRollup(sum, 1day).hisMap pt => pt.as(1ft³)  // Average ft³/min over 1h and multiply by 60 to get hourly ft³\n  //joinedPrev: hisJoin([xPrev, yPrev])\n  //newSeriesPrev: joinedPrev.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsagePrevious\").findAll row => row->heat > 0\n  \n  tBase: 2017-10-01..2017-12-21\n  //xBase: read(weather and dis==\"LBNL Weather Station\").degreeDays(tBase, 65°F)\n  yBase: read(locationRef->dis==\"SBLID 79 (TOT HILL) Utility\" and equipRef->gas\n              and delta and energy and sensor and not virtual and not hidden)\n              .hisRead(tBase, {limit:null})\n  //joinedBase: hisJoin([xBase, yBase]).hisClip()\n  seriesBase: yBase.renameCol(\"v0\",\"gasUsageBase\").hisClip()\n  \n  allJoined: joinAll([seriesBase, seriesHolidays], \"ts\")\n  allJoined.addMeta({chartType: \"scatter\", title: \"Comparison of Hill daily natural gas usage over time\"})\n    .addColMeta(\"gasUsageBase\", {chartType: \"scatter\", dis: \"Base daily gas usage\"})\n    .addColMeta(\"gasUsageHolidays\", {chartType: \"scatter\", color: \"#CCCBCB\", dis: \"Holidays Gas Usagee\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolFoldSparkHis"],,,,M,,,,,,"viMeterConsumption",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display a grid with the totalized consumption of each meter listed in meterRefs,\n  along with uptime statistics based on NA values and null values\n\n  Arguments: \n  meterRefs\n  span\n  removeSparks     Bool, if true, consider data is not valid when there is\n                   any spark on the meter\n  conventionStr    Str, see convList\n*/\n(meterRefs, span, removeSparks:true, conventionStr:null) => do\n  // Process conventionStr\n  convList: [\n    \"LBNL Convention: inclusive / exclusive / 00:00 - 23:59\",\n    \"Typical: inclusive / inclusive / 00:00 - 23:59\",\n    \"inclusive / inclusive / noon-noon\"]\n  convNum: convList.index(conventionStr)\n  if (convNum==null) convNum= 1\n\n  // Prepare readSpan based on convention\n  if (convNum==0)\n    // Shift end date, -1 day and -1sec\n    readSpan: span.toSpan.start()..(span.toSpan.end() -1day -1sec)\n  if (convNum==1)\n    // Typical skyspark convention, just remove midnight\n    readSpan: span.toSpan.start()..(span.toSpan.end() -1sec)\n  if (convNum==2)\n    // Start and end at noon on provided dates\n    readSpan: dateTime(span.toDateSpan.start(),time(12,0,0))..\n              dateTime(span.toDateSpan.end(),time(11,59,59))\n\n  meterRefs\n  // Find the consumption differential trend associated with the meter, should have delta tag\n  .map(meterRef => read(delta and sensor and not hidden and equipRef->id==meterRef, false))\n  \n  // Remove meters that don't have a consumption differential\n  .findAll(pt => pt != null)\n  \n  // Calculate metrics for each meter / consumption point\n  .map(pt => do\n    // Meter rec\n    meterRec: readById(pt->equipRef)\n    \n    // Load data, clip to remove previous and next data points loaded by default\n    hisTrend: pt.hisRead(readSpan, {limit: null})\n                .hisClip()\n    \n    // Calculate total consumption by sum, remove null and na() values\n    // to get a result even when data is missing\n    total: hisTrend\n           .hisMap(v => if (v==null or v==na()) 0 else v)\n           .foldCol(\"v0\", sum)\n    \n    // Find periods when there are no spark on meter\n    sparkPeriods: ruleSparks(meterRec, readSpan, readAll(sparkRule))\n                  .ruleSparkHis()\n                  .toolFoldSparkHis()\n    noSparkPeriods: if (removeSparks and not(isEmpty(sparkPeriods)))\n                      hisPeriodMatrix([sparkPeriods])\n                      .findAll(r => not r->v0)\n                      .keepCols([\"ts\",\"dur\"])\n                    else\n                      hisSlidingWindows(readSpan, 1hr, 1hr)\n    \n    // Get meter uptime trend\n    up: try\n          if (meterRec.has(\"elec\"))\n            hisTrend\n            // Use toolHisAlign to find lowest common interval and align to it\n            // (Results may be inaccurate if trending interval is not fixed)\n            .toolHisAlign(avg, min, false)\n            // Filter out anything not in readSpan, because rollup sometimes fills the grid\n            // from midnight to midnight\n            .findAll(r => r->ts >= readSpan.start and r->ts <=readSpan.end)\n            // Map missing data as 0 and avaialble data as 1\n            .hisMap((v, ts, his) => if (v==null or v==na()) 0\n                                    else if (removeSparks and hisInWindows(ts, sparkPeriods)) 0\n                                    else 1)\n            // Remove any rows that postpone now(), e.g. if loading full current year\n            .hisFindAll((v,ts,his)=>ts<now()+1s)\n          else if (meterRec.has(\"gas\")) do\n            // Attempt to retrieve uptime trend if it exists\n            read(uptime and equipRef==meterRec->id)\n            .hisRead(readSpan, {limit:null})\n            .hisFindInPeriods(noSparkPeriods)\n            .hisFindAll(v => v != null and v != na())\n          else\n            null\n        catch\n          null\n          \n    // Calculate uptime in %\n    spanEnd: if (readSpan.end > now()) now() else readSpan.end\n    spanLength: (spanEnd - readSpan.start).to(1h)\n    uptime: if (meterRec.has(\"elec\"))\n              (up.foldCol(\"v0\", sum) / up.size * 100).as(1%)\n            else if (meterRec.has(\"gas\") and up != null and not isEmpty(up))\n              (up.foldCol(\"v0\", sum) / spanLength * 100).as(1%)\n            else na()\n        \n    // Convert consumption to desired unit\n    total= if(unit(total)==unit(1BTU) and meterRec.has(\"gas\")) total.to(1therm)\n           else total\n           \n    // Compile return dictionary values for the current meter consumption\n    {meter: pt->equipRef->id,\n     total: total,\n     uptime: uptime\n    }\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpRemap34ARUNetworkPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  bacnetPtList: null\n  \n  readAll(locationRef->id==@p:lbnl:r:2319c0bc-f94a93c1 and point and bacnetCur)\n  .each pt => do\n    jobProgress(0%, pt.dis())\n    instance: reGroups(r\"Sys CH-(\\d)\", pt.dis())[1]\n    objectType: pt->bacnetCur[0..1]\n    connectorId: pt->bacnetConnRef\n    \n    bacnetLearn(connectorId)\n    if (objectType == \"AV\") do\n      bacnetPtList= bacnetLearn(connectorId, 2)\n    end // AV\n    if (objectType == \"BV\") do\n      bacnetPtList= bacnetLearn(connectorId, 5)\n    end // BV\n    if (isEmpty(bacnetPtList)) return \"bacnetLearn failed\"\n    \n    bacnetDis: pt->bacnetName + \"_\" + instance\n    bacnetRow: bacnetPtList.find(row => row[\"dis\"]==bacnetDis)\n    if (bacnetRow == null) throw \"Object not found: \" + bacnetDis\n    \n    commit(diff(pt, {bacnetName: bacnetDis, bacnetCur: bacnetRow->bacnetCur}))\n  end // readAll\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"hisReadIonSql_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n( sqlConn, point, dates ) => do\n  // Process sqlConn\n  if (isRef(sqlConn)) conn: readById(sqlConn)\n  else conn: sqlConn\n  //Need to add some error checking\n  //if not point->equipRef->ionSqlConn then return False???\n\n  // Ask sql for UTC datetimes in text format, so it doesn't get inadvertently converted by JDBC\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND (S.DisplayName = '\" + point->equipRef->sqlMeter + \"')\" +\n   //    \"      OR S.Name = '\" + point->equipRef->sqlMeter + \"')\" +\n       \" AND D.QuantityID = \" + point->sqlQID +\n       \" AND D.TimestampUTC >= '\" + dates.start.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n       \" AND D.TimestampUTC < '\" + dates.end.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: conn.sqlQuery(sql)\n\n  // Add \"UTC\" to tz-naive text strings from sql, then parse and convert to Los_Angeles time zone\n  mapped: data.map(row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                .toTimeZone(\"Los_Angeles\"),\n                            val: if(row.missing(\"val\")) null else row->val })\n              .findAll(r => r.has(\"val\"))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"fandocDeficiencyLinks",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyRef) => do\n  try links: readById(deficiencyRef)->links\n  catch return \"Deficiency has no associated links.\"\n  \n  if(isEmpty(links))\n    return \"Deficiency has no associated links.\"\n  \n  doc: \"\"\n  links.each((link, n) => do\n    domain: if (link.contains(\"google\")) \" (Drive)\"\n            else if (link.contains(\"skyspark\")) \" (SkySpark)\"\n            else if (link.contains(\"tracker\")) \" (kW Tracker)\"\n            else \"\"\n    if(doc != \"\") doc= doc+\"\\n\\n\"\n    doc= doc+\"[Link \"+(n+1).toStr()+domain+\"]\"\n            +\"`\"+link+\"`\"\n  end)\n  return doc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDailyGasHillHolidaysScatter",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of daily gas usage on hill (in therm) vs HDD\n  Compare 2017 end-of-year holiday with other periods\n*/\n\n() => do\n  tHolidays: 2017-12-22..2018-01-01\n  xHolidays: read(weather and dis==\"LBNL Weather Station\").degreeDays(tHolidays, 65°F)\n  yHolidays: read(locationRef->dis==\"SBLID 79 (TOT HILL) Utility\" and equipRef->gas\n               and delta and energy and sensor and not virtual and not hidden)\n             .hisRead(tHolidays, {limit:null})\n  joinedHolidays: hisJoin([xHolidays, yHolidays]).hisClip()\n  seriesHolidays: joinedHolidays.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsageHolidays\").findAll row => row->heat > 0\n  \n  //xPrev: read(weather and dis==\"LBNL Weather Station\").degreeDays(pastMonth() - 7day, 65°F)\n  //yPrev: (read(siteRef->dis==\"Building 33\" and equipRef->gas and volume and rate and not virtual).hisRead(pastMonth() - 7day, {limit:null})\n  //         .hisRollup(avg, 1hr).hisInterpolate().hisMap pt => pt*60)\n  //       .hisRollup(sum, 1day).hisMap pt => pt.as(1ft³)  // Average ft³/min over 1h and multiply by 60 to get hourly ft³\n  //joinedPrev: hisJoin([xPrev, yPrev])\n  //newSeriesPrev: joinedPrev.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsagePrevious\").findAll row => row->heat > 0\n  \n  tBase: 2017-10-01..2017-12-21\n  \n  xBase: read(weather and dis==\"LBNL Weather Station\").degreeDays(tBase, 65°F)\n  yBase: read(locationRef->dis==\"SBLID 79 (TOT HILL) Utility\" and equipRef->gas\n              and delta and energy and sensor and not virtual and not hidden)\n         .hisRead(tBase, {limit:null})\n  joinedBase: hisJoin([xBase, yBase]).hisClip()\n  seriesBase: joinedBase.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsageBase\").findAll row => row->heat > 0\n  \n  allJoined: joinAll([seriesBase, seriesHolidays], \"heat\")\n  allJoined.addMeta({chartType: \"scatter\", title: \"Comparison of Hill daily natural gas usage versus HDD\"})\n    .addColMeta(\"gasUsageBase\", {chartType: \"scatter\", dis: \"Base daily gas usage\"})\n    .addColMeta(\"gasUsageHolidays\", {chartType: \"scatter\", color: \"#CCCBCB\", dis: \"Holidays Gas Usagee\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldSample",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  if (val == foldStart()) return {v0: null}\n  if (val == foldEnd()) return acc[\"v0\"]\n  if (val == na() or acc[\"v0\"]==na()) return {v0: na()}\n  if (val == null) return acc\n  return {v0: val}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viB59OATComparison",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/* \n  For the given dates compare the AHU OAT and OA %RH sensors to the campus sensors\n\n    Arguments:\n    dates        Span of dates we want to compare OA temps for\n    ahus         Location for sensors, default to B59\n    \n  **consider adding a range for \"out of sync\" or \"needs callibration\"\n*/\n\n(dates: today, rollupMinutes: 5min, dryBulbOnly:false, ahuRef: null, weather: null, ctRef: null) => do\n\n  // Default to B59 AHUs & Exhaust\n  if(ahuRef==null)\n    ahuRef = @p:lbnl:r:2373a7aa-df0b1ca4\n  \n  //Default to LBNL Weather Station\n  if(weather==null)\n    weather = @p:lbnl:r:2194df1f-ebd11fde\n    \n  //Default to B59 TW\n  if(ctRef==null)\n    ctRef = @p:lbnl:r:22dbdae2-0f98c395\n  \n  // Look-up the AHUs at B59 \n  ahus: readAll(locationRef==ahuRef \n                   and ahu\n                   and equip)\n\n // Exit if no ahus were found\n  if(isEmpty(ahus)) return null\n\n // Create grid of calculated histories\n  hisGrid: {}.toGrid()\n  \n  // List of colors for display\n  colorsList: [\"blue\",\"red\",\"green\",\"purple\",\"gold\",\"teal\",\"hotpink\",\"orange\",\"greenyellow\",\"grey\",\"grey\",\"grey\"]\n\n // Cycle through each AHU and look up the OA temp and name appropriately\n  ahus.each((ahu,i) => do\n    // Find OA temp... \n    //The mode to find OA %RH and OA WB has been disabled after new AHUs with no %RH sensors were added\n    //these were causing the function to fail.\n    ahuTemp: read(air and outside and point and sensor and temp and not wetBulb and equipRef==ahu->id, false)\n    ahuRH: if (dryBulbOnly) null else read(air and outside and point and sensor and humidity and equipRef==ahu->id, false)\n    oaWB: if (dryBulbOnly) null else read(air and outside and point and sensor and temp and wetBulb and equipRef==ahu->id, false)\n    \n    ahuPts: [ahuTemp, ahuRH, oaWB].findAll(v => v != null)\n    \n    // Read histories, combine\n    grid: ahuPts.hisRead(dates, {limit:null})\n         .hisRollup(avg, rollupMinutes.as(\"min\"))\n         \n    // Formatting per column\n    grid.removeCol(\"ts\").colNames.each colName => do\n      // Get meta from column, same as point metadata\n      colMeta: grid.col(colName).meta()\n      \n      // Identify point from tags\n      if (colMeta.has(\"air\") and colMeta.has(\"temp\") and colMeta.missing(\"wetBulb\")) do\n        pointType: \"oat\"\n        disText: \" OA Temp (°F)\"\n      end else if (colMeta.has(\"wetBulb\") and colMeta.has(\"temp\")) do\n        pointType: \"wb\"\n        disText: \" OA Wetbulb Temp (°F)\"\n      end else do\n        pointType: \"rh\"\n        disText: \" OA Relative Humidity (%)\"\n      end\n      \n      grid= grid.addColMeta(colName,\n            {chartGroup: pointType,\n             dis: ahu->navName + disText,\n             color: colorsList[i],\n             strokeWidth:2,\n            })\n    end\n                     \n    // Add to hisGrid summary array\n    if (isEmpty(grid)) return null\n    if (isEmpty(hisGrid)) hisGrid=grid\n    else hisGrid= hisJoin([grid,hisGrid])\n  end)\n  \n  // Look up OA temp, OA %RH and OA WB for LBNL Weatherstation\n   oaTemp: read(air and point and sensor and temp and not wetBulb and weatherRef==weather, false)\n   oaRH: read(air and point and sensor and humidity and weatherRef==weather, false)\n   oaWB: read(point and sensor and temp and wetBulb and weatherRef==weather, false)\n   \n   //Read histories, add to grid\n   weatherGrid: toRecList([oaTemp, oaRH, oaWB]).hisRead(dates, {limit:null})\n         .hisRollup(avg, rollupMinutes.as(\"min\"))\n         .addColMeta(\"v0\", {chartGroup: \"oat\",\n                            color: \"black\",\n                            strokeWidth:2,\n                            dis: weather->dis + \" OA Temp (°F)\"})\n         .addColMeta(\"v1\", {chartGroup: \"rh\",\n                            color: \"black\",\n                            strokeWidth:2,\n                            dis: weather->dis + \" OA Relative Humidity (%)\"})\n         .addColMeta(\"v2\", {chartGroup: \"wb\",\n                            color: \"black\",\n                            strokeWidth:2,\n                            dis: weather->dis + \" OA Wetbulb Temp (°F)\"})\n\n\n  //add weather to the rest of the trends\n  hisGrid= hisJoin([hisGrid, weatherGrid])\n\n  // Look up OA WB for the B59 CT\n  ctWB: read(air and outside and point and sensor and temp and wetBulb and locationRef==ctRef, false)\n      \n  //Read histories, add to grid\n  wbGrid: ctWB.hisRead(dates, {limit:null})\n          .hisRollup(avg, rollupMinutes.as(\"min\"))\n          .addColMeta(\"v0\", {chartGroup: \"wb\",\n                             color: \"#00CED1\",\n                             strokeWidth:2,\n                             dis: ctRef->dis + \" OA Wetbulb Temp (°F)\"})\n    \n    //add weather to the rest of the trends\n  // hisGrid= hisJoin([hisGrid, wbGrid]).addCol(\"diff\", row => do\n  //           if (row[\"v10\"] > 0 and row[\"v11\"] > 0)\n  //             return ((row[\"v10\"] - row[\"v11\"]) / row[\"v10\"]*100).as(\"%\")\n  //           else\n  //             return null\n  //          end)\n  //          .addColMeta(\"diff\", {chartGroup: \"wb\",\n  //                               color: \"#FF6347\",\n  //                               dis: \"Percentage Variance (%)\",\n  //                               chartMin: -20%,\n  //                               chartMax: 20%})\n  \n  // Remove non-OAT chart groups if dry bulb only                          \n  if (dryBulbOnly) do\n    keepColNames: hisGrid\n                  .colNames\n                  .findAll(colName => colName==\"ts\" or hisGrid.col(colName).meta[\"chartGroup\"]==\"oat\")\n    hisGrid= hisGrid.keepCols(keepColNames)\n  end\n  \n  return hisGrid\nend\n            \n                   \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"tmpGraphPointByPoint",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  readByIds([@p:lbnl:r:234ac366-9384a1cd,\n             @p:lbnl:r:234ac366-cba4f42c,\n             @p:lbnl:r:234ac365-2d1a77f3,\n             @p:lbnl:r:234ac366-2c6a38b9,\n             @p:lbnl:r:234ac366-cff4b4ae])\n  .hisRead(today)\n  .toolFormatTrends(\"By unit\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"calculateAccumulatorToRate",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates history for a virtual rate of change\n point using an accumualtor point history\n  \n Accumulator point should be tagged as pointRef in virtual\n rate of change point\n  \n Arguments:\n restartDate (optional)   Date to rewrite history from. Must be\n                          a date, not a dateTime.\n newOnly (optional)       If true, calculate only for points that\n                          have no history (not hisEnd)\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2018-08-23 //\n*/\n\n(restartDate:null, newOnly:false) => do\n  // Store today's date\n  today: now().date\n  \n  // Virtual points with rateFromAccumulator tag with a pointRef\n  //  and no hisFunc can go through this function\n  filter: \"virtual and sensor and point and rateFromAccumulator \" +\n          \"and his and pointRef and not hisFunc\"\n  if (newOnly) filter = filter + \" and not hisEnd\"\n  query: parseFilter(filter)\n  \n  ptList: readAll(query)\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  // Cycle through each point:\n  ptList.each pt => do\n    hisEnd: pt[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    aregument). Assign dates, clear history, and/or assign\n    hisEnd based on which of the 4 cases is presented\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Calculate rate:\n    // Initialize previous value and previous timestamp trackers\n    prevVal: null\n    prevTs: null\n    dict: null\n\n    rawGrid: pt->pointRef.hisRead(dates, {limit: null})\n    resultGrid: rawGrid.map row => do\n      // All rows that are not first row\n      if (prevVal != null) do\n        deltaTs: (row->ts - prevTs).to(1h) // Use time in hours for rates (BTU/h)\n        deltaVal: row->v0 - prevVal\n        avgTs: prevTs + (deltaTs / 2)\n        rate: deltaVal / deltaTs\n        if (unit(rate) == unit(1kWh / 1h)) rate = rate.as(1kW)\n        if (unit(rate) == unit(1gal / 1h)) rate = (rate/60).as(1gal/min)\n        dict = {ts: avgTs, v0: rate}\n      end\n      // Update values\n      prevTs = row->ts\n      prevVal = row->v0\n      dict\n    end\n    \n    // Filter out result grid to remove negative values (accumulator reset)\n    resultGrid = resultGrid.findAll(row => row[\"v0\"] >= 0)\n    \n    // Filter out redundant data (already in history)\n    filteredGrid: resultGrid.findAll(row => row->ts > hisEnd + 1s)\n    \n    // Write calculated data to history.\n    hisWrite(filteredGrid, pt)\n    return {written: filteredGrid.size, status: \"OK\"}\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"ptVirtualChillerEfficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For the chiller equip that this virtual point exists in, find the input\n  and output delta energy points, load trend data for these points,\n  convert units as needed, align data with toolHisAlign and calculate\n  efficiency ratio in kW/ton.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n\n  Tags:\n  - virtual\n  --- hisFunc\n  --- hisRollup function with (val, acc) arguments\n  --- hisInterval (optional)\n*/\n\n(rec, dates, opts, yield) => do\n  // Normalize to absolute ref (for old Historian)\n  rec= rec->id.readById\n\n  // Determine numerator and denominator\n  numeratorPt: read(input and delta and energy and sensor and not hidden\n                    and equipRef==rec->equipRef, false)\n  denominatorPt: read(output and delta and energy and sensor and not hidden\n                      and equipRef==rec->equipRef, false)\n\n  // Exit if numerator or denominator not found\n  if (numeratorPt==null or denominatorPt==null) return null\n\n  tUnit: \"kW/ton\"\n  \n  // Check for presence of hisInterval tag\n  minRollup: if (rec.has(\"hisInterval\")) rec->hisInterval\n             else 0min\n  \n  // Determine rollup function\n  rollupFunc: eval(\"(val,acc)=>\"+rec->hisRollup+\"(val,acc)\")\n\n  // Read available history, align, calculate ratio, yield\n  hisGrid: [numeratorPt, denominatorPt]\n           .hisRead(dates, {limit:null})\n  hisGrid.toolHisAlign(rollupFunc, min,  // rollupFunc, intervalFunc\n                       true, minRollup)  // removeMissing, minRollup\n         .addCol(\"ratio\", row => do\n           numerator: row->v0.to(\"kWh\").as(1)\n           denominator: row->v1.to(\"tonrefh\").as(1)\n           if (numerator==0 or denominator==0) return na()\n           return (numerator / denominator).as(tUnit)\n         end)\n         .each(row => yield(row->ts, row->ratio))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuDuctGain","anZoneEnabled"],,,,M,,,,,,"ruReheatFailure",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns a grid of periods an equip has a dyfunctional reheat\n  valve, whereby the terminal unit reheat command is 90% or more but DAT is low.\n  Based on a given minimum differential, default 10°F, above AHU SAT + estimated\n  duct gain.\n  \n  Arguments:\n  equip           equip record of equip to test\n  span            dateSpan, span of dates to run analysis on\n  minDiffTemp     number in °F, minimum target temp differential between\n                  measured discharge air temp and estimated entering air temp\n  minrh           number in %, default 90%, above which valve position is considered\n                  fully open\n  rhDelay         allowed time delay for heating coil to warm up after 100% cmd\n  minTime         duration, filter out periods shorter than minTime\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n  zoneEnabledOnly Bool, if true filter out periods when anZoneEnabled\n                  period is False / Off\n  enMinAirflowSp  Minimum airlfow setpoint to consider zone controls are\n                  enabled.\n*/\n\n(equip:readById(@p:lbnl:r:2324cceb-e30a4c1a), span:pastWeek(),\n minDiffTemp: 5°F, minrh: 90%, rhDelay: 90min, minTime: 30min,\n mergePeriod: 15min, zoneEnabledOnly:false, enMinAirflowSp: 50cfm) => do\n  // Params: syncDelay allows buffer in case reheat valve position\n  // is trended at 15min and DAT is trended at 5min\n  syncDelay: 15min\n  \n  dat: read(discharge and air and temp and sensor and equipRef==equip->id,\n            false)\n  rh: read(heat and valve and cmd and equipRef==equip->id, false)\n    \n  // Retrieve occupied command if occOnly is true\n  zone: if(equip.has(\"zone\")) equip\n        else if(equip.has(\"equipRef\")) readById(equip->equipRef)\n        else null\n  zoneEn: if (zone!= null and zoneEnabledOnly)\n            anZoneEnabled(zone->id, span, enMinAirflowSp)\n          else null\n  \n  // If DAT is missing, return null\n  if (dat==null) return null\n  \n  // If terminal unit has no reheat valve cmd, return null\n  if (rh==null) return null\n\n  // Period is valid only when reheat valve has been fully open\n  // for at least rhDelay\n  extSpan: span.toDateSpan().start-1day..span.toDateSpan().end+1day\n  fullrh: rh.hisRead(extSpan, {limit: null})\n            .hisFindPeriods(v => v > minrh)\n            .hisPeriodShift(rhDelay, -syncDelay)\n  \n  // Estimate duct heat gain for related AHU\n  if (not(readById(equip->id).has(\"ahuRef\"))) return null\n  ahuId: equip->ahuRef\n  heatGain: anAhuDuctGain(ahuId, span, rhDelay)\n  if (heatGain==null) return null\n\n  // Load AHU SAT and TU DAT history, and flag when DAT < SAT + DHG + minDiffTemp\n  // and reheat valve has been fully open or nearly so (fullrh period)\n  sat: read(discharge and air and temp and sensor and equipRef==ahuId,\n            false)\n  // If AHU SAT is missing, return null\n  if (sat==null) return null \n  \n  datHis: dat.hisRead(span, {limit: null}).renameCol(\"v0\",\"dat\")\n  eatHis: sat.hisRead(span, {limit: null})\n             .addCol(\"eat\", row => row->v0 + heatGain)\n             .keepCols([\"ts\",\"eat\"])\n  \n  // Join trends, interpolate, filter out reheat periods\n  flagPeriods: hisJoin([datHis, eatHis])\n      .hisInterpolate()\n      .hisFindInPeriods(fullrh)\n\n  // Filter out unoccupied periods if occ is avilable\n  if (zoneEn != null)\n    flagPeriods= flagPeriods.hisFindInPeriods(zoneEn)\n\n  // Detect DAT < EAT + minDiffTemp\n  flagPeriods= flagPeriods\n      .addCol(\"flag\", row => if (row.has(\"dat\") and row.has(\"eat\"))\n                               row->dat < row->eat + minDiffTemp\n                             else\n                               null)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindPeriods(flag => if (flag != null) flag else false)\n  \n  // Re-filter to avoid last TRUE lasting until midnight\n  flagPeriods= hisPeriodIntersection([flagPeriods, fullrh])\n  \n  // Filter out unoccupied periods again, if occ is avilable\n  if (zoneEn != null)\n    flagPeriods= hisPeriodIntersection([flagPeriods, zoneEn])\n\n  // Rename cols after hisPeriodIntersection\n  flagPeriods= flagPeriods.renameCol(\"v0\",\"flag\")\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip.dis() + \" has leaky reheat valve or miscalibrated DAT sensor\"\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"sqlTestScript3",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(sqlConn, sqlMeter, sqlQID, dates) => do\n\n  //Need to add some error checking\n  //if not point->equipRef->ionSqlConn then return False???\n\n  // Ask sql for UTC datetimes in text format, so it doesn't get inadvertently converted by JDBC\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND S.Name = '\" + sqlMeter + \"'\" +\n       \" AND D.QuantityID = \" + sqlQID +\n       \" AND D.TimestampUTC >= '\" + dates.start.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n       \" AND D.TimestampUTC < '\" + dates.end.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: read(sqlConn).sqlQuery(sql)\n\n  // Add \"UTC\" to tz-naive text strings from sql, then parse and convert to Los_Angeles time zone\n  mapped: data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                .toTimeZone(\"Los_Angeles\"),\n                            val: row->val }\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,"Perform regression of daily natural gas usage versus HDD, with factor of weekday / weekend (total 2 variables).",,,,M,"anRegGasHddCalculate_v1","dailyGasHDD",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate regression of daily natural gas usage versus HDD,\n  with factor of weekday / weekend (total 2 variables).\n  Return dictionary with:\n    results:  dict of model coefficients and fit statistics\n    graph:    chart grid for measured & fitted points\n    dataset:  grid of original dataset, plus fitted values\n  \n  Arguments: \n  meterUsageRef      Ref of gas meter usage data point (Btu or therm)\n  dateSpan           Span of dates to perform analysis on\n  ddRefTemp          Reference temp for calculation of degree days\n  titlePrefix        (Optional) Title prefix for graph title\n  datesHighlight     Span of dates to highlight in graph\n\n  Notes:\n  For degree days calculation, the weather station associated with\n  the site associated with the meter usage point is used. Function\n  will fail if weatherRef is not defined on the corresponding site.\n*/\n\n(meterUsageRef, dateSpan, ddRefTemp, titlePrefix:\"\", datesHighlight:null) => do\n  // Read usage from meter energy point\n  usage: readById(meterUsageRef)\n        .hisRead(dateSpan, {limit:null})\n        .hisRollup(sum, 1day)\n        .renameCol(\"v0\", \"usage\")\n  \n  // Reference value with unit, for later unit casting\n  refValue: 1.as(usage.first[\"usage\"])\n\n  // Read outside air temperature from weather station associated with\n  //   meterUsage point, and calculate degree days\n  hdd: read(weatherRef==readById(meterUsageRef)->siteRef->weatherRef\n            and weatherPoint and air and temp  // OAT is input to degreeDays\n            and not secondary)  // Do not use secondary sensor if one exists\n       .degreeDays(dateSpan, ddRefTemp)\n       .keepCols([\"ts\",\"heat\"])\n  \n  // Join regression data and filter out missing gas data points\n  dataset: hisJoin([hdd.hisRollup(sum, 1day), \n                    usage.hisRollup(sum, 1day)])\n             // Filter out dates with missing gas data\n             .findAll(row => row.has(\"usage\"))\n   \n  // Create design matrix, specifically apply day type factoring\n  //   to HDD, to separate weekdays and weekends\n  regMatrix: dataset.map row => {\n    ts: row->ts,\n    hddWeekday: if(isWeekday(row->ts)) row->heat else 0,\n    hddWeekend: if(isWeekday(row->ts)) 0 else row->heat,\n    usage: row->usage\n  }\n       \n  // Isolate dependent and independent variables for regression\n  y: regMatrix.keepCols([\"usage\"])\n  x: regMatrix.keepCols([\"hddWeekday\",\"hddWeekend\"])\n\n  // Perform regression and extract coefficients\n  reg: matrixFitLinearRegression(y, x)\n  intercept: reg.meta[\"bias\"]\n  slopeWeekday: reg[0][\"b\"]\n  slopeWeekend: reg[1][\"b\"]\n\n  // Calculate fitted values using coefficients and join with dataset\n  slope: null\n  dataset = dataset.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->heat).as(refValue)\n    end)\n  \n  // Calculate statistics\n  measuredTotal: y.foldCol(\"usage\", sum)\n  n: reg.meta[\"rowCount\"]\n  measuredAvg: measuredTotal / n\n  sqError: dataset.addCol(\"se\", row => pow(row->fittedUsage - row->usage,2))\n                  .foldCol(\"se\", sum)\n  p: 2\n  mse: sqError / (n-p)\n  rmse: sqrt(mse)\n  cvrmse: rmse / measuredAvg\n  \n  // Build dictionary of results\n  regRes: {\n    intercept: intercept,\n    slopeWeekday: slopeWeekday,\n    slopeWeekend: slopeWeekend,\n    rSquared: reg.meta[\"r2\"],\n    n: n,\n    p: p,\n    measuredAvg: measuredAvg,\n    mse: mse,\n    rmse: rmse,\n    cvrmse: (cvrmse*100).as(1%),\n    ddRefTemp: ddRefTemp\n  }\n\n  // Apply day type factoring to usage, for graphing purposes\n  usage_factor: dataset.map row => {\n    ts: row->ts,\n    usageWeekday: if(isWeekday(row->ts)) row->usage else null,\n    usageWeekend: if(isWeekday(row->ts)) null else row->usage\n  }\n\n  // Create graph of data, scatter plot of usage vs HDD\n  graph: hisJoin([hdd, usage_factor])\n    // Keep only useful data for scatter plot\n    .keepCols([\"heat\",\"usageWeekday\",\"usageWeekend\"])\n    // Sort so scatter plot uses proper xmin and xmax\n    .sort(\"heat\")\n    // Calculate fitted values per day type to show regression results\n    .addCol(\"regressionWeekday\", row => if(row.has(\"heat\"))\n      (intercept+regRes[\"slopeWeekday\"]*row->heat).as(refValue)\n      else null)\n    .addCol(\"regressionWeekend\", row => if(row.has(\"heat\"))\n      (intercept+regRes[\"slopeWeekend\"]*row->heat).as(refValue)\n      else null)\n    // Reorder columns to control overlay\n    .reorderCols([\"heat\",\"regressionWeekend\",\"regressionWeekday\",\n                  \"usageWeekend\",\"usageWeekday\"])\n    // Add meta data to control graph display\n    .addColMeta(\"usageWeekday\", {chartType:\"scatter\", chartGroup:\"main\",\n                                 color:\"#1D80F1\"})\n    .addColMeta(\"usageWeekend\", {chartType:\"scatter\", chartGroup:\"main\",\n                                 color:\"#07203C\"})\n    .addColMeta(\"regressionWeekday\", {chartType:\"scatter\", chartGroup:\"main\",\n                                      color:\"#C7DFFB\"})\n    .addColMeta(\"regressionWeekend\", {chartType:\"scatter\", chartGroup:\"main\",\n                                      color:\"#C1C7CE\"})\n    .addMeta({title:titlePrefix+\"Daily gas usage vs HDD grouped by day type\"})\n    \n  // Return dict of: (dict) regression results, (grid) graph, (grid) dataset\n  return {results:regRes, graph:graph, dataset:dataset}\nend\n\n/*\n\nTest for calling a function in Axon by its tags. Can work, but cumbersome:\neval(read(func and regModel==\"dailyGasHDD\" and version==1 and apply)->name\n     +\"(parseRef(\\\"\"\n     +read(siteRef->dis==\"Campus Utility\" and gas and energy and point and \n       sensor)->id\n     +\"\\\"),2018-01-01..2018-01-28,\"\n     +(anRegGasDailyHDDv1(\n       read(siteRef->dis==\"Campus Utility\" and gas and energy and point and\n         sensor)->id,\n       2017-02-01..2018-01-28,\n       65°F)->results)\n     +\")\")\n\nEval argument looks like:\nanRegGasHddAv1(parseRef(\"p:lbnl:r:2204f59c-5e34a792\"),\n  2018-01-01..2018-01-28,\n  {intercept:1942.5582171226897,\n    slopeWeekday:258.6275333069492, \n    slopeWeekend:218.29285026361526, \n    rSquared:0.8963347812420092, \n    n:362, p:2, \n    measuredAvg:3980.441988950276therm, \n    mse:201978.87300901793, \n    rmse:449.4205970013145, \n    cvrmse:11.290720936240447%, \n    ddRefTemp:65°F})\n\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"roundHis",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec, dates) => do\n  his: rec.hisRead(dates)\n  \n  newHis:  his.map r=> do\n    {ts: r->ts,\n    v0: if (r[\"v0\"]!=null) (r[\"v0\"]*10).round / 10 else null}\n  end\n  \n  hisWrite(newHis, rec)\n  //return newHis\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends","toolHisGridShowGaps","toolRecursiveSearch"],,,,M,,,,,,"viPUETrends_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays PUE trends with formatting.\n  \n  Arguments:\n  equipRef       Ref to an equip\n  pointsRefs     list of point IDs, display history for those points\n  span           period to display\n  hisInterval    PUE interval used for calculation (specific to points)\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n  deficiencies   Bool, whether to show deficiencies on graph\n  rules          Bool, whether to display results of sparkrules\n*/\n\n(equipRef:null, pointsRefs:[], span:today()-3day..today()-1day, hisInterval:15min,\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null, rules:true) => do\n  if (pointsRefs==null) pointsRefs=[]\n  \n  gridE: try toolRecursiveSearch(equipRef,\n               \"(pue and sensor and his)\"+\n               \"or ((denominator or numerator) and sensor and his)\")\n         catch {}.toGrid()\n  \n  // Add hisInterval tag to PUE for proper calculation\n  if (not(isEmpty(gridE)))\n    gridE= gridE.map(row =>\n      if(row.has(\"pue\")) row.set(\"hisInterval\",hisInterval)\n      else row)\n  \n  gridP: try readByIds(pointsRefs)\n         catch {}.toGrid()\n         \n  gridA: if(isEmpty(gridP)) gridE else gridE.addRows(gridP)\n  try grid: gridA.hisRead(span, {limit:limit})\n                 .hisRollup(avg, hisInterval)\n                 .toolHisGridShowGaps(hisInterval*1.01)\n  catch return null\n\n  // Format trends\n  grid= grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\n \n  // Display active sparkRules results\n  if (rules) do\n    targets: [equipRef]\n    pointsRefs.each ptRef =>\n      targets= targets.add(readById(ptRef)[\"equipRef\"])\n    targets= targets.findAll(v => v!= null).unique()\n    \n    ruHis: ruleSparks(targets, span, readAll(sparkRule))\n           .ruleSparkHis()\n    \n    grid= hisJoin([grid, ruHis])\n  end\n\n  return grid.addMeta({title:\"NERSC PUE trends. Gaps greater than \"+round(hisInterval*1.01)+\" in any of the inputs are shown.\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viAhuZonePt",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, load chosen point for all TUs\n  served by that AHU then display the result on a heat map.\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  \n  rollup       duration, interval for rollup of ZAT\n  colors       Stru, used to override defaults, e.g. \"green, red\"\n*/\n\n(ahuRef, dates: yesterday(), ptStr:\"Heating Setpoint\",\n rollup: 15min, colors: null) => do\n  // Determine tags filter string based on ptStr selection\n  filterStr:\n    if (ptStr==\"Heating Setpoint\")\n      \"zone and air and temp and effective and heating and sp\"\n    else if (ptStr==\"Cooling Setpoint\")\n      \"zone and air and temp and effective and cooling and sp\"\n    else if (ptStr==\"Request - Colder SAT\")\n      \"cool and air and request and cmd\"\n    else if (ptStr==\"Request - Warmer SAT\")\n      \"heat and (general or air) and request and cmd\"\n    else if (ptStr==\"Ignored Requests - Colder SAT\")\n      \"cool and air and ignore and cmd\"\n    else if (ptStr==\"Ignored Requests - Warmer SAT\")\n      \"heat and (general or air) and ignore and cmd\"\n    else if (ptStr==\"Zone Temperature\")\n      \"zone and air and temp and sensor\"\n    else if (ptStr==\"Cooling PID\")\n      \"cool and pid and cmd\"\n    else if (ptStr==\"Discharge Air Temperature\")\n      \"discharge and air and temp and sensor\"\n    else if (ptStr==\"Fan Speed Command\")\n      \"(fan or equipRef->fan) and speed and cmd\"\n    else return null\n    \n  // Determine colors\n  colors=\n    if (colors != null) colors\n    else if (ptStr==\"Heating Setpoint\") \"#cccccc, #ff9999, #ff0033\"\n    else if (ptStr==\"Cooling Setpoint\") \"#3300ff, #9999ff, #cccccc\"\n    else if (ptStr==\"Request - Colder SAT\") \"white, blue\"\n    else if (ptStr==\"Request - Warmer SAT\") \"white, red\"\n    else if (ptStr==\"Ignored Requests - Colder SAT\") \"white, black\"\n    else if (ptStr==\"Ignored Requests - Warmer SAT\") \"white, black\"\n    else if (ptStr==\"Zone Temperature\") \"blue, palegreen, red\"\n    else if (ptStr==\"Cooling PID\") \"white, #dddddd, blue\"\n    else if (ptStr==\"Discharge Air Temperature\") \"white, orange, red\"\n    else if (ptStr==\"Fan Speed Command\") \"#B9B9B9,#98FB98,#89ED89,#7ADF7A,#6BD16B,#5DC35D,#4EB54E,#3FA73F,#309930,#228B22,#DD1313\"\n    else return null\n  \n  // Chart limits\n  if (ptStr==\"Heating Setpoint\") do\n    chartMin: 68°F\n    chartMax: 76°F\n  end else if (ptStr==\"Cooling Setpoint\") do\n    chartMin: 68°F\n    chartMax: 76°F\n  end else if (ptStr==\"Request - Colder SAT\") do\n    chartMin: 0\n    chartMax: 4\n  end else if (ptStr==\"Request - Warmer SAT\") do\n    chartMin: 0\n    chartMax: 4\n  end else if (ptStr==\"Ignored Requests - Colder SAT\") do\n    chartMin: 0\n    chartMax: 4\n  end else if (ptStr==\"Ignored Requests - Warmer SAT\") do\n    chartMin: 0\n    chartMax: 4\n  end else if (ptStr==\"Zone Temperature\") do\n    chartMin: 55°F\n    chartMax: 85°F\n  end else if (ptStr==\"Cooling PID\") do\n    chartMin: 0%\n    chartMax: 100%\n  end else if (ptStr==\"Discharge Air Temperature\") do\n    chartMin: 55°F\n    chartMax: 85°F\n  else if (ptStr==\"Fan Speed Command\") do\n    chartMin: 0%\n    chartMax: 100%\n  end else return null\n  \n  // Complete filter string\n  filterStr= filterStr + \" and equipRef->ahuRef==@\" + ahuRef\n  pts: readAll(parseFilter(filterStr))\n               \n  if(isEmpty(pts)) return null\n  \n  try do\n    pos: pts.hisRead(dates, {limit:null})\n    \n    if (rollup>0)\n      pos= pos.hisRollup(avg, rollup)\n    else\n      pos= pos.toolHisAlign(avg, max)\n    \n    pos=pos.hisFlatten((val, ts, his) => do\n        eq: readById(his->equipRef)\n        room: if (eq.has(\"equipRef\"))\n                readById(eq->equipRef)\n              else\n                eq\n        dis: if (readAll(supply and terminalUnit and equipRef==room->id).size >= 2)\n               room->navName + \" \" +\n               reGroups(\"\"\"(Supply,? )?(.*)\"\"\", eq->navName)[2]\n             else room->navName\n        {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n         rm: dis,\n         v0: val}\n    end)\n    .reorderCols([\"ts\",\"rm\",\"v0\"])\n    .addColMeta(\"v0\", {chartMin: chartMin,\n                       chartMax: chartMax})\n    .addMeta({view: \"chart\", chartType:\"heatMap\", \n              title: ptStr + \", zones served by \"\n                     + readById(ahuRef).dis() + \", \"\n                     + pos.meta[\"hisRollupInterval\"],\n              colors: colors})\n  catch (ex) do\n    pos: null\n  end\n  return pos\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldHisDiffMin",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, ts, acc) => do\n  if (val == foldStart()) return {vlast:na(), dmin: 0}\n  if (val == foldEnd()) return acc->dmin\n  if (val == na()) return na()\n  \n  if (acc->vlast == na()) return {vlast: val, dmin: 0}\n  return {vlast: val,\n          dmin: min(acc->dmin, (val - acc->vlast))}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldDiffAvg",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  // Initialization\n  if (val == foldStart())\n    return {last:na(), total:na(), samples:na()}\n  // Completion\n  if (val == foldEnd())\n    return acc[\"total\"] / acc[\"samples\"]\n    \n  // Special cases\n  if (val == na()) return na()\n  if (val == null) return na()\n  \n  // Special case for first record, can't compute diff\n  if (acc->last == na()) return {last: val, total:0, samples: 0}\n  \n  // Typical case\n  return {last: val,\n          total: acc->total + (val - acc->last),\n          samples: acc->samples + 1}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tempFixIPs",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  grid: readAll(bacnetConn and siteRef->dis==\"74\" and uri)\n  \n  re: r\"(bacnet://)(\\d{3}\\.\\d{1,}\\.\\d{1,}\\.\\d{1})(\\d{1}/.*)\"\n  bs: \"bacnet://128.3.66.13/2470608?dnet=24706&dadr=8\"\n  \n  result: []\n  \n  grid.each row => do\n    id: row->id\n    match: readById(id)->uri\n    test: reGroups(re, toStr(match))\n    var: (test[1] + \"131.243.251.2\" + test[3]).parseUri\n    diff(readById(id), {uri: var})  //.commit()\n  end\n\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneDeltaTemps"],,,,M,,,,,,"viAhuZoneDeltaTempsOcc",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, calculate the temperature deviation from zone temp\n  deadband for all TUs served by that AHU (using anAhuZoneDeltaTemps)\n  then display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), maxDev: 5°F, rollup: 15min, zoneIdList:null, filterUnocc:false) => do\n  devs: anAhuZoneDeltaTemps(ahuRef, dates, maxDev, rollup, zoneIdList, filterUnocc)\n  \n  try do\n    devs= devs\n        .findAll(r => r->ts.hour > 8 and r->ts.hour < 20)\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n                rm: if (ts.hour > 8 and ts.hour < 20) his->dis else null,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {unit:\"°F\",\n                           chartMin: maxDev * -1,\n                           chartMax: maxDev})\n        .addMeta({view: \"chart\", chartType:\"heatMap\",\n                  title: \"Deviation from deadband, zones served by \"\n                         +readById(ahuRef).dis() + \", 9 AM - 8 PM\",\n                  colors: \"blue, palegreen, red\"})\n  catch (ex) do\n    devs= null\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viMeterConsumption","toolFormatGrid"],,,,M,,,,,,"viMeterMonthlyList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a table of meter monthly consumption records formatted for display.\n  \n  Arguments: \n  siteRef             Ref<site>, siteRef filter\n  intervalCompare     Bool, if true and siteRef!=null, load interval data from\n                      meters and show measured consumption over monthly read\n                      spans of time for comparison.\n*/\n\n(siteRef:null, intervalCompare:false) => do\n  // Build title\n  title: \"Monthly consumption records, \"\n  if (siteRef!=null) do\n    prefix: if (parseNumber(readById(siteRef).dis,false)!=null) \"B\" else \"\"\n    title= title + prefix + readById(siteRef).dis\n  end else\n    title= title + \"all\"\n\n  // Initialize grid\n  grid: if(siteRef==null)\n          readAll(monthlyRead)\n        else\n          readAll(monthlyRead and meterRef->siteRef==siteRef)\n  \n  // Escape if no reads are found, to avoid grid manipulation errors\n  if (isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                        .addColMeta(\"dis\", {dis: title})\n\n  // If intervalCompare is true, and siteRef is provided, load and\n  // process available interval data\n  if (intervalCompare and siteRef!=null) do\n    grid= grid.addCol(\"prevReadDate\", cRow => do\n      pGrid: grid.findAll(row => row->meterRef==cRow->meterRef and\n                          row->readDate < cRow->readDate)\n      if (isEmpty(pGrid)) return null\n      else return pGrid.sortr((a,b) => a->readDate <=> b->readDate)\n                       .first->readDate\n    end)\n    \n    grid= grid.map(r => do\n      if (r[\"prevReadDate\"]==null) return r\n      startDate: r[\"prevReadDate\"]\n      endDate: r[\"readDate\"] - 1day\n      resDict: viMeterConsumption([r->meterRef], startDate..endDate, true)\n               .first\n      resDict.each((v,k) => r=r.set(k,v))\n      return r\n    end)\n    \n    if (grid.has(\"total\")) grid= grid.renameCol(\"total\", \"intervalConsumption\")\n    if (grid.has(\"uptime\")) grid= grid.renameCol(\"uptime\", \"intervalUptime\")\n  end\n\n  // Add title as id column display name\n  grid= grid.addColMeta(\"meterRef\", {dis:title})\n  \n  disCols: if (intervalCompare and siteRef!=null)\n             [\"meterRef\",\"readDate\",\"consumption\",\"intervalConsumption\",\n              \"intervalUptime\",\"mod\",\"ignore\",\"notes\"]\n           else\n             [\"meterRef\",\"readDate\",\"consumption\",\"mod\",\"ignore\",\"notes\"]\n  \n  return grid.toolFormatGrid(disCols)\n             .sortr((a,b) => a->readDate <=> b->readDate)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpImport06RHC",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  x: readLink(@p:lbnl:r:218d77af-da247d70).ioReadCsv\n  // skip column 0 which is ts\n  x.colNames[1..-1].each colName => do\n     pointDis: \"RHC-\"+colName[3..4]+\" ZAT\"\n     x.map(row => {ts: parseDateTime(row[\"timestamp_iso\"], \"YYYY-MM-DD hh:mm:SS\", \"Los_Angeles\"), val: parseFloat(row[colName])})\n       .hisWrite((readAll(point and zone and air and temp).find t => t.dis.contains(pointDis))->id)  \n  end\n  //\"RHC-\"+readLink(@p:lbnl:r:218c1890-17ab0854).ioReadLines[0..3].concat(\"\\n\").ioReadCsv.colNames[1][3..4]+\" ZAT\"\n  //readAll(point and zone and air and temp).findAll t => t.dis.contains((\"RHC-\"+readLink(@p:lbnl:r:218c1890-17ab0854).ioReadLines[0..3].concat(\"\\n\").ioReadCsv.colNames[1][3..4]+\" ZAT\"))\n  //readAll(point and zone and air and temp).find t => t.dis.contains((\"RHC-\"+readLink(@p:lbnl:r:218c1890-17ab0854).ioReadLines[0..3].concat(\"\\n\").ioReadCsv.colNames[1][3..4]+\" ZAT\"))\n  //p:lbnl:r:218c24c5-f879025c\n  //readLink(@p:lbnl:r:218c24c5-f879025c).ioReadCsv.map(row => {ts: parseDateTime(row[\"timestamp\"], \"YYYY-MM-DD hh:mm:SS\", \"Los_Angeles\"), val: parseFloat(row[\"rhc01ZAT\"])})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB34TRWTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:23514801-c3638d61,\n             @p:lbnl:r:235131d1-e1eaf423,\n             @p:lbnl:r:23513207-eb8a2341,\n             @p:lbnl:r:2351435d-c46a5987,\n             @p:lbnl:r:23514460-0d083d22,\n             @p:lbnl:r:23513490-1fc20f6a,\n             @p:lbnl:r:23514127-f3b02e61,\n             @p:lbnl:r:23514508-bf782705])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74ZoneTsi",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create zones\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b74/tsi_equip.csv`)\n  \n  siteDis: \"74\"\n  siteId: read(site and dis==siteDis)->id\n  \n  file.each row => do\n    floorDis: row[\"floor\"]\n    locationDis: \"B74 Floor \" + floorDis    \n    locationId: read(location and siteRef==siteId and\n                  dis==locationDis)->id\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    \n    exist: readAll(siteRef==siteId and \n                   locationRef==locationId and\n                   equip and\n                   navName==roomDis)\n    \n    uriText: row[\"bacnetAddress\"]\n    uri: parseUri(uriText)\n    connRef: read(conn and bacnetConn and uri==uri)->id\n                   \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: roomDis,\n         disMacro: \"\\\$locationRef \\\$navName\",\n         zone,\n         equip,\n         locationRef: locationId,\n         siteRef: siteId,\n         tmp2:today()\n        },\n        {add}\n      ))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"mapZoneLoadPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create up to two new points per supply terminal unit for a given site.\n  Conditions for creation of any point:\n  - ahuRef tag present at equip level\n  - zone air temp sensor point exists\n  - air flow sensor exists\n  \n  Conditions for creation of reheat load point:\n  - discharge air temp sensor point exists\n  - hotWaterHeat tag present at equip level\n*/\n\n(siteId) => do\n  tus: readAll(supply and terminalUnit and equip and siteRef==siteId)\n  tus.each tu => do\n    if (not(tu.has(\"ahuRef\"))) return null\n    if (read(zone and air and temp and sensor and equipRef==tu->id,false)\n        == null) return null\n    if (read(air and flow and sensor and equipRef==tu->id,false)\n        == null) return null\n        \n    // Create zone load point\n    zoneLoadPtDict: {\n      navName: \"Zone Load\",\n      disMacro: \"\\\$equipRef \\\$navName\",\n      equipRef: tu->id,\n      his,\n      kind: \"Number\",\n      locationRef: tu->locationRef,\n      point,\n      power,\n      sensor,\n      siteRef: tu->siteRef,\n      tz: \"Los_Angeles\",\n      unit: \"BTU/h\",\n      virtual,\n      zone,\n      tmp: today()\n    }\n    commit(diff(null, zoneLoadPtDict, {add}))\n    \n    if (read(discharge and air and temp and sensor and equipRef==tu->id,false)\n        == null) return null\n    if (not(tu.has(\"hotWaterHeat\"))) return null\n    \n    // Create reheat load point\n    reheatLoadPtDict: {\n      navName: \"Reheat Coil Load\",\n      disMacro: \"\\\$equipRef \\\$navName\",\n      coil,\n      equipRef: tu->id,\n      heat,\n      his,\n      kind: \"Number\",\n      locationRef: tu->locationRef,\n      point,\n      power,\n      sensor,\n      siteRef: tu->siteRef,\n      tz: \"Los_Angeles\",\n      unit: \"BTU/h\",\n      virtual,\n      tmp: today()\n    }\n    commit(diff(null, reheatLoadPtDict, {add}))\n  end  // tus.each tu\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid","viMeterMonthly","toolModelStats"],,,,M,,,,,,"viMeterMonthlyRegression",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display monhtly data graph associated with a regression of \n  monthly consumption data.\n  \n  Arguments: \n  monthlyRegressionRef    Id of a monthlyRegression record\n  postOverride            Str, \"Last 12 Months\" or \"FY 2019\"\n*/\n(monthlyRegressionRef, postOverride:\"\", view:\"Consumption\", disregardIgnore:false) => do\n  // Variables\n  monthlyRef: if (isRef(monthlyRegressionRef)) readById(monthlyRegressionRef)\n              else monthlyRegressionRef\n  meterRef: monthlyRef->meterRef\n  hddBase: monthlyRef[\"hddBase\"]\n  cddBase: monthlyRef[\"cddBase\"]\n  baseSpan: monthlyRef->baseSpan\n  postSpan: monthlyRef[\"postSpan\"]\n  normSpan: monthlyRef[\"normSpan\"]\n  meter: readById(meterRef)\n  weatherId: meter->siteRef->weatherRef\n  \n  // Retrieve data\n  grid: viMeterMonthly(meterRef,\n                       if (hddBase==null) 65°F else hddBase,\n                       if (cddBase==null) 55°F else cddBase,\n                       false,\n                       disregardIgnore)\n        .addMeta({title:meter.dis})\n  \n  // Unit\n  tUnit: grid[0][\"cons\"].unit\n  \n  // Remove HDD / CDD if unused\n  xCols: []\n  if (hddBase!=null) xCols= xCols.add(\"heat\")\n  if (cddBase!=null) xCols= xCols.add(\"cool\")\n  if (isEmpty(xCols))\n    return {error: \"Missing both HDD base temp and CDD base temp\"}.toGrid\n  \n  // Change postSpan if postDefault is true\n  if (postOverride==\"Post: Last 12 Months\")\n    postSpan= grid[-12][\"readDate\"]-1day..grid[-1][\"readDate\"]\n  if (postOverride==\"Post: FY 2019\")\n    postSpan= 2018-10-01..2019-09-30\n  \n  // Base model results\n  baseRes: grid\n           .findAll(r => baseSpan.toDateSpan.contains(r->readDate -1day))\n           .toolModelStats([\"consumptionPerDay\"], xCols)\n           .set(\"case\", \"Base\")\n  \n  // If model has a postSpan or postDefault is true, create post model\n  if (postSpan != null)\n    postRes: grid\n             .findAll(r => postSpan.toDateSpan.contains(r->readDate -1day))\n             .toolModelStats([\"consumptionPerDay\"], xCols)\n             .set(\"case\", \"Post\")\n  else postRes: null\n\n  // Add adjusted baseline to grid\n  grid= grid.addCol(\"adjustedBase\", row => do\n    // Begin with offset\n    v: baseRes->a\n    // Add coeffs based on HDD, CDD, as needed\n    xCols.each(xCol => v = v + baseRes[\"b\"+capitalize(xCol)] * row[xCol])\n    // Model is for unit/day, multiply by number of days for total consumption\n    v= v * row->countDays\n    // Force unit to original unit\n    v= v.as(tUnit)\n  end)\n\n  // Add adjusted baseline per day\n  grid= grid\n  .addCol(\"adjustedBasePerDay\",\n          row => row[\"adjustedBase\"] / row[\"countDays\"])  \n  \n  // Formatting\n  grid= grid\n  .addCol(\"basePeriod\", r =>\n            if (baseSpan.toDateSpan.contains(r->readDate-1day))\n              true\n            else false)\n  .addColMeta(\"basePeriod\",\n              {dis:\"Baseline Period\",\n               color: \"darkorange\",\n               chartGroup:\"2\",\n               chartType:\"runtime\",\n              })\n\n  .addColMeta(\"adjustedBasePerDay\",\n              {dis:\" \"+meter.dis+\", Weather-Adjusted Baseline Avg Daily Consumption\",\n               color: \"grey\",\n               chartGroup:\"1\",\n               chartType:\"bar\"\n              })\n              \n  // Add postPeriod if needed\n  if (postSpan != null) do\n    grid= grid\n    .addCol(\"postPeriod\", r =>\n              if (postSpan.toDateSpan.contains(r->readDate-1day))\n                true\n              else false)\n    .addColMeta(\"postPeriod\",\n                {dis:\"Post Period\",\n                 color: \"royalblue\",\n                 chartGroup:\"2\",\n                 chartType:\"runtime\",\n                 hisMode:\"cov\"\n                })\n  end\n\n  // Normalized consumption\n  if (normSpan==null) normSpan= 2012-01-01..2018-12-31\n  normGrid: {}.toGrid\n  normSpan.eachMonth(mo => do\n    normGrid= normGrid.addRow(\n      {readDate: mo.end,\n       heat: if (hddBase != null)\n               readById(weatherId)\n               .degreeDays(mo, hddBase)\n               .foldCol(\"heat\", sum),\n       cool: if (cddBase != null)\n               readById(weatherId)\n               .degreeDays(mo, cddBase)\n               .foldCol(\"cool\", sum),\n       countDays: mo.end - mo.start + 1day \n      })\n  end)\n  // Add normalized baseline\n  normGrid= normGrid.addCol(\"base\", row => do\n    // In normalized grid, heat and cool are total for the period, not /day\n    // Therefore only the intercept needs to be multiplied by countDays\n    v: (baseRes->a * row->countDays).as(1)\n    xCols.each(xCol => v = v + baseRes[\"b\"+capitalize(xCol)] * row[xCol])\n    v= v.as(tUnit)\n  end)\n  // Add normalized post\n  if (postRes!=null)\n    normGrid= normGrid.addCol(\"post\", row => do\n      v: (postRes->a * row->countDays).as(1)\n      xCols.each(xCol => v = v + postRes[\"b\"+capitalize(xCol)] * row[xCol])\n      v= v.as(tUnit)\n    end)\n\n  // Views\n  if (view==\"Consumption\")\n    return grid.keepCols([\"readDate\",\"basePeriod\",\"postPeriod\",\n                          \"consumptionPerDay\",\"adjustedBasePerDay\"])\n  else if (view==\"Scatter\") do\n    xVar: if (meter.has(\"gas\")) \"heat\" else \"cool\"\n    baseGrid: grid\n    .findAll(r => baseSpan.toDateSpan.contains(r->readDate-1day))\n    .keepCols([xVar,\"consumptionPerDay\"])\n    .renameCol(\"consumptionPerDay\",\"consumptionPerDayBase\")\n    .addColMeta(\"consumptionPerDayBase\",\n                {dis:\"Baseline Avg Daily Consumption\",\n                 color:\"darkorange\"})\n    if (postRes!=null) do\n      postGrid: grid\n      .findAll(r => postSpan.toDateSpan.contains(r->readDate-1day))\n      .keepCols([xVar,\"consumptionPerDay\"])\n      .renameCol(\"consumptionPerDay\",\"consumptionPerDayPost\")\n      .addColMeta(\"consumptionPerDayPost\",\n                  {dis:\"Post Avg Daily Consumption\",\n                   color:\"royalblue\",\n                   chartMin:0.as(tUnit)})\n      grid= join(baseGrid, postGrid, xVar)\n    end else grid= baseGrid\n    return grid.reorderCols(grid.colNames.moveTo(xVar,0))\n               .sort((a,b) => a[xVar] <=> b[xVar])\n               .addMeta({chartType:\"scatter\", title:null})\n  end else if (view==\"Stats\") do\n    results: [baseRes]\n    if (postRes!=null) results= results.add(postRes)\n    return results\n           .toGrid\n           .toolFormatGrid([\"case\",\"mape\",\"cvrmse\",\"n\"])\n  end else if (view==\"Normalized\") do\n    return normGrid.toolFormatGrid([\"readDate\",\"base\",\"post\"])\n  end else if (view==\"Savings\") do\n    if (postSpan==null) return null\n    grid= grid\n          .addCol(\"avoided\", row => row[\"adjustedBase\"] - row[\"cons\"])\n          .findAll(r => postSpan.toDateSpan.contains(r->readDate-1day))\n    normGrid= normGrid\n              .addCol(\"savings\", row => row[\"base\"] - row[\"post\"])\n    avoidedConsumption: grid.foldCol(\"avoided\", sum)\n    adjustedBaseline: grid.foldCol(\"adjustedBase\", sum)\n    normalizedSavings: normGrid.foldCol(\"savings\", sum)\n    normalizedBaseline: normGrid.foldCol(\"base\", sum)\n    // Normalizing to 365 days\n    normalizedSavings= normalizedSavings / normGrid.foldCol(\"countDays\", sum).as(1) * 365\n    normalizedBaseline= normalizedBaseline / normGrid.foldCol(\"countDays\", sum).as(1) * 365\n    return [{dis: \"Avoided Consumption\", value: avoidedConsumption},\n            {dis: \"Avoided Consumption (% of Adjusted Baseline)\", value: (avoidedConsumption/adjustedBaseline*100).as(\"%\")},\n            {dis: \"Adjusted Baseline\", value: adjustedBaseline},\n            {dis: \"Normalized Maintained Savings\", value: normalizedSavings},\n            {dis: \"Maintained Savings (% of Normalized Baseline)\", value: (normalizedSavings/normalizedBaseline*100).as(\"%\")},\n            {dis: \"Normalized Baseline\", value: normalizedBaseline},]\n           .toGrid()\n  end else return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateDeficiency","recValidateDeficiencyNote"],,,,M,,,,,,"recNewDeficiencyNote",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyNoteDict) => do\n  // Normalize action input\n  deficiencyNoteDict= actionNormInput(deficiencyNoteDict, \"dict\")\n  \n  if (deficiencyNoteDict.has(\"id\") and not(deficiencyNoteDict.has(\"deficiencyRef\")))\n  deficiencyNoteDict= deficiencyNoteDict\n    .set(\"deficiencyRef\", deficiencyNoteDict->id)\n  \n  deficiencyNoteDict= deficiencyNoteDict\n    .set(\"author\", userCur()->dis)\n   \n  deficiencyNoteDict= deficiencyNoteDict\n    .findAll((v,n) => [\"deficiencyRef\",\n                       \"equipRef\",\n                       \"timestamp\",\n                       \"deficiencyNote\",\n                       \"author\",\n                       \"timeSpent\",\n                       \"pictureLinks\"].contains(n))\n\n  // Validate record\n  deficiencyNoteDict= recValidateDeficiencyNote(deficiencyNoteDict)\n  \n  recNew(deficiencyNoteDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anHunting",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze a history grid and find periods of hunting, defined as periods\n  of at least minTime during which the rate of change is consistently\n  greater than maxChangePerMinute.\n  Return grid with periods of hunting.\n  \n  Arguments: \n  hisGrid            Grid of history data, with ts and v0 columns (others ignored)\n                     values should be percentages beteen 0% and 100%\n  maxChangePerMinute Allowed rate of change, default 5% (per minute)\n  mergePeriod        Merge sparks that are less than mergePeriod apart, default 30min\n  minTime            Minimum hunting time to be reported, default 30min\n*/\n\n(hisGrid, maxChangePerMinute: 5%, mergePeriod: 30min, minTime: 30min) => do\n  // Check that history is in %, otherwise return null\n  if (not hisGrid.has(\"v0\") or not hisGrid.col(\"v0\").meta.has(\"unit\")\n      or hisGrid.col(\"v0\").meta->unit != \"%\")\n    return null\n\n  // Remove unit from maxChangePerMinute for threshold to avoid unit issues\n  threshold: maxChangePerMinute.as(1)\n\n  // Initialize prev, previous values\n  prev: {ts: null, v0: null}\n  \n  // Calculate rate of change for hisGrid\n  rateGrid: hisGrid.map row => do\n    if (prev[\"ts\"] == null or prev[\"v0\"] == null) do\n      prev = {ts: row->ts, v0: row->v0}\n      return {ts: null, v0: null}\n    end else if (row->v0 == na()) do\n      // Return a row with na() as value, but do not change previous values\n      return {ts: row->ts, v0: row->v0}\n    end else if (prev->v0 == na()) do\n      // Return a row with na() as value, and change previous values\n      prev = {ts: row->ts, v0: row->v0}\n      return {ts: row->ts, v0: na()}\n    end else do\n      rChange: abs((row->v0 - prev->v0) / (row->ts - prev->ts).to(1min))\n      prev = {ts: row->ts, v0: row->v0}\n      return {ts: row->ts, v0: rChange}\n    end\n  end\n  // Remove null values, typically just leading row\n  .findAll(row => row[\"ts\"] != null and row[\"v0\"] != null)\n  // Remove na() values, corresponding to issues not related to this rule\n  .findAll(row => row[\"v0\"] != na())\n  \n  // Apply theshold\n  huntPeriods: rateGrid.hisFindPeriods v => v > threshold\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  huntPeriods = hisPeriodShift(huntPeriods, -mergePeriod/2, mergePeriod/2)\n  huntPeriods = hisPeriodShift(huntPeriods, mergePeriod/2, -mergePeriod/2)\n  huntPeriods = huntPeriods.findAll(r => r->v0 >= minTime)\n  \n  if (isEmpty(huntPeriods)) return null\n  \n  dis: huntPeriods.col(\"v0\").meta->navName + \" is hunting\"\n  return huntPeriods.addColMeta(\"v0\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolFormatGrid",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Reorders grid columns based on the order of provided column\n  names, and hides all other columns.\n  \n  Arguments:\n  grid            Grid to format\n  disColNames     Str[], specifies names and order of columns\n                  to display\n*/\n\n(grid, disColNames:null) => do\n  // Test inputs\n  if (grid==null or isEmpty(grid)) return grid\n  if (disColNames==null) disColNames= grid.colNames\n  \n  // Retrieve column names from grid and remove any display\n  // column name not found in the results\n  colNames: grid.colNames\n  disColNames.each v => do\n    if (not(colNames.contains(v)))\n      disColNames= disColNames.remove(disColNames.index(v))\n  end\n  \n  // Cycle through disColNames to:\n  // 1- Reorder grid columns according to disColNames order\n  // 2- Prepare list of columns to hide\n  hidColNames: colNames\n  disColNames.each((v,i) => do\n    colNames= colNames.moveTo(v,i)\n    hidColNames= hidColNames.remove(hidColNames.index(v))\n  end)\n  grid= grid.reorderCols(colNames)\n  \n  // Hide columns which name is not in disColNames\n  hidColNames.each v =>\n    grid= grid.addColMeta(v,{hidden})\n    \n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"anZoneAirflowDriver",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given zone, retrieve info regarding airflow setpoints and damper positions, \n  and determine what is driving the supply airflow setpoint at any given moment.\n  \n  Arguments: \n  zoneRef            Reference of zone equip\n  dates              Span, dates to run analysis on\n  minAfTolerance     Number, relative tolerance around min airflow setpoint to\n                     consider setpoint is at minimum\n  minRhvVent         Number in %, minimum reheat valve position to consider that\n                     ventilation requirements (min supply airflow sp) are driving airflows\n*/\n\n(zoneRef: @p:lbnl:r:239c4b07-18ee336a, dates: pastWeek(),\n minAfTolerance: 0.05, minRhvVent: 0%, rollup:15min,\n commErrorsAsNaN: true, filterZeros: true) => do\n  // Retrieve zone record\n  zone: readById(zoneRef)\n  \n  // Check that provided reference is for a zone equip\n  if (not(zone.has(\"zone\")))\n    return null\n  \n  // Retrieve needed values and points\n  saSps: toolRecursiveSearch(zoneRef, \"point and equipRef->supply and air and flow and effective and sp\")\n  saMins: {}.toGrid()//toolRecursiveSearch(zoneRef, \"point and equipRef->supply and min and air and flow and sp\")\n  zats: toolRecursiveSearch(zoneRef, \"point and equipRef->supply and zone and temp and sensor\")\n  gexDprs: toolRecursiveSearch(zoneRef, \"point and equipRef->exhaust and damper and cmd\")\n  rhVlvs: toolRecursiveSearch(zoneRef, \"point and equipRef->supply and heat and valve and cmd\")\n\n  // If sp is missing, return null\n  if (isEmpty(saSps)) return null\n  if (isEmpty(zats)) return null\n  \n  // Combine trends\n  saSp: saSps.hisRead(dates, {limit:null})\n             .hisMap(v => if ((filterZeros and v==0) or v==na()) null else v)\n             .hisInterpolate\n             .hisMap(v => if (v==null) na() else v)\n             .hisFoldCols(sum)\n             \n  if (isEmpty(saMins))\n    grid: saSp.addCol(\"v1\", row => zone[\"minAirflowSp\"])\n  else do\n    saMin: saMins.hisRead(dates, {limit:null})\n                 .hisMap(v => if ((filterZeros and v==0) or v==na()) null else v)\n                 .hisInterpolate\n                 .hisMap(v => if (v==null) na() else v)\n                 .hisFoldCols(sum)\n    grid: hisJoin([saSp, saMin])\n  end\n  \n  zat: zats.hisRead(dates, {limit:null})\n                 .hisMap(v => if (v==na()) null else v)\n                 .hisInterpolate\n                 .hisMap(v => if (v==null) na() else v)\n                 .hisFoldCols(avg)\n  grid= hisJoin([grid, zat])\n  \n  if (isEmpty(rhVlvs))\n    grid= grid.addCol(\"v3\", row => 0)\n  else do\n    rhVlv: rhVlvs.hisRead(dates, {limit:null})\n                 .hisMap(v => if (v==na()) null else v)\n                 .hisInterpolate\n                 .hisMap(v => if (v==null) na() else v)\n                 .hisFoldCols(avg)\n    grid= hisJoin([grid, rhVlv])\n  end\n  \n  if (isEmpty(gexDprs))\n    grid= grid.addCol(\"v4\", row => 0)\n  else do\n    gexDpr: gexDprs.hisRead(dates, {limit:null})\n                   .hisMap(v => if (v==na()) null else v)\n                   .hisInterpolate\n                   .hisMap(v => if (v==null) na() else v)\n                   .hisFoldCols(avg)\n    grid= hisJoin([grid, gexDpr])\n  end\n\n  grid= grid\n        .renameCol(\"v0\",\"saSp\")\n        .renameCol(\"v1\",\"saMin\")\n        .renameCol(\"v2\",\"zat\")\n        .renameCol(\"v3\",\"rhVlv\")\n        .renameCol(\"v4\",\"gexDpr\")\n        .hisRollup(avg, rollup)\n        .hisInterpolate\n        .findAll(row => row.remove(\"ts\").all(v => v != null and v != na()))\n  \n  // Evaluate modes of operation / what factor is driving airflow\n  grid= grid\n      .addCol(\"mode\", row => do\n        if((row[\"saSp\"] <= row[\"saMin\"] * (1+minAfTolerance))\n           and row[\"rhVlv\"] > minRhvVent) return \"minAirflowSp\"\n        if((row[\"saSp\"] > row[\"saMin\"] * (1+minAfTolerance))\n           and row[\"gexDpr\"]==0) return \"airflowOffset\"\n        if((row[\"saSp\"] > row[\"saMin\"] * (1+minAfTolerance))\n           and row[\"gexDpr\"]>0 and row[\"rhVlv\"]==0) return \"cooling\"\n        if((row[\"saSp\"] > row[\"saMin\"] * (1+minAfTolerance))\n           and row[\"gexDpr\"]>0 and row[\"rhVlv\"]>0) return \"heating\"\n        return \"unknown\"\n      end)\n  \n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolHisAlign",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*  \n  Process a history grid to align timestamps of contained histories, for example\n  in preparation for a foldCols. Determine average interval for each history, \n  then select a target interval for hisRollup. Rollup using given rollupFunc. \n  Process missing (null) values based on selected option.\n  NA values are propagated. Options for null values:\n  - Show missing values with NA\n  - Remove rows with any missing values\n  If any column / trend is COV with hisMode:\"cov\" tag, return original\n  grid if minRollup is 0, or apply hisRollup at provided minRollup.\n  \n  Arguments:\n  hisGrid          History grid to process\n  rollupFunc       Func, function used for rollup\n  intervalFunc     Func, (x,y) function used to select rollup interval\n  removeMissing    Bool, if true, remove rows with any null values,\n                   else replace all null values with NA\n  minRollup        Number (time), specify minimum rollup time\n  validIntervals   List of Numbers (time), valid rollup intervals\n*/\n\n(hisGrid, rollupFunc:avg, intervalFunc:min,\n removeMissing:true, minRollup:0min,\n validIntervals:[1s, 2s, 5s, 10s, 15s, 30s,\n                 1min, 2min, 3min, 5min, 10min, 15min, 30min,\n                 1hr, 2hr, 6hr, 12hr, 24hr]) => do\n  // Initialize\n  interval: null\n  covFlag: false\n  minRollup= try minRollup.to(\"s\") catch 0s\n  \n  // Cycle through each column and determine corresponding\n  // average interval\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    subHisGrid: hisGrid.keepCols([\"ts\"].add(colName))\n                       .hisClip\n                       .findAll(row => row[colName] != null)\n    if (subHisGrid.size < 2) return null\n    tsList: subHisGrid.colToList(\"ts\")\n    avgInterval: (tsList[-1] - tsList[0]) / (tsList.size - 1)\n    avgInterval= avgInterval.to(\"s\")\n    // Check metadata for hisMode==cov\n    if (subHisGrid.col(colName).meta[\"hisMode\"]==\"cov\")\n      covFlag= true\n    // Apply intervalFunc selection function\n    interval= if (interval==null) avgInterval\n              else intervalFunc(interval, avgInterval)\n  end\n  // If minRollup > 0, apply to interval\n  if (minRollup > 0) interval= max(interval, minRollup)\n  \n  // If some histories are COV and minRollup is specified,\n  // simply rollup at minRollup\n  if (covFlag and minRollup > 0)\n    hisGrid= hisGrid.hisRollup(rollupFunc, minRollup)\n  // Else if any history is COV and minRollup isn't specified, or if\n  // no interval was found do not rollup\n  else if (covFlag or interval==null or interval==0)\n    hisGrid= hisGrid\n  // Else select closest valid interval from validIntervals and rollup\n  else do\n    distF: (x,y) => abs(x.to(\"s\") - y.to(\"s\")).as(1)\n    finalInterval: validIntervals\n      .sort((a,b) => distF(a,interval) <=> distF(b,interval))\n      .first\n    \n    // Perform rollup\n    hisGrid= hisGrid.hisRollup(rollupFunc, finalInterval)\n  end\n  \n  // Process missing data\n  if (removeMissing)\n    hisGrid= hisGrid.findAll(row => row.all(v => v != null))\n  else // Show missing values with NA\n    hisGrid= hisGrid.hisMap(v => if (v==null) na() else v)\n\n  return hisGrid\nend\n\n/*\n  Updates\n  2020-01-21  Raphael Vitti\n    Added default rollup of cov series if minRollup is provided.\n*/",,
,["psyWetBulb"],,,,M,,,,,,"ptWetBulbfromDewPoint",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate wet bulb temperatureure history from histories of\n    dry bulb temperature, dew point and ambient pressure\n*/\n\n(rec, dates, opts, yield) => do\n  // Retrieve needed values from other histories associated with same weather station\n  dryBulb: read(weatherPoint and main and air and temp and sensor and weatherRef==rec->weatherRef).hisRead(dates, {limit: null})\n  dewPoint: read(weatherPoint and dew and temp and sensor and weatherRef==rec->weatherRef).hisRead(dates, {limit: null})\n  ambPressure: read(weatherPoint and barometric and pressure and sensor and weatherRef==rec->weatherRef).hisRead(dates, {limit: null})\n  \n  // Join grids and interpolate null values\n  inputGrid: hisJoin([dryBulb, dewPoint, ambPressure], {limit: null}).hisInterpolate({limit: null})\n  \n  // For each timestamp, calculate wet bulb temperature and return pair\n  inputGrid.each row => yield(ts: row->ts, v0: psyWetBulb(row->v0, row->v1, row->v2))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptMetricsCoolingSystemPpue"],,,,M,,,,,,"viTUEAndWetBulb",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return trends of TUE and OA WB Temp (in °F) data at B59\n*/\n\n(dateRange: toDateSpan(2019-06-01..2019-09-01),\n minCompPower: null, maxCompPower: null,\n suffix:\"\") => do\n  // Default to B59 for siteRef\n  bldgRef: read(site and dis==\"59\")\n  bldgRefId: bldgRef->id\n   \n  // Look up B59 Data Center compute power, used later for filtering\n  totalCompRef: read(locationRef->dis==\"B59 Data Center\"\n                     and superComputer and navName==\"Computers\")->id\n  totalCompMeterRef: read(meter and compute and equipRef==totalCompRef)->id\n  totalCompPower: read(power and sensor and point and equipRef==totalCompMeterRef)\n\n  // Get the TUE point for this siteRef and hisInterval\n  tue: read(siteRef==bldgRefId \n            and hisFunc==\"ptMetricsCoolingSystemPpue\"\n            and point)\n  \n  // Get the PUE trend for the given range\n  tueTrend: hisRead(tue, dateRange, {limit:null})\n            .renameCol(\"v0\",\"tue\"+suffix)\n  \n  // Get the reference for the TW Plant (for wetbulb)  \n  twPlantEquip: read(siteRef==bldgRefId\n                     and equip\n                     and condenserWaterPlant\n                     and navName == \"Plant\")\n                    \n  //wetbulb temperature (defaulting to the same location as the default)\n  wbTemp: read(equipRef==twPlantEquip->id and outside and point and sensor and wetBulb)\n          .hisRead(dateRange, {limit:null})\n          .renameCol(\"v0\",\"oaWetBulb\")\n  \n  // join trends\n  allTrends: hisJoin([wbTemp, tueTrend])\n   \n  // determine valid period based on compute power filter\n  filterPeriod: hisRead(totalCompPower, dateRange, {limit:null})\n                .hisFindPeriods(v => (minCompPower==null or v >= minCompPower)\n                                     and (maxCompPower==null or v <= maxCompPower))    \n   \n  // Apply filter to grid\n  grid: allTrends.hisFindInPeriods(filterPeriod)\n  return(grid)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Lagged History",,M,,,,,,"hisTimeCompare_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(point, dates, duration) => do\n  // Read data from current historian display, get meta info needed for proper display\n  r_current: point.hisRead(dates)\n  his_meta: r_current.meta\n  \n  // Read data from earlier, shift timestamps to current historian display\n  r: point.hisRead(dates - duration)\n  list_ts: colToList(r,\"ts\")\n  list_v1: colToList(r,\"v0\")\n  list_ts0: list_ts.map s => s + duration\n  r_combined: list_ts0.toGrid.map( (row,index) => {ts:row->val, v0:list_v1[index]} )\n  \n  // Set meta information of grid for proper display\n  point_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"dis\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  r_comb_meta: r_combined.addMeta(his_meta).addMeta({dis: \"LAGGED \"+duration+\" \"+point_dis})\n  r_out: r_comb_meta.addColMeta(\"v0\", {dis: duration+\" earlier: \"+v0_dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid","toolSummarizeCol"],,,,M,,,,,,"viDeficienciesPlanning",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a table of deficiencies formatted for display; group together all the\n  deficiencies with the same deficiencyGroupRef + sprintRef + siteRef and summarize\n  assignedTo, state, size, count, energyValue, operationalValue and dates for\n  these grouped deficiencies. Summaries are created with toolSummarizeCol func.\n  state, energyValue and operationalValue have custom priority lists for rollup.\n  \n  Arguments: \n  state         Str, state filter, can be \"Any\", \"Active\", \"Not Closed\" or any\n                specific deficiency state string\n  sprintRefs    Ref<sprint>[], sprintRef filter\n  siteRef       Ref<site>, siteRef filter\n  assignedTo    Str, assignedTo filter, can be \"\"\n  filter        Str, filter on deficiency dis and group dis, case insensitive\n  groupLink     Str, Overview or List\n*/\n\n(state:\"Any\", sprintRefs:null, siteRef:null, assignedTo:\"\", filter:\"\",\n groupLink:\"Overview\") => do\n  // Determine current and previous sprints\n  sortedSpr: readAll(sprint)\n             .sortr((a,b) => a->sprint <=> b->sprint)\n  currentSpr: sortedSpr[0]\n  previousSpr: sortedSpr[1]\n  // Process sprintRefs\n  if (sprintRefs != null)\n    sprintRefs= sprintRefs\n    .map(sId => if (readById(sId)->sprint==-1) previousSpr->id\n                else if (readById(sId)->sprint==0) currentSpr->id\n                else sId) \n\n  // Build title\n  title: \"Deficiencies (\" + state + \")\"\n  if (assignedTo!=\"\" and assignedTo!=\"Any\")\n    title= title + \", for \" + assignedTo\n  if (sprintRefs!=null) do\n    sprintNums: sprintRefs.map(v => readById(v)->sprint.toStr)\n    if (sprintNums.size > 1) title= title + \", Sprints \"\n    else title= title + \", Sprint \"\n    title= title+ sprintNums.concat(\", \")\n  end\n  if (siteRef!=null) do\n    prefix: if (parseNumber(readById(siteRef).dis,false)!=null) \"B\" else \"\"\n    title= title + \", \" + prefix + readById(siteRef).dis\n  end\n\n  // Initialize grid\n  grid: if(siteRef==null)\n          // All deficiencies\n          readAll(deficiency)\n        else\n          // Or all deficiencies associated with selected site\n          readAll(deficiency and siteRef==siteRef)\n  \n  // Escape if no deficiencies are found, to avoid grid manipulation errors\n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n                                       \n  \n  // Apply deficiency state filter\n  grid= grid.findAll(row => if(state==\"Any\") true\n                            else if(state==\"Active\")\n                              [\"To Do\",\"In Progress\"].contains(row->state)\n                            else if(state==\"Not Closed\")\n                              not([\"Closed\",\"Abandoned\"].contains(row->state))\n                            else row->state==state)\n  \n  // Apply sprintRef filter\n  grid= grid.findAll(row => if(sprintRefs==null) true\n                            else sprintRefs.contains(row[\"sprintRef\"]))\n\n  // Escape if no deficiencies are left, to avoid grid manipulation errors\n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n                                       \n  // Add display column and link column\n  grid= grid.addCol(\"dis\", row => row.dis())\n            .addCol(\"link\", row => uiLink({view: \"deficiencyView\",\n                                           state:{deficiencyRef:row->id}}))\n  \n  // Group by deficiencyGroupRef + sprintRef + siteRef\n  if (grid.has(\"deficiencyGroupRef\"))\n    grid.colToList(\"deficiencyGroupRef\").unique.each grp => do\n      // Cycle on each unique group\n      if (grp != null) do\n        // Create sub-selection grid based on deficiency group\n        sub: grid.findAll(d => d[\"deficiencyGroupRef\"]==grp)\n        sprList: if (sub.has(\"sprintRef\")) sub.colToList(\"sprintRef\").unique else [null]\n        sprList.each spr => do\n          // Cycle on each unique sprintRef, create second sub-selection\n          sub2: sub.findAll(d => d[\"sprintRef\"]==spr)\n          sprDis: if (spr==null) \"\" else \", Sprint \"+readById(spr).dis()\n          sub2.colToList(\"siteRef\").unique.each siteRef => do\n            // Cycle on each unique siteRef, create third sub-selection\n            sub3: sub2.findAll(d => d[\"siteRef\"]==siteRef)\n            // Find or create deficiencyGroupSet with (siteRef, sprintRef, deficiencyGroupRef)\n            dGroupSet: readAll(deficiencyGroupSet and siteRef==siteRef and\n                               deficiencyGroupRef==grp)\n            dGroupSet= if (isEmpty(dGroupSet)) null\n                       else dGroupSet\n                            .find(dG => dG[\"sprintRef\"]==spr, false)\n            if (dGroupSet==null)\n              dGroupSet= commit(diff(null,\n                                     {deficiencyGroupSet,\n                                      siteRef: siteRef,\n                                      sprintRef: spr,\n                                      deficiencyGroupRef: grp},\n                                     {add}))\n            // Give summary row the id of the deficiencyGroupSet\n            dGroupSetId: dGroupSet->id\n            // Group by state, cycle through state groups\n            [[\"In Progress\",\"To Do\",\"Pending\"],\n             [\"New\",\"Backlog\",\"In Consideration\"],\n             [\"Resolved\",\"Closed\",\"Abandoned\"]].each sts => do\n              sub4: sub3.findAll(d => sts.contains(d[\"state\"]))\n              if (not(isEmpty(sub4))) do\n                count: sub4.size\n                // Prefix for building display, add B only if site dis is a number\n                prefix: if (parseNumber(readById(siteRef).dis,false)!=null) \"B\" else \"\"\n                // Deficiency summary name is based on site, group and sprint\n                dis: prefix+readById(siteRef).dis + \" \" + readById(grp).dis() + sprDis\n                // Summary state with priority (New supercedes all other states, etc.)\n                state: sub4.toolSummarizeCol(\"state\",\n                         [\"New\",\"In Progress\",\"To Do\",\"Pending\",\"Backlog\",\"Resolved\",\"Closed\",\"In Consideration\",\"Abandoned\"])\n                sprintRef: spr\n                // Total size for group\n                size: if (sub4.has(\"size\")) sub4.colToList(\"size\")\n                                            .findAll(v => v!=null and isNumber(v))\n                                            .fold(sum)\n                      else null\n                // Summary assignedTo\n                assignedTo: sub4.toolSummarizeCol(\"assignedTo\")\n                // Summary energyValue, operationValue and priority with priority list\n                energyValue: sub4.toolSummarizeCol(\"energyValue\",\n                               [\"Maintenance\",\"High\",\"Medium\",\"Low\",\"None\"])\n                operationalValue: sub4.toolSummarizeCol(\"operationalValue\",\n                                    [\"High\",\"Medium\",\"Low\",\"None\"])\n                priority: sub4.toolSummarizeCol(\"priority\",\n                                    [\"High\",\"Medium\"])\n                                    \n                // Earliest startDate\n                startDate: if (sub4.has(\"startDate\") and not(sub4.colToList(\"startDate\").contains(null)))\n                             sub4.colToList(\"startDate\")\n                                 .sort((a,b) => a <=> b)\n                                 .first\n                           else null\n                // Latest endDate\n                endDate: if (sub4.has(\"endDate\") and not(sub4.colToList(\"endDate\").contains(null)))\n                           sub4.colToList(\"endDate\")\n                               .sortr((a,b) => a <=> b)\n                               .first\n                         else null\n                // Remove all rows being summarized (site + group + sprint)\n                grid= grid.findAll(d => not(d[\"deficiencyGroupRef\"]==grp and\n                                            d[\"siteRef\"]==siteRef and\n                                            d[\"sprintRef\"]==spr))\n                // Add link to deficiencies list showing only the selected group\n                groupViewUrl: uiLink({view: if (groupLink==\"Overview\") \"deficienciesOverview\"\n                                            else \"deficienciesList\",\n                                      state:{groupRef:grp,\n                                             siteRef:siteRef,\n                                             sprintRefs: if (spr!=null) [spr] else null,\n                                             state:state}})\n                // Add summary row for current grouping\n                grid= grid.addRow({id: dGroupSetId,\n                                   dis: dis,\n                                   state:state,\n                                   sprintRef:sprintRef,\n                                   size: size,\n                                   assignedTo: assignedTo,\n                                   count:count,\n                                   energyValue: energyValue,\n                                   operationalValue: operationalValue,\n                                   priority: priority,\n                                   startDate:startDate,\n                                   endDate: endDate,\n                                   deficiencyGroupRef:grp,\n                                   link: groupViewUrl,\n                                   siteRef:siteRef})\n              end\n            end\n          end\n        end\n      end\n    end\n  \n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n  \n  // Filter by assignedTo\n  grid= grid.findAll(row =>\n      if (assignedTo==\"Any\") return true\n      else if (row[\"assignedTo\"]==null) false\n           else reMatches(\".*\"+assignedTo+\".*\", row[\"assignedTo\"]))\n  \n  // Text filter on deficiency display name + group's display name\n  grid= grid.findAll(row => do\n    groupDis: if(row[\"deficiencyGroupRef\"]!=null)\n                readById(row[\"deficiencyGroupRef\"]).dis()\n              else \"\"\n    // Regex with ?i flag is NOT case sensitive\n    return reMatches(\"(?i).*\"+filter+\".*\", row.dis() + groupDis)\n  end)\n\n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n\n  // Convert mod to Los_Angeles tz\n  grid= grid.map(row => row.map((v,n) => if (n==\"mod\" and v != null)\n                                           v.toTimeZone(\"Los_Angeles\")\n                                         else v))\n  // Add filter summary in first column name\n  grid= grid.addColMeta(\"dis\", {dis: title})\n  \n  disCols: [\"dis\",\"state\",\"sprintRef\",\"size\",\"assignedTo\",\n            \"count\",\"energyValue\",\"operationalValue\",\"priority\",\n            \"startDate\",\"endDate\",\"link\"]\n  \n  // Sort on display name\n  grid= grid.sort((a,b) => a.dis() <=> b.dis())\n  \n  // Return formatted grid showing disCols only, in order\n  return grid.toolFormatGrid(disCols)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"hisReadMetasysSql",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n( sqlConn, point, dates ) => do\n\n  //Need to add some error checking\n  //if not point->equipRef->ionSqlConn then return False???\n  //NOTE that Metasys-NIE2 is also Metasys9-NIE2 in tblPointName, but not in the bacnetName when autodiscovering points. May be due to when Ramesh renamed the NIE\n\n  // Ask sql for UTC datetimes in text format, so it doesn't get inadvertently converted by JDBC\n  sql:       \"SELECT AVF.ActualValue AS val, CONVERT(varchar, AVF.UTCDateTime, 120) AS ts\" +\n             \" FROM JCIHistorianDB.dbo.tblPoint P, JCIHistorianDB.dbo.tblPointSlice PS, JCIHistorianDB.dbo.tblActualValueFloat AVF\" + \n             \" WHERE P.pointID = PS.PointID\" + \n             \" AND P.PointName LIKE '%\" + point->bacnetName + \"%'\" + \n             \" AND PS.pointSliceID = AVF.pointSliceID\" +\n             \" AND CONVERT(varchar, AVF.UTCDateTime, 120) >= '\" + dates.start.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n             \" AND CONVERT(varchar, AVF.UTCDateTime, 120) < '\" + dates.end.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n             \" UNION \" + \n             \"SELECT AVD.ActualValue AS val, CONVERT(varchar, AVD.UTCDateTime, 120) AS ts\" +\n             \" FROM JCIHistorianDB.dbo.tblPoint P, JCIHistorianDB.dbo.tblPointSlice PS, JCIHistorianDB.dbo.tblActualValueDigital AVD\" + \n             \" WHERE P.pointID = PS.PointID\" + \n             \" AND P.PointName LIKE '%\" + point->bacnetName + \"%'\" + \n             \" AND PS.pointSliceID = AVD.pointSliceID\" +\n             \" AND CONVERT(varchar, AVD.UTCDateTime, 120) >= '\" + dates.start.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n             \" AND CONVERT(varchar, AVD.UTCDateTime, 120) < '\" + dates.end.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n             \" ORDER BY ts ASC\"\n\n  data: read(dis==\"metasysDB\").sqlQuery(sql)\n\n\n  // Add \"UTC\" to tz-naive text strings from sql, then parse and convert to Los_Angeles time zone\n  mapped: if(point->kind==\"Bool\") do\n            data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                  .toTimeZone(\"Los_Angeles\"),\n                              val: if(row->val==1) true else false }\n            end\n            else do\n            data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                  .toTimeZone(\"Los_Angeles\"),\n                              val: (row->val) }\n            end\n\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recSprintSnap"],,,,M,,,,,,"recNewSprint",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  // Take a snapshot of work units for the most recent sprint\n  recSprintSnap()\n\n  // Find latest sprint (highest number)\n  latestNumber: readAll(sprint)\n                .sortr((a,b) => a->sprint <=> b->sprint)\n                .first->sprint\n  \n  // New sprint dictionary\n  newSprintDict: {sprint: latestNumber+1,\n                  disMacro:\"\\\$sprint\"}\n\n  // Commit\n  recNew(newSprintDict)\n  \n  // Find new sprint\n  newSprintRef: readAll(sprint)\n                .sortr((a,b) => a->sprint <=> b->sprint)\n                .first->id\n\n  // Move all active deficiencies to new sprint\n  readAll(deficiency)\n  .findAll(row =>\n      [\"To Do\",\"In Progress\"].contains(row->state))\n  .each(d => commit(diff(d, {sprintRef: newSprintRef})))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolFuncDependencies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Update the function dependencies of all functions and views in project,\n  by scanning the function src for other function names. Store function\n  names as list in 'depends' tag of function or view.\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  readAll(func or view)\n  .map(f => {id:f->id,\n             depends:readAll(func)\n                    .findAll(func=>f->src.contains(func->name))\n                    .colToList(\"name\"),\n            })\n  .each(f => commit(diff(readById(f->id), {depends: f->depends})))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"writeHisFuncRef",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function processes all points with a hisFuncRef tag, and stores,\n into each point's history, the history of the point referenced by hisFuncRef.\n*/\n\n() => do\n  startDateDefault: date(2019,01,01)\n  pts: readAll(point and hisFuncRef)\n  \n  pts.map(pt => do\n    startDate: if (pt.has(\"hisEnd\")) pt->hisEnd.date() else startDateDefault\n    hisGrid: readById(pt->hisFuncRef).hisRead(startDate..today(),{limit:null})\n    \n    filteredGrid:\n    if (pt.has(\"hisEnd\"))\n        hisGrid.findAll(row => row->ts > pt->hisEnd)\n    else\n        hisGrid\n    \n    // Remove null values everywhere\n    filteredGrid= filteredGrid.findAll(row => row.all(v => v!=null))\n    \n    // Remove NA values when at the end of the range\n    lastValid: filteredGrid.findAll(row => row.all(v => v!=na()))\n    if (isEmpty(lastValid)) return {pt: pt->id, written: 0, status: \"No new data\"}\n    lastValid= lastValid.sort((a,b) => a->ts <=> b->ts)\n                        .last->ts\n    filteredGrid= filteredGrid.findAll(row => row->ts <= lastValid)\n    \n    // Write data to history.\n    hisWrite(filteredGrid, pt)\n    return {pt: pt->id, written: filteredGrid.size, status: \"OK\"}\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viSubmeters",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display a stacked bar chart showing the breakdown of energy or volume\n  over a given period for a given meter into the usage of its\n  submeters or meters from served systems. Also displays a line chart showing the\n  meter usage and the difference between the meter value and the total of sub-values.\n\n  Arguments: \n*/\n\n(meterRef:read(siteMeter and elec and meter and siteRef->dis==\"30\")->id,\n span:pastMonth(), stacked:true, dayType:\"All\") => do\n    // Parameters\n    interval: 1h\n    \n    // Inline functions\n    maxRound: x => do y:if(x<100) 10 else if(x<250) 50 else 100; ceil(x/y)*y end\n    \n    // If no submeters, exit\n    ptType: if (stacked) \"energy and delta and not hidden\" else \"power and not hidden\"\n    filterStr: ptType + \" and (equipRef->submeterOf==@\" + meterRef\n                      + \" or equipRef->meterRef==@\" + meterRef + \")\"\n    submeterPts: readAll(parseFilter(filterStr))\n    if (isEmpty(submeterPts))\n        return {empty: \"The selected meter has no submeter\"}\n               .toGrid()\n    unit: submeterPts.first->unit\n \n    // Main meter history\n    meterUsage: read(energy and delta and not hidden and equipRef==meterRef)\n    mHis: meterUsage.hisRead(span, {limit: null})\n                    .findAll(row => if (dayType==\"All\") true\n                                    else if (dayType==\"Weekday\") isWeekday(row->ts)\n                                    else isWeekend(row->ts))\n                    .hisRollup(if(stacked) sum else avg, interval)\n                    .hisDailyProfile(avg)\n                    .map(row => {time: time(row->time.hour(),30), v0: row->v0})\n    cMax: mHis.foldCol(\"v0\",max).maxRound()\n \n    submHis: submeterPts.hisRead(span, {limit: null})\n    submHis= submHis.findAll(row => if (dayType==\"All\") true\n                                    else if (dayType==\"Weekday\") isWeekday(row->ts)\n                                    else isWeekend(row->ts))\n    colNames: submHis.colNames.findAll(v => v != \"ts\")\n    \n    // Prepare chart\n    submStackedHis: submHis.hisRollup(if(stacked) sum else avg, interval)\n                           .hisDailyProfile(avg)\n    colNames.each colN => do\n      col: submStackedHis.col(colN)\n      submStackedHis= submStackedHis.addColMeta(colN,\n        {chartType: if (stacked) \"stackedBar\" else \"line\",\n         dis: reGroups(r\".* - (.*)\", col.meta->equipRef->navName)[1],\n         chartGroup: \"breakdown\",\n         chartMin: 0.as(unit),\n         chartMax: if(stacked) cMax.as(unit) else null\n        })\n    end\n    \n    title: if (stacked) readById(meterRef).dis + \", \" + dayType\n                + \"average usage profile and stacked disaggregation\" \n           else \"Submeters of \" + readById(meterRef).dis + \", \" + dayType\n                + \"average power profile\"\n    \n    submStackedHis= submStackedHis.addMeta({title: title})\n        \n    if (not(stacked)) return submStackedHis\n    \n    // Prepare line chart with aggregation error    \n    combinedDailyHis: submHis.hisRollup(if(stacked) sum else avg, interval)\n                             .hisDailyProfile(avg)\n                             .foldCols(colNames, \"combined\", sum)\n                             .map(row => {time: time(row->time.hour(),30),\n                                          combined: row->combined})\n                    \n    combinedHis: hisJoin([combinedDailyHis, mHis])\n                 .addCol(\"error\", row => row[\"v0\"]-row[\"combined\"])\n                 .addColMeta(\"v0\", {\n                     dis: \"Meter, selected\",\n                     chartGroup: \"breakdown\",\n                     chartMin: 0.as(unit),\n                     chartMax: cMax.as(unit),\n                     color:\"#000000\"})\n                 .addColMeta(\"combined\", {\n                     dis: \"Submeters, combined\",\n                     chartGroup: \"lines\",\n                     chartMin: 0.as(unit)})\n                 .addColMeta(\"error\", {\n                     dis: \"Total unmetered or error\",\n                     chartType: \"area\",\n                     chartGroup: \"lines\",\n                     chartMin: 0.as(unit),\n                     chartMax: cMax.as(unit),\n                     color: \"#e85c5c\"})\n                 .removeCol(\"combined\")\n    \n    return hisJoin([submStackedHis,combinedHis])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateTagSet",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  // Enforce required fields\n  if (rec.missing(\"dis\"))\n    throw \"A display name (dis) is required\"\n  if (rec.missing(\"ptTags\"))\n    throw \"A comma-separated string with a list of tags is required\"\n  if (rec.missing(\"tagCategoryRef\"))\n    throw \"A tagCategory is required\"\n\n  // Test tags\n  try do\n    rec->ptTags.split(\",\")\n    if (rec.has(\"eqTags\")) rec->eqTags.split(\",\")\n  catch\n    throw \"ptTags and eqTags must be comma-separated strings\"\n\n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"viPlantInVOut",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find input and output power points under a certain system.\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n  addedPtRecs      Optional, grid of additional points to show on graph\n*/\n\n(sysRef:null, dates: today) => do\n  // Default to B59 TW Sys if no ref is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and navName==\"TW Sys\")->id\n\n  // Get all power sensor points under sysRef (recursive)\n  // All input powers must be in kW and not on a load meter\n  // Output power is from a load meter\n  inputPowerPts: toolRecursiveSearch(sysRef,\n                   \"point and power and sensor and unit==\\\"kW\\\"\" +\n                   \" and not equipRef->load and not equipRef->meter\")\n  outputPowerPts: toolRecursiveSearch(sysRef,\n                    \"point and power and sensor\" +\n                    \" and equipRef->load and equipRef->meter\")\n\n  // Interpolate, filter and calculate total input and output power\n  inputPowers: hisRead(inputPowerPts,dates,{limit:null})\n                 .hisInterpolate\n                 .findAll(row => row.all(v => v != null))\n  outputPowers: hisRead(outputPowerPts,dates,{limit:null})\n                  .hisInterpolate\n                  .findAll(row => row.all(v => v != null))\n\n  totalInputPower: inputPowers.hisFoldCols(sum).renameCol(\"v0\",\"in\")\n  totalOutputPower: outputPowers.hisFoldCols(sum).renameCol(\"v0\",\"out\")\n                                .hisMap(v => if (v != null) v.to(\"kBTU/h\"))\n\n  //convert totalOutputPower to kW\n  totalOutputPower= totalOutputPower.addCol(\"out_kW\",\n      row => if(row->out == null) null else row->out.to(\"kW\"))\n\n  // Join input and output, then calculate effectiveness\n  totals: hisJoin([totalInputPower,totalOutputPower])\n            .hisInterpolate\n            .findAll(row => row.all(v => v != null))\n\n  metric: keepCols(totals, [\"ts\",\"sysCOP\",\"in\",\"out\"])\n            .addColMeta(\"in\",\n              {dis: readById(sysRef).dis + \" Total Input Power (kW)\",\n               unit: \"kW\", chartGroup: \"p\", color: \"#ba7c00\"})\n            .addColMeta(\"out\",\n              {dis: readById(sysRef).dis + \" Total Plant Load (kBTU/h)\",\n               unit: \"kBTU/h\", chartGroup: \"p\", color: \"#42b6f4\"})\n  \n  return metric\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap34PCHW3CH",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point stored in `io/integration_b34/b34_pchw_3ch.csv`\n to add these points to existing equips.\n \n This file includes a match to the 2018-09-10 tagging standard for the\n purpose of associating the proper tags and navName to each point.\n Also includes equip id.\n*/\n\n(finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b34/b34_pchw_tw.csv`)\n  \n  siteId: @p:lbnl:r:22c3f305-88d0e22e\n  connectorId: @p:lbnl:r:2329d28f-bcff2683\n  \n  bacnetPtList: [null, null, null, null, null, null]\n  bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\"]\n  \n  [0,2,3,4,5].each type => do\n    bacnetLearn(connectorId)\n    learn: bacnetLearn(connectorId, type)\n    bacnetPtList= bacnetPtList.set(type, learn)\n  end\n  \n  return bacnetPtList\n  \n  alcPtList= alcPtList.addCol(\"newPt\", row => do\n    equip: readById(parseRef(row->eq))\n    equipId: equip->id\n    locationId: equip->locationRef->id\n    \n    // Get info from bacnetPtList by matching bacnetCur\n    curType: row->bacnetCur[0..1]\n    bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n    if (bacnetGrid == null) bacnetGrid= [].toGrid()\n    ptRowMatch: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n    if (ptRowMatch == null)\n      ptRowMatch= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n    \n    // Prepare new point dict\n    ptDict: {point,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: connectorId,\n             connRef: connectorId,\n             cur,\n             bacnetCur: row->bacnetCur,\n             bacnetHis: row[\"bacnetHis\"], //optional\n             bacnetName: row->bacnetName,\n             kind: ptRowMatch[\"kind\"], //optional\n             unit: ptRowMatch[\"unit\"], //optional\n             enum: ptRowMatch[\"enum\"], //optional\n             equipRef: equipId,\n             his,\n             notes: row[\"point\"], //optional\n             locationRef: locationId,\n             siteRef: siteId,\n             tz: \"Los_Angeles\",\n             tmp: today()}\n               \n    // Set collection interval / cov if no bacnetHis\n    if (row[\"bacnetHis\"] == null)\n      if (row[\"kind\"] == \"Bool\") do\n        ptDict= ptDict.set(\"hisCollectCov\", marker())\n        ptDict= ptDict.set(\"hisCollectInterval\", 12h)\n      end else do\n        ptDict= ptDict.set(\"hisCollectInterval\", 15min)\n      end\n\n    // Add navName and meaningful tags from standard\n    tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n    ptDict= ptDict.set(\"navName\", tagRow->dis)\n    tagSet: tagRow->tagsPtOnly.split(\",\")\n    tagSet.each tag => do\n      ptDict= ptDict.set(tag, marker())\n    end\n\n    // Commit if finalize == true\n    if (finalize) do\n      commit(diff(null, ptDict, {add}))\n    end\n\n    return ptDict\n  end) // alcPtList.addRow(\"newPt\", row\n  \n  return alcPtList\nend\n \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viSiteOcc",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function finds all occupancy sensors in a given building / site,\n  loads the associated trends for the given span, and summarizes the\n  occupancy as one trend showing the number of occupancy sensors detecting\n  occupancy at any given time.\n  \n  Returns a history grid formatted for display as a chart, with\n  ts, v0\n  \n  Arguments:\n  siteRef        Ref<site> id of the selected site\n  span           DateSpan to display\n*/\n\n(siteRef, span, rollupMin) => do\n  rollup: rollupMin.as(1min)\n\n  readAll(zone and occupied and sensor and not virtual and siteRef==siteRef)\n  .hisRead(span, {limit:null})\n  .hisRollup(discreteBoolPeriods, rollup)\n  .hisClip()\n  // For each interval, determine how long each occ sensor was ON\n  .hisMap(v => do\n    // parseDiscreteBoolPeriods return a grid with offset / val\n    grid: parseDiscreteBoolPeriods(v)\n    \n    // Check if empty, store size info\n    if (isEmpty(grid)) return 0\n    else maxIndex: grid.size - 1\n    \n    // Calculate durations and select ON times\n    grid= grid\n          .map((row, index) =>\n              {dur: if (index==maxIndex) rollup - row->offset\n                    else grid[index+1]->offset - row->offset,\n               val: row->val})\n          .findAll(row => row->val==true)\n          \n    // Return value between 0 and 1 representing average occ during interval\n    if (isEmpty(grid)) return 0\n    return (grid.foldCol(\"dur\", sum) / rollup).as(1)\n  end)\n  .hisFoldCols(sum)\n  .addColMeta(\"v0\", {dis: \"B\"+readById(siteRef)->dis+\" Total Occupancy Sensors ON\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAVTSI2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_b33/tsi_integ_2of2.csv`\n to add these points to zone equips that exist and exhaust TUs that\n may not exist.\n \n The relation between ALC VAVs and the TSI integration programs\n is in file `io/integration_b33/vav_tsi_8682_only.csv`, and only one\n of each group of two TSI integration program is used, as all points\n of interest are integrated twice, except for fume hood damper positions\n which can be added later.\n \n The first file includes a match to the 2018-09-05 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n() => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b33/tsi_integ_2of2.csv`)\n  alcEqList: ioReadCsv(`io/integration_b33/vav_tsi_8682_only.csv`)\n  \n  siteId: read(site and dis==\"33\")->id\n  \n  // Cycle through equips\n  alcEqList.each((eqRow, indexEqRow) => do\n    jobProgress((indexEqRow / alcEqList.size())*100.as(1%), eqRow->supplyVAV)\n    \n    supplyTUId: read(supply and terminalUnit and equip and siteRef->id==siteId\n                 and navName==\"Supply \"+reGroups(r\"33-(VAV-\\d{3})\",eqRow->supplyVAV)[1])->id\n    zoneId: supplyTUId->equipRef\n    locationId: supplyTUId->locationRef\n    \n    // Create fume hood and exhaust terminal unit equips if needed\n    // Fume hood\n    if (read(fumeHood and equipRef==zoneId, false) == null) do\n      eqDict1: {navName: \"Fume Hood\",\n               disMacro: \"\\\$equipRef \\\$navName\",\n               equip,\n               equipRef: zoneId,\n               locationRef: locationId,\n               siteRef: siteId,\n               fumeHood,\n               test20180904}\n      commit(diff(null, eqDict1, {add}))\n    end // if no fume hood equip\n    fumeHoodId: read(fumeHood and equipRef==zoneId)->id\n    \n    // Exhaust terminal unit\n    if (read(exhaust and terminalUnit and equipRef==zoneId, false) == null) do\n      eqDict2: {navName: \"Exhaust TU\",\n               disMacro: \"\\\$equipRef \\\$navName\",\n               equip,\n               equipRef: zoneId,\n               locationRef: locationId,\n               siteRef: siteId,\n               exhaust,\n               terminalUnit,\n               test20180905}\n      commit(diff(null, eqDict2, {add}))\n    end // if no exhaust terminal unit equip\n    exhaustTUId: read(exhaust and terminalUnit and equipRef==zoneId)->id\n    \n    // Load needed connector, and TL and AV points list\n    connectorId: parseRef(eqRow->routerRef)\n    \n    bacnetLearn(connectorId)\n    bacnetPtList2: bacnetLearn(connectorId, 2)\n    if (isEmpty(bacnetPtList2)) return \"bacnetLearn failed\"\n    \n    bacnetLearn(connectorId)\n    bacnetTrendList: bacnetLearn(connectorId, 20)\n    if (isEmpty(bacnetTrendList)) return \"bacnetLearn failed\"\n  \n    // Go through list of points of interest for each eq and integrate\n    alcPtList.each ptRow => do\n      // Detect type of point to determine proper equipRef\n      if (ptRow->indexTagStandard.parseNumber() < 183) do equipId: zoneId\n      else if (ptRow->indexTagStandard.parseNumber() < 188) do equipId: supplyTUId\n      else if (ptRow->indexTagStandard.parseNumber() < 191) do equipId: exhaustTUId\n      else do equipId: fumeHoodId end\n      \n      // Find bacnetCur and related info\n      bacnetDis: ptRow->bacnetDis + \"_\" + eqRow->instance\n      bacnetRow: bacnetPtList2.find(row => row[\"dis\"]==bacnetDis)\n      if (bacnetRow == null) return \"next point\"\n      \n      // Find bacnetHis\n      bacnetTrendDis: ptRow->bacnetTrendDis + \"_\" + eqRow->instance\n      bacnetTrendRow: bacnetTrendList.find(row => row[\"dis\"]==bacnetTrendDis)\n      if (bacnetTrendRow == null) return \"next point\"\n      \n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: bacnetRow->bacnetCur,\n               bacnetHis: bacnetTrendRow->bacnetHis,\n               bacnetName: bacnetDis,\n               kind: bacnetRow->kind,\n               unit: bacnetRow->unit,\n               equipRef: equipId,\n               his,\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp20180905,\n               notes: ptRow->pointName}\n                \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==ptRow->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      commit(diff(null, ptDict, {add}))\n      \n    end // alcPtList.each ptRow\n  end) // alcEqList.each eqRow\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptMetricsCoolingSystemITUE","toolRecursiveSearch"],,,,M,,,,,,"viITUEline",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the ITUE points for Cori, Edison, and Computers\n  and construct a chart for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(dates: today, rollup: 15min, sysRef:null, wbRef:null) => do\n  // Default to B59 Data Center Computers if no sysRef is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id\n\n  // Default to B59 TW if no wbRef is provided\n  if(wbRef==null)\n    wbRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n  // Get all ITUEs under this computer\n  itues: toolRecursiveSearch(sysRef,\n                   \"hisFunc==\\\"ptMetricsCoolingSystemITUE\\\"\")\n\n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  // Interpolate, filter and calculate total input and output power\n  itueTrends: hisRead(itues,dates,{limit:null})\n                 .hisRollup(avg, rollup)\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"computers\")\n                 .renameCol(\"v1\", \"cori\")\n                 .renameCol(\"v2\", \"edison\")\n  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .hisRollup(avg, rollup)\n                  .renameCol(\"v0\",\"oaWB\")\n\n  //Add OA Wetbulb to the collection of itues\n  metric: hisJoin([oaWetBulb, itueTrends])  \n            .addColMeta(\"oaWB\",\n              {dis: \"OAT WB\",\n              unit: \"°F\", color: \"#4B0082\",\n               chartGroup: \"all\"})\n            .addColMeta(\"computers\",\n              {dis: \"Combined Computer ITUE\",\n               unit: \"_\", color: \"#000000\",\n               chartGroup: \"all\"})\n            .addColMeta(\"cori\",\n              {dis: \"Cori ITUE\",\n               unit: \"_\", color: \"#DC143C\",\n               chartGroup: \"all\"})\n            .addColMeta(\"edison\",\n              {dis: \"Edison ITUE\",\n               unit: \"_\", color: \"#FF7F50\",\n               chartGroup: \"all\"})\n  return metric\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["meterFormulaRead"],,,,M,,,,,,"meterFormulasUpdate",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function updates and stores meter formulas in zinc format\n  for all meters that are virtual and whose location has sblid tag\n  \n  Relies on meterFormulaRead func and ioWriteZinc\n*/\n\n() => do\n  meters: readAll(virtual and siteMeter and (elec or gas) and equip and sblid)\n  numbers: meters.size\n  \n  meters.each((equip, i) => do\n    jobProgress((i/numbers)*100.as(\"%\"), \"Meter: \" + equip.dis())\n    commit(diff(\n      equip, \n      {meterFormula:\n         meterFormulaRead(equip->sblid,\n                          if (equip.has(\"elec\")) \"elec\" else \"gas\")\n         .ioWriteZinc(\"\")\n      }\n    ))\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["scrapeConvertStrToNum"],,,,M,,,,,,"scrapeDentMeter",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function scrapes data from a DENT meter by accessing the\n website, finding the name of the csv that contains the data,\n and parsing through that csv for relevant values. It then writes\n voltage, current, and energy to the respective points on the\n meter.\n \n ***Requires that \"Avg\" is checked in logger. If not, some\n columns will not be able to be scraped.\n\n Arguments:\n restartDate:             Date to scrape history from. Must be\n (optional)               a dateTime, not a date. If no date is\n                          given, default will be the last time\n                          data was scraped. If there is no hisEnd,\n                          the default will be pastWeek.\n \n device:                  The rec of the device; used for finding\n                          the csv file name.\n \n channel:                 The channel we want to write to point\n                          history. Must be entered as a string.\n                          Must be 1 of 5 options:\n                          chan1,chan2,chan3,chan4,chan5\n                          \n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-08-13 //\n*/\n\n(restartDate:null,device:\"C1607024-\",channel:\"chan1\") => do\n  // Get the csv file's name by using regular expressions to match\n  // the expected format of the name.\n  // (a sample csv file name is C1607024-2018-07-26-18-01-21.csv)\n  try website_text_grid: ioReadLines(`http://dentmeter-test.lbl.gov/download_logged_data.html?password=SBL_2018`) // ioReadLines(`198.128.219.57//download_logged_data.html?password=SBL_2018`)\n  catch return {suggestion1: \"Disconnect logger from meter.\", suggestion2: \"Check that meter is connected via ethernet.\"}\n  csv_name_row: website_text_grid.find row => row.contains(device)\n  try csv_name: reGroups(\"\"\"[A-Z]{1}\\\\d{7}-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}.csv\"\"\",csv_name_row)[0]\n  catch return \"Try Again\"\n  \n  // Read lines of the csv.\n  csv_grid: ioReadLines(`http://dentmeter-test.lbl.gov/` + csv_name)\n  csv_grid= csv_grid[0..-2] // Patch-up: The last row almost always causes error b/c it is not fully filled.\n  \n  // Find how many inputs are in each channel.\n  chan_names: csv_grid.find row => row.contains(\"Record\")\n  chan_names= split(chan_names, \",\")\n  chan1: chan_names.findAll (row => row.contains(\"Chan 1\")).size\n  chan2: chan_names.findAll (row => row.contains(\"Chan 2\")).size\n  chan3: chan_names.findAll (row => row.contains(\"Chan 3\")).size\n  chan4: chan_names.findAll (row => row.contains(\"Chan 4\")).size\n  chan5: chan_names.findAll (row => row.contains(\"Chan 5\")).size\n  \n  // Get the headers of each column. (May have repeats of headers).\n  col_names: csv_grid.find row => row.contains(\"Date\")\n  col_names= split(col_names, \",\")\n  \n  // Divide the headers by channel. (Will NOT have repeats of\n  // headers).\n  chan1_names: col_names[3..(3+chan1-1)]\n  chan2_names: col_names[(3+chan1)..(3+chan1+chan2-1)]\n  chan3_names: col_names[(3+chan1+chan2)..(3+chan1+chan2+chan3-1)]\n  chan4_names: col_names[(3+chan1+chan2+chan3)..(3+chan1+chan2+chan3+chan4-1)]\n  chan5_names: col_names[(3+chan1+chan2+chan3+chan4)..(3+chan1+chan2+chan3+chan4+chan5-1)]\n  \n  // Parse the csv for timestamp and data. For each row, if it is\n  // a meaningful row (if it has a timestamp), assign values.\n  data_grid: csv_grid.map row => do\n    date_string: reGroups(\"\"\"\\\\d{2}/\\\\d{2}/\\\\d{2}\"\"\",row)\n    time_string: reGroups(\"\"\"\\\\d{2}:\\\\d{2}:\\\\d{2}\"\"\",row)\n    // If a meaningful row\n    if (date_string!=null and time_string!=null) do\n      // First assign dateTime. The csv is always in UTC so convert\n      // to Los Angeles time. Then make a list of data.\n      dateTime: dateTime(parseDate(date_string[0],\"MM/DD/YY\"),parseTime(time_string[0],\"hh:mm:ss\"),\"GMT\")\n      .toTimeZone(\"Los_Angeles\")\n      data: split(row,\",\")\n      data= data[3..-1]\n      data= data.map val => do\n        value: scrapeConvertStrToNum(val)\n      end\n      // If chan1 has values, check to see if its header is in the\n      // header list for Channel 1. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan1 > 0) do\n        if (chan1_names.any name => name.contains(\"Volt\")) do\n          chan1_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_volt: null\n        end\n        if (chan1_names.any name => name.contains(\"Amp\")) do\n          chan1_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_amps: null\n        end\n        if (chan1_names.any name => name.contains(\"KW Hours\")) do\n          chan1_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_KWH: null\n        end\n        if (chan1_names.any name => name.contains(\"Avg. KW\")) do\n          chan1_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_avgKW: null\n        end\n        if (chan1_names.any name => name.contains(\"Avg. KVA\")) do\n          chan1_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_avgKVA: null\n        end\n        if (chan1_names.any name => name.contains(\"PF\")) do\n          chan1_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_PF: null\n        end\n        if (chan1_names.any name => name.contains(\"KVAR\")) do\n          chan1_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_KVAR: null\n        end\n      end else do\n        chan1_volt: null\n        chan1_amps: null\n        chan1_KWH: null\n        chan1_avgKW: null\n        chan1_avgKVA: null\n        chan1_PF: null\n        chan1_KVAR: null\n      end\n      // If chan2 has values, check to see if its header is in the\n      // header list for Channel 2. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan2 > 0) do\n        if (chan2_names.any name => name.contains(\"Volt\")) do\n          chan2_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_volt: null\n        end\n        if (chan2_names.any name => name.contains(\"Amp\")) do\n          chan2_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_amps: null\n        end\n        if (chan2_names.any name => name.contains(\"KW Hours\")) do\n          chan2_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_KWH: null\n        end\n        if (chan2_names.any name => name.contains(\"Avg. KW\")) do\n          chan2_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_avgKW: null\n        end\n        if (chan2_names.any name => name.contains(\"Avg. KVA\")) do\n          chan2_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_avgKVA: null\n        end\n        if (chan2_names.any name => name.contains(\"PF\")) do\n          chan2_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_PF: null\n        end\n        if (chan2_names.any name => name.contains(\"KVAR\")) do\n          chan2_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_KVAR: null\n        end\n      end else do\n        chan2_volt: null\n        chan2_amps: null\n        chan2_KWH: null\n        chan2_avgKW: null\n        chan2_avgKVA: null\n        chan2_PF: null\n        chan2_KVAR: null\n      end\n      // If chan3 has values, check to see if its header is in the\n      // header list for Channel 3. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan3 > 0) do\n        if (chan3_names.any name => name.contains(\"Volt\")) do\n          chan3_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_volt: null\n        end\n        if (chan3_names.any name => name.contains(\"Amp\")) do\n          chan3_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_amps: null\n        end\n        if (chan3_names.any name => name.contains(\"KW Hours\")) do\n          chan3_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_KWH: null\n        end\n        if (chan3_names.any name => name.contains(\"Avg. KW\")) do\n          chan3_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_avgKW: null\n        end\n        if (chan3_names.any name => name.contains(\"Avg. KVA\")) do\n          chan3_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_avgKVA: null\n        end\n        if (chan3_names.any name => name.contains(\"PF\")) do\n          chan3_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_PF: null\n        end\n        if (chan3_names.any name => name.contains(\"KVAR\")) do\n          chan3_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_KVAR: null\n        end\n      end else do\n        chan3_volt: null\n        chan3_amps: null\n        chan3_KWH: null\n        chan3_avgKW: null\n        chan3_avgKVA: null\n        chan3_PF: null\n        chan3_KVAR: null\n      end\n      // If chan4 has values, check to see if its header is in the\n      // header list for Channel 4. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan4 > 0) do\n        if (chan4_names.any name => name.contains(\"Volt\")) do\n          chan4_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_volt: null\n        end\n        if (chan4_names.any name => name.contains(\"Amp\")) do\n          chan4_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_amps: null\n        end\n        if (chan4_names.any name => name.contains(\"KW Hours\")) do\n          chan4_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_KWH: null\n        end\n        if (chan4_names.any name => name.contains(\"Avg. KW\")) do\n          chan4_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_avgKW: null\n        end\n        if (chan4_names.any name => name.contains(\"Avg. KVA\")) do\n          chan4_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_avgKVA: null\n        end\n        if (chan4_names.any name => name.contains(\"PF\")) do\n          chan4_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_PF: null\n        end\n        if (chan4_names.any name => name.contains(\"KVAR\")) do\n          chan4_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_KVAR: null\n        end\n      end else do\n        chan4_volt: null\n        chan4_amps: null\n        chan4_KWH: null\n        chan4_avgKW: null\n        chan4_avgKVA: null\n        chan4_PF: null\n        chan4_KVAR: null\n      end\n      // If chan5 has values, check to see if its header is in the\n      // header list for Channel 5. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan5 > 0) do\n        if (chan5_names.any name => name.contains(\"Volt\")) do\n          chan5_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_volt: null\n        end\n        if (chan5_names.any name => name.contains(\"Amp\")) do\n          chan5_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_amps: null\n        end\n        if (chan5_names.any name => name.contains(\"KW Hours\")) do\n          chan5_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_KWH: null\n        end\n        if (chan5_names.any name => name.contains(\"Avg. KW\")) do\n          chan5_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_avgKW: null\n        end\n        if (chan5_names.any name => name.contains(\"Avg. KVA\")) do\n          chan5_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_avgKVA: null\n        end\n        if (chan5_names.any name => name.contains(\"PF\")) do\n          chan5_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_PF: null\n        end\n        if (chan5_names.any name => name.contains(\"KVAR\")) do\n          chan5_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_KVAR: null\n        end\n      end else do\n        chan5_volt: null\n        chan5_amps: null\n        chan5_KWH: null\n        chan5_avgKW: null\n        chan5_avgKVA: null\n        chan5_PF: null\n        chan5_KVAR: null\n      end\n    // If not a meaningful row, assign all values \"false\"\n    end else do\n      dateTime: false\n      chan1_volt: false\n      chan1_amps: false\n      chan1_KWH: false\n      chan1_avgKW: false\n      chan1_avgKVA: false\n      chan1_PF: false\n      chan1_KVAR: false\n      chan2_volt: false\n      chan2_amps: false\n      chan2_KWH: false\n      chan2_avgKW: false\n      chan2_avgKVA: false\n      chan2_PF: false\n      chan2_KVAR: false\n      chan3_volt: false\n      chan3_amps: false\n      chan3_KWH: false\n      chan3_avgKW: false\n      chan3_avgKVA: false\n      chan3_PF: false\n      chan3_KVAR: false\n      chan4_volt: false\n      chan4_amps: false\n      chan4_KWH: false\n      chan4_avgKW: false\n      chan4_avgKVA: false\n      chan4_PF: false\n      chan4_KVAR: false\n      chan5_volt: false\n      chan5_amps: false\n      chan5_KWH: false\n      chan5_avgKW: false\n      chan5_avgKVA: false\n      chan5_PF: false\n      chan5_KVAR: false\n    end\n    {ts:dateTime,chan1Volt:chan1_volt,chan1Amps:chan1_amps,chan1KWH:chan1_KWH,chan1AvgKW:chan1_avgKW,chan1AvgKVA:chan1_avgKVA,chan1PF:chan1_PF,chan1KVAR:chan1_KVAR,chan2Volt:chan2_volt,chan2Amps:chan2_amps,chan2KWH:chan2_KWH,chan2AvgKW:chan2_avgKW,chan2AvgKVA:chan2_avgKVA,chan2PF:chan2_PF,chan2KVAR:chan2_KVAR,chan3Volt:chan3_volt,chan3Amps:chan3_amps,chan3KWH:chan3_KWH,chan3AvgKW:chan3_avgKW,chan3AvgKVA:chan3_avgKVA,chan3PF:chan3_PF,chan3KVAR:chan3_KVAR,chan4Volt:chan4_volt,chan4Amps:chan4_amps,chan4KWH:chan4_KWH,chan4AvgKW:chan4_avgKW,chan4AvgKVA:chan4_avgKVA,chan4PF:chan4_PF,chan4KVAR:chan4_KVAR,chan5Volt:chan5_volt,chan5Amps:chan5_amps,chan5KWH:chan5_KWH,chan5AvgKW:chan5_avgKW,chan5AvgKVA:chan5_avgKVA,chan5PF:chan5_PF,chan5KVAR:chan5_KVAR}\n  end\n  \n  // Filter out unmeaningful rows of data to which we assigned false.\n  // Then turn it into a grid (above, the type was actually a list,\n  // even though the variable name was \"grid.\" This was because using\n  // list was easier to parse strings than grid.\n  data_grid_filtered: data_grid.findAll row => row->ts!=false\n  data_grid_filtered= toGrid(data_grid_filtered)\n  \n  // Filter out unused/irrelevant columns.\n  nullColNames: data_grid_filtered.colNames.findAll colName => do\n    data_grid_filtered.all row => row[colName] == null\n  end\n  polished_grid: data_grid_filtered.removeCols(nullColNames)\n  \n  // To avoid redundant history, (once new points are available) add\n  // the usual block of code that gets the hisEnd and filters out\n  // rows based on ts. Then write to points.\n  points: readAll(tonyTMP and point)\n  points.each pt => do\n  /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    aregument). Assign dates, clear history, and/or assign\n    hisEnd based on which of the 4 cases is presented\n    (noHis/his and noInput/input) */\n    hisEnd: pt[\"hisEnd\"]\n    today: now().date\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd.date..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Based on the results above, filter the grid.\n    date_filtered_grid: polished_grid.findAll row => row->ts > hisEnd\n    \n    // Write to voltage point.\n    if (pt->unit==\"V\") do\n      column_name: concat([channel,\"Volt\"])\n      voltage_grid: date_filtered_grid.keepCols([\"ts\",column_name])\n      voltage_grid= voltage_grid.reorderCols([\"ts\",column_name])\n      hisWrite(voltage_grid,pt)\n    end\n    // Write to current point.\n    if (pt->unit==\"A\") do\n      column_name: concat([channel,\"Amps\"])\n      current_grid: date_filtered_grid.keepCols([\"ts\",column_name])\n      current_grid= current_grid.reorderCols([\"ts\",column_name])\n      hisWrite(current_grid,pt)\n    end\n    // Write to energy point.\n    if (pt->unit==\"kWh\") do\n      column_name: concat([channel,\"KWH\"])\n      energy_grid: date_filtered_grid.keepCols([\"ts\",column_name])\n      energy_grid= energy_grid.reorderCols([\"ts\",column_name])\n      hisWrite(energy_grid,pt)\n    end\n  end\nend\n\n\n\n\n\n// ***If we want to replace C1607024- with some code to make it\n// more generalized, we can use:\n//     website_text_grid: ioReadLines(`http://dentmeter-test.lbl.gov/download_logged_data.html`)\n//     website_text_filtered:  website_text_grid.find row => reGroups(\"\"\"[A-Z]{1}\\\\d{7}\"\"\",row)!=null\n//     device_name: reGroups(\"\"\"[A-Z]{1}\\\\d{7}\"\"\",website_text_filtered)\n// and use device_name to replace C1607024. Alternatively, we could\n// make an input called device_name. It could be a point, and the\n// argument is a rec, and we would have to turn it into a string.\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viCyclesOfConSumGraph",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all makeup and blowdown meters and graph their totals over the\n  given period of time, per site.\n  Return grid for graph with:\n    siteDis    Site dis\n    makeup     Total makeup water volume\n    blowdown   Total blowdown volume\n  \n  Arguments: \n  span         Date span to analyze and summarize\n*/\n\n(span) => do\n  // Find blowdown water volume records\n  blowdownR: readAll(delta and volume and sensor and not hidden and\n                     equipRef->blowdown and equipRef->water and equipRef->meter)\n  \n  // Calculate total volume over span for each site\n  blowdownT: blowdownR\n             .map(pt => {siteDis: pt->siteRef->dis,\n                         blowdown: pt.hisRead(span).hisClip.foldCol(\"v0\", sum)})\n  \n  // List of location ids for locationss with blowdown meter\n  locIds: blowdownR.colToList(\"locationRef\")\n  \n  // Find makeup water volume records in locations with blowdown meter\n  makeupR: readAll(delta and volume and sensor and not hidden and\n                  equipRef->makeup and equipRef->water and equipRef->meter)\n           .findAll(rec => locIds.contains(rec->locationRef))\n  \n  // Calculate total volume over span for each site\n  makeupT: makeupR\n           .map(pt => {siteDis: pt->siteRef->dis,\n                       makeup: pt.hisRead(span).hisClip.foldCol(\"v0\", sum)})\n  \n  // Join grids and prepare for display as graph\n  summary: join(makeupT, blowdownT, \"siteDis\")\n  \n  // Calculate cycles of concentration for each site\n  summary = summary.addCol(\"cycles\", row => do\n              if (row[\"makeup\"] > 0 and row[\"blowdown\"] > 0)\n                return (row[\"makeup\"] / row[\"blowdown\"]).as(\"_cycles\")\n              else\n                return null\n            end)\n           .addMeta({chartType: \"bar\"})\n           .sort(\"siteDis\")\n           .addColMeta(\"makeup\", {chartType: \"bar\", color: \"#1ab2ff\",\n                                  dis: \"Total Makeup Water Volume\"})\n           .addColMeta(\"blowdown\", {chartType: \"bar\", color: \"#9933ff\",\n                                    dis: \"Total Blowdown Water Volume\"})\n           .addColMeta(\"cycles\", {chartType: \"bar\", color: \"#000000\",\n                                  dis: \"Cycles of Concentration\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["dbCopiesBacnetCur"],,,,M,,,,,,"viCopiesBacnetCur",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  bacnetConnRef + bacnetCur combinations are unique, and there should\n  only be one point per such combination. This function finds duplicates,\n  which typically reflect a typo or error during the point creation.\n  \n  Return grid with:\n    id:            point id, for all points with duplicate combinations\n    bacnetConnRef: ref \n    bacnetCur:     text\n    copies:        number of duplicate combinations (2+)\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  // Now updated asynchronously using dbCopiesBacnetCur\n  copy: ioReadTrio(`io/dbHealth/copiesBacnetCur.trio`)\n  \n  return copy\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"tmpMap74Tsi8681",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point, add these points to zone and to equips that already exist.\n \n The file includes a match to the 2018-11-28 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(file: `io/integration_b74/tsi_8681.csv`,\ntypes: [2,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(file)\n  \n  siteId: read(site and dis==\"74\")->id\n  failedList: []\n\n  // Cycle through existing terminal units\n  tus: readAll(supply and terminalUnit and equip\n               and controls==\"lbnl74_tsi_8681_bacnet_rev2\"\n               and siteRef==siteId)\n  \n  tus.each((tu, i) => do\n    jobProgress(round(i/tus.size()*100).as(\"%\"), tu.dis())\n    locationId: tu->locationRef\n    zoneId: tu->equipRef\n    connectorId: tu->connRef\n    instance: tu->connInstance\n    \n    // Find exhaust TU if it exists\n    etu: read(exhaust and terminalUnit and equip and equipRef==zoneId,\n              false)\n    \n    // Prepare list of bacnet grids containing all bacnet info for given types\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"TL\"]\n    \n    try do\n      types.each type => do\n        learn: bacnetLearn(connectorId, type)\n        bacnetPtList= bacnetPtList.set(type, learn)\n      end\n    end catch (ex) do\n      failedList= failedList.add(tu.dis())\n      // Skip terminal unit\n      return null\n    end\n\n    // Cycle through given points of interest, find and integrate\n    alcPtList.each pt => do\n      // Find corresponding tag set info in tagging standard\n      tagRow: tagStd.find(tag => tag->index==pt->indexTagStandard)\n    \n      // Initialize found bacnet rows to null\n      bacnetCurRow: null\n      bacnetHisRow: null\n    \n      // If bacnetCur is available, retrieve corresponding info\n      if (pt[\"bacnetCurName\"] != null) do\n        curType: bacnetObjMap.index(pt[\"bacnetCurType\"])\n        curName: pt->bacnetCurName + \"_\" + instance\n        \n        // Find available BACnet point info\n        bacnetCurGrid: bacnetPtList[curType]\n        if (bacnetCurGrid == null) bacnetCurGrid= [].toGrid()\n        bacnetCurRow= bacnetCurGrid.find(row => row[\"dis\"]==curName)\n        \n        // If point not found in BACnet, it is hidden or does not\n        // exist for this zone. Skip point only if bacnetHis also missing\n      end // If bacnetCur is available\n      \n      // If bacnetHis is available, retrieve corresponding info\n      if (pt[\"bacnetHisName\"] != null) do\n        hisName: pt->bacnetHisName + \"_\" + instance\n        \n        // Find available BACnet point info\n        bacnetHisGrid: bacnetPtList[20]\n        if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n        bacnetHisRow= bacnetHisGrid.find(row => row[\"dis\"]==hisName)\n      end\n\n      // If we did not find BACnet info for either Cur or His, skip point\n      if ((bacnetCurRow == null) and (bacnetHisRow == null)) return null\n      \n      // Check equipment type to determine proper equipRef\n      equipId: if (pt->eq==\"supply\") tu->id\n               else if (pt->eq==\"exhaust\") etu->id\n               else zoneId\n          \n      // If point already exists, skip\n      ptFilter: \"point and equipRef==@\" + equipId + \" and \"\n                + tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n      if (read(parseFilter(ptFilter),false) != null) return null\n          \n      // Prepare polling variables as needed (null if bacnetHis)\n      hisCollectCov: if (pt[\"hisCollectCov\"]==null) null else marker()\n      hisCollectInterval: if (pt[\"hisCollectCov\"]==null) null else 12h\n      \n      // Prepare new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: if (bacnetCurRow != null) bacnetCurRow[\"bacnetCur\"],\n               bacnetHis: if (bacnetHisRow != null) bacnetHisRow[\"bacnetHis\"],\n               bacnetCurName: if(pt[\"bacnetCurName\"] != null) pt->bacnetCurName + \"_\" + instance,\n               bacnetHisName: if(pt[\"bacnetHisName\"] != null) pt->bacnetHisName + \"_\" + instance,\n               bacnetDesc: if (bacnetCurRow != null) bacnetCurRow[\"bacnetDesc\"], //optional\n               kind: if (bacnetCurRow != null) bacnetCurRow[\"kind\"] else pt[\"kind\"],\n               unit: if (pt[\"unit\"] != null or bacnetCurRow == null) pt[\"unit\"]\n                     else bacnetCurRow[\"unit\"],\n               enum: if (bacnetCurRow != null) bacnetCurRow[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               hisCollectCov: hisCollectCov,\n               hisCollectInterval: hisCollectInterval,\n               notes: pt[\"alcDisplay\"], //optional\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp2: today()}\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n    end  // alcPtList.each pt\n  end)  // each tu\n  \n  return failedList\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualSumNA",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  summed value of all points which have a virtualRef equal\n  to the id of the virtual point. This version perpetuates the NA\n  as such, rather than replacing with a null.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap(x => if (x==null) na() else x)\n         .hisFoldCols(sum)\n         .each(row => yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recEditNotesFromId",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(notesDict) => do\n  // Normalize action input\n  notesDict= actionNormInput(notesDict, \"dict\")\n  \n  // Only allow notes and id to persist\n  notesDict= notesDict.findAll((v,k) => [\"id\",\"notes\",\"mod\"].contains(k))\n\n  // Edit record\n  recEdit(notesDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"pumpMaxStageExceeded",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(plant, dates, maxTime: 30min) => do\n  // this function assumes sampled status trends (not cov)\n  // current version does not differentiate between primary and secondary pumps\n  // and all pumps associated with the plant get queried\n  \n  // get max stage information from plant\n  maxStage: plant->secondaryLoopMaxStage\n  \n  if (maxStage == null) do\n    throw \"No 'secondaryLoopMaxStage' defined: \" + dis(plant)\n    return null\n  end  \n\n  runPeriods: []\n  \n  // get status of all pumps in the same system (pumps are sub-equipment of plant)\n  pumpCmd: readAll(water and pump and run and sensor and equipRef==plant->id)     \n     \n    // load history for dates (one day if used in rule / spark)\n    pumpCmd.hisRead(dates)\n    \n    // transform status values from boolean to integer\n    .hisMap(x => if (x) 1 else 0)\n    \n    // sum all values to determine how many pumps are on at any given time\n    .hisFoldCols(sum)\n    \n    // find when maximum number of pumps staged is exceeded\n    .hisFindPeriods(v0 => v0 > maxStage)\n    \n    // raise flag only if any period exceeds maxTime\n    .findAll(r => r->v0 > maxTime)\n\n\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["foldHisDiffMax"],,"Accumulator Jumped",,M,"Accumulator value jumped by more than allowed step",,,,,"ruMeterAccJump",,"meter","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates) => do\n  // Get all accumulator points\n  accs: readAll(point and accumulator and sensor\n                and not virtual\n                and equipRef==equip->id)\n  if (isEmpty(accs)) return null\n  \n  accs.hisRead(dates, {limit:null})\n      .hisRollup(foldHisDiffMax, 24hr)\n      .hisFindPeriods((val, ts, his) => do\n        rollover: his[\"rollover\"]\n        maxStep: his[\"maxAccStep\"]\n        if (rollover != null and maxStep == null)\n          maxStep= rollover / 10\n        if (maxStep == null)\n          return false\n        else\n          return (val > maxStep)\n      end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDiffPressComplianceHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all zones, and calculate the error between their\n  differential pressure and pressure setpoint. Then, display results as compliance metric.\n  >100% out of deadband away from zero - blue\n  100% in deadband - palegreen\n  0-100% out of deadband towards zero - yellow\n  <0% reversed pressurization - red\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n  deadbandDev        Number in inH2O, deadband allowed deviation\n  group              String, \"All,Negative only,Positive only\"\n  rollupMinutes      Number in minutes, use for rollup\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastWeek(),\n deadbandDev: 0.005, group: \"All\", rollupMinutes:15) => do\n  // Params\n  unit: \"%\"\n  // -50%, 0%, 50%, 100%, 150%\n  colors: \"red, orange, yellow, palegreen, blue\"\n  minClip: -50%\n  maxClip: 150%\n \n  // Retrieve location / site record, then retrieve all zone pressures\n  loc: readById(locRef)\n  if (loc.has(\"site\"))\n    zones: readAll(zone and equip and siteRef==locRef)\n  else\n    zones: readAll(zone and equip and locationRef==locRef)\n   \n  // Filter out zones that do not have a dP setpoint\n  zones= zones\n  .findAll(z => read(equipRef==z->id and air and pressure and sp, false)!=null)\n\n  // Select only negatively or positively pressurized rooms\n  groupFunc: if (group==\"Negative only\") v => v < 0\n             else if (group==\"Positive only\") v => v > 0\n             else v => true\n    \n  zones= zones\n  .findAll(z => read(equipRef==z->id and air and pressure and sp)\n                .hisRead(dates)\n                .hisFindAll(v => v != null and v != na())\n                .foldCol(\"v0\", avg)\n                .groupFunc)\n\n  // Exit if no zones were found\n  if(isEmpty(zones)) return null\n\n  // Create grid of calculated histories\n  hisGrid: {}.toGrid()\n  \n  // Cycle through zones and create history of pressure devations\n  zones.each(zone => do\n    // Find pressure and pressure setpoint\n    dp: read(air and pressure and sensor and equipRef==zone->id, false)\n    dpsp: read(air and pressure and sp and equipRef==zone->id, false)\n    \n    // If either is missing, skip zone\n    if (dp==null or dpsp==null) return null\n    \n    // Col name based on zone name\n    colName: zone->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    grid: [dp, dpsp].hisRead(dates, {limit: null})\n        .hisRollup(avg, rollupMinutes.as(\"min\"))\n        .addCol(colName, row => do\n          if (row.remove(\"ts\").any(v => v==null or v==na()))\n            return null\n          else do\n            v: row->v0\n            sp: row->v1\n            // Treat zero setpoint separately\n            if (sp==0) do\n              return if(abs(v) < deadbandDev) 1 else abs(v) / deadbandDev*3\n            end\n            \n            // Non-zero setpoint\n            if (abs(sp - v) < deadbandDev) return 1\n            else return v / sp\n          end\n        end)\n    .keepCols([\"ts\",colName])\n    .hisFindAll(val => val != null)\n    .hisMap(v => v.as(1)*100.as(\"%\"))\n    .hisMap(v => max(minClip, min(maxClip, v)))\n    .addColMeta(colName, {dis: zone->navName})\n    \n    // Add to hisGrid summary array\n    if (isEmpty(grid)) return null\n    if (isEmpty(hisGrid)) hisGrid=grid\n    else hisGrid= hisJoin([grid,hisGrid])\n  end)\n  \n  if (isEmpty(hisGrid)) return null\n\n  try do\n    hisGrid= hisGrid\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollupMinutes<60) \":mm\" else \"\")+\"a\"),\n                rm: his->dis,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: minClip.as(unit),\n                           chartMax: maxClip.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: colors})\n  catch (ex) do\n    return null\n  end\n  \n  title: loc.dis()\n         + \" zone pressure differentials, relative setpoint compliance, \"\n         + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n         + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")\n  if (loc.has(\"site\")) title= \"B\" + title\n\n  return hisGrid.addMeta({title: title})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["bacnetObjType","intgUpdateConnCache"],,,,M,,,,,,"bacnetLearnCached",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function is the equivalent of bacnetLearn, but uses the cached records\n  created by intgUpdateConnCache instead of querying the BACnet device directly.\n  \n  If arg is \"all\", return all leaf objects\n*/\n\n(conn, arg:null) => do\n  if (isRef(conn)) conn= readById(conn)\n  pts: readAll(connPointCache and connRef==conn->id)\n  \n  if (isEmpty(pts)) return null\n  \n  // If arg is null, return only a list of unique point types\n  if (arg==null) do\n    grid: pts.keepCols([\"bacnetCur\",\"bacnetHis\"])\n             .map(row => if (row.has(\"bacnetCur\")) bacnetObjType(row->bacnetCur)\n                          else if (row.has(\"bacnetHis\")) bacnetObjType(row->bacnetHis)\n                          else null)\n                          \n    if (isEmpty(grid) or not(grid.has(\"learn\")) or not(grid.has(\"dis\")))\n      return null\n    \n    return grid.unique(\"learn\")\n               .reorderCols([\"dis\",\"learn\"])\n               .sort((a,b) => a->learn.parseNumber <=> b->learn.parseNumber)\n  end\n  \n  // Add point tag to all leaf nodes\n  pts= pts.addCol(\"point\", row => marker())\n  \n  if (arg==\"all\") return pts\n  \n  // If arg is a \"learn\" parameter, return only relevant points\n  grid: pts.addCol(\"learn\",\n      row => if (row.has(\"bacnetCur\")) bacnetObjType(row->bacnetCur)->learn\n             else if (row.has(\"bacnetHis\")) bacnetObjType(row->bacnetHis)->learn\n             else null)\n  \n  if (isNumber(arg)) arg= arg.toStr()\n  grid= grid.findAll(row => row->learn == arg)\n  \n  // Remove empty columns\n  nullColNames: grid.colNames.findAll(colName => do\n    grid.colToList(colName).all v => v == null\n  end)\n  grid= grid.removeCols(nullColNames)\n            .removeCols([\"id\",\"learn\",\"connRef\",\"connPointCache\",\"mod\"])\n  \n  // Sort columns by name and rows by \"dis\"\n  colNamesOrder: grid.colNames.sort((a,b) => a <=> b)\n  return grid.reorderCols(colNamesOrder)\n             .sort((a,b) => a->dis <=> b->dis)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"fillBACnetInfo",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function uses the bacnetLearn function to add the \"bacnetName\" tag\n  to BACnet points whose BACnet names are missing.\n  \n  Arguments:\n  conn          Record of the connector's display name that we want\n                to add a bacnetName tag to.\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2018-07-13 //\n*/\n\n(conn) => do\n  counter: 0\n  // Create a list of \"learn\" types to cycle through for each connector\n  learn_objects: bacnetLearn(conn)\n  if (learn_objects == null) do\n    return \"No Learn Ojects\"\n  end else do\n    learn_objects.each object => do\n      object =  object[\"learn\"]\n      // For each learn object, get a list of points with bacnetCur's\n      points: bacnetLearn(conn,object)\n      // For each point, get bacnetCur info, then compare it to the existing\n      // database (excluding points that already have the bacnetName tag) to\n      // try to find a matching conn and bacnetCur.\n      points.each point => do\n        pt_bacnetCur: point[\"bacnetCur\"]\n        // Comparison is an already integrated point with a bacnetConRef and\n        // bacnetCur but not a bacnetName. We compare our point to this comparison\n        // point to see if we need to add a bacnetName.\n        matchRec: readAll(point and bacnetCur and bacnetConnRef and not bacnetName)\n                    .find(row => row->bacnetConnRef->id==conn->id and row->bacnetCur==pt_bacnetCur)\n        if (matchRec != null) do\n          dis: point[\"dis\"]\n          counter = counter + 1\n          commit(diff(matchRec, {bacnetCurName: dis, tmp: today()}))\n        end\n      end\n    end\n    return {connector: conn->id, written: counter, status: \"OK\"}\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"hisReadIonSql",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n( sqlConn, point, dates ) => do\n\n  //Need to add some error checking\n  //if not point->equipRef->ionSqlConn then return False???\n\n  // Ask sql for UTC datetimes in text format, so it doesn't get inadvertently converted by JDBC\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND S.Name = '\" + point->equipRef->sqlMeter + \"'\" +\n       \" AND D.QuantityID = \" + point->sqlQID +\n       \" AND D.TimestampUTC >= '\" + dates.start.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\" +\n       \" AND D.TimestampUTC < '\" + dates.end.toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: read(sqlConn).sqlQuery(sql)\n\n  // Add \"UTC\" to tz-naive text strings from sql, then parse and convert to Los_Angeles time zone\n  mapped: data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                .toTimeZone(\"Los_Angeles\"),\n                            val: row->val }\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecsTags"],,,,M,,,,,,"tagListCompliance",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function finds all points that have non-ignored tag sets\n  that exactly match any tagSet and stores their id in \n  `io/tagging/taggingStandardMatches.csv`\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  // Initialize list that will store the id of compliant points\n  matches: []\n  \n  // Load dependencies\n  try ignoreTags: ioReadCsv(`io/config/ignoreTags.csv`)\n                  .colToList(\"ignoreTagsRegex\")\n  catch\n    return {error: \"io/config/ignoreTags.csv could not be loaded\"}.toGrid()\n\n  // Cycle through the tag sets\n  readAll(tagSet).each tagSet => do\n    // Convert to lists of tags\n    eqTagSet: if (tagSet.has(\"eqTags\")) tagSet->eqTags.split(\",\")\n              else null\n    ptTagSet: tagSet->ptTags.split(\",\")\n  \n    // Find all points with eqTags and ptTags matching the tagSet\n    filter: \"point and \"\n    // eqTags filter string\n    if (eqTagSet != null)\n      filter= filter + \"equipRef->\" + eqTagSet.concat(\" and equipRef->\") + \" and \"\n    // ptTags filter string\n    filter= filter + ptTagSet.concat(\" and \")\n    points: readAll(parseFilter(filter))\n  \n    // Remove ignored tags\n    points= points.toolRecsTags(ignoreTags)\n            \n    // Cycle through points, and remove matches that are not exact\n    points= points\n    .findAll(pt => do\n      tags: pt.remove(\"id\").findAll(v => v != null).names\n      return tags.all(tag => ptTagSet.contains(tag))\n    end)    \n    \n    // Add remaining points' ids to matches\n    points.each pt => matches= matches.add(pt->id.toStr)\n  end\n  \n  matches.ioWriteCsv(`io/tagging/taggingStandardMatches.csv`)\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAVTSI0",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_b33/tsi_integ_1of2.csv`\n to add these points to zone equips that exist and exhaust TUs that\n may not exist.\n \n The relation between ALC VAVs and the TSI integration programs\n is in file `io/integration_b33/vav_tsi.csv`\n \n The first file includes a match to the 2018-09-04 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n() => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b33/tsi_integ_0of2.csv`)\n  alcEqList: ioReadCsv(`io/integration_b33/vav_tsi.csv`)\n  \n  siteId: read(site and dis==\"33\")->id\n  \n  // Cycle through equips\n  alcEqList.findAll(row => row->controlProgram != \"lbnl33_tsi_8682_rht_bacnet\")\n           .each((eqRow, indexEqRow) => do\n    jobProgress((indexEqRow / alcEqList.size())*100.as(1%), eqRow->supplyVAV)\n    \n    supplyTUId: read(supply and terminalUnit and equip and siteRef->id==siteId\n                 and navName==\"Supply \"+reGroups(r\"33-(VAV-\\d{3})\",eqRow->supplyVAV)[1])->id\n    zoneId: supplyTUId->equipRef\n    numSupplyTUs: readAll(supply and terminalUnit and equip and equipRef==zoneId).foldCol(\"id\", count)\n    locationId: supplyTUId->locationRef\n    \n    if (numSupplyTUs != 1) throw \"Error, number of VAVs != 1 for \" + readById(zoneId)->navName\n    \n    // Create fume hood and exhaust terminal unit equips if needed\n    // Fume hood\n    /*if (read(fumeHood and equipRef==zoneId, false) == null) do\n      eqDict1: {navName: \"Fume Hood\",\n               disMacro: \"\\\$equipRef \\\$navName\",\n               equip,\n               equipRef: zoneId,\n               locationRef: locationId,\n               siteRef: siteId,\n               fumeHood,\n               test20180904}\n      commit(diff(null, eqDict1, {add}))\n    end // if no fume hood equip */\n    //fumeHoodId: read(fumeHood and equipRef==zoneId)->id\n    \n    // Exhaust terminal unit\n    /*if (read(exhaust and terminalUnit and equipRef==zoneId, false) == null) do\n      eqDict2: {navName: \"Exhaust TU\",\n               disMacro: \"\\\$equipRef \\\$navName\",\n               equip,\n               equipRef: zoneId,\n               locationRef: locationId,\n               siteRef: siteId,\n               exhaust,\n               terminalUnit,\n               test20180904}\n      commit(diff(null, eqDict2, {add}))\n    end // if no exhaust terminal unit equip */\n    //exhaustTUId: read(exhaust and terminalUnit and equipRef==zoneId)->id\n    \n    // Load needed connector, and TL and AV points list\n    connectorId: parseRef(eqRow->routerRef)\n    \n    bacnetLearn(connectorId)\n    bacnetPtList2: bacnetLearn(connectorId, 2)\n    if (isEmpty(bacnetPtList2)) return \"bacnetLearn failed\"\n    \n    bacnetLearn(connectorId)\n    bacnetTrendList: bacnetLearn(connectorId, 20)\n    if (isEmpty(bacnetTrendList)) return \"bacnetLearn failed\"\n  \n    // Go through list of points of interest for each eq and integrate\n    alcPtList.each ptRow => do\n      // Detect type of point to determine proper equipRef\n      if (ptRow->indexTagStandard.parseNumber() < 186) do equipId: zoneId\n      else if (ptRow->indexTagStandard.parseNumber() < 195) do equipId: supplyTUId\n      else if (ptRow->indexTagStandard.parseNumber() < 198) do equipId: exhaustTUId\n      else do equipId: fumeHoodId end\n      \n      // Find bacnetCur and related info\n      //bacnetDis: ptRow->bacnetDis + \"_\" + eqRow->instance\n      //bacnetRow: bacnetPtList2.find(row => row[\"dis\"]==bacnetDis)\n      //if (bacnetRow == null) return \"next point\"\n      \n      // Find bacnetHis\n      bacnetTrendDis: ptRow->bacnetTrendDis + \"_\" + eqRow->instance\n      bacnetTrendRow: bacnetTrendList.find(row => row[\"dis\"]==bacnetTrendDis)\n      if (bacnetTrendRow == null) return \"next point\"\n      \n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               bacnetHis: bacnetTrendRow->bacnetHis,\n               kind: \"Number\",\n               unit: \"°F\",\n               equipRef: equipId,\n               his,\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp20180905,\n               notes: ptRow->pointName}\n                \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==ptRow->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      commit(diff(null, ptDict, {add}))\n      \n    end // alcPtList.each ptRow\n  end) // alcEqList.each eqRow\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anFumeHoodSash"],,,,M,,,,,,"viFaceVelocityHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all fume hoods and calculate\n  their sash height using the function anFumeHoodSash\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n  rollupMinutes      Number in minutes, use for rollup\n  focus              Str, enum:\"All,Occupied,Unoccupied\"\n  scheduleRef        Ref for schedule to use along with focus\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastWeek(),\n rollupMinutes:15, focus:\"All\", scheduleRef:null,\n sp: 105, tolerance:5, advancedColors:true) => do\n  unit: \"ft/min\"\n  clipMin: (sp - 3*tolerance).as(unit)\n  clipMax: (sp + 3*tolerance).as(unit)\n  \n  // Colors option\n  colors: if (advancedColors)\n      \"#ff0000, #ff9933, #5cd65c, #5cd65c, #5cd65c, #3399ff, #0000ff\"\n          else\n      \"#ff0000, #ff9933, #5cd65c, #5cd65c, #5cd65c, #ff9933, #ff0000\"\n  \n  // Retrieve location / site record, then retrieve all fume hoods\n  loc: readById(locRef)\n  if (loc.has(\"site\"))\n    fvel: readAll(siteRef==locRef and face and air and speed\n                  and sensor and equipRef->fumeHood)\n  else\n    fvel: readAll(locationRef==locRef and face and air and speed\n                  and sensor and equipRef->fumeHood)\n  \n  if (isEmpty(fvel)) return null\n  \n  fvel= fvel.hisRead(dates, {limit: null})\n            .hisMap(v => if (v==null) return null\n                         else if (v==0) return na()\n                         else return v)\n            .hisRollup(avg, rollupMinutes.to(\"min\"))\n  \n  // Filter by focus / schedule\n  if (focus != \"All\" and scheduleRef != null) do\n    schedule: readById(scheduleRef)\n      \n    if (schedule->navName == \"Occupancy Sensors\")\n      // Placeholder, retrieve occ sensor info and filter\n      filterPeriods: null\n    else do\n      if (focus==\"Occupied\")\n        filterFunc: v => v\n      else\n        filterFunc: v => not(v)\n    \n      filterPeriods: scheduleHis(schedule, dates)\n                     .hisFindPeriods(filterFunc)\n    end\n  end else filterPeriods: null\n  \n  if (filterPeriods != null) do\n    // base grid and discard col are used to maintain entire ts array\n    // through filtering\n    base: fvel.keepCols([\"ts\",\"v0\"]).renameCol(\"v0\",\"discard\")\n    fvel= hisFindInPeriods(fvel, filterPeriods)\n    fvel= hisJoin([base,fvel]).removeCol(\"discard\")\n  end\n  \n  try do\n    fvel= fvel.hisMap(v => if (v == null) null\n                           else if (v == na()) na()\n                           else min(max(v.to(unit),clipMin.as(unit)),\n                                    clipMax.as(unit)))\n        .hisFlatten((val, ts, his) => \n               {ts: ts,\n                rm: his->equipRef->equipRef->navName + \" (\"\n                    + reGroups(\"(Fume Hood\\\\W? ?)?(.*)\",\n                               his->equipRef->navName)[2] + \")\",\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: clipMin.as(unit),\n                           chartMax: clipMax.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: colors})\n  catch (ex) do\n    return null\n  end\n  \n  title: loc.dis() + \" fume hoods face velocity, heat map, \"\n         + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n         + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")\n  if (loc.has(\"site\")) title= \"B\" + title\n  if (focus != \"All\")\n    title= title + \", \" + focus.decapitalize + \" hours only\"\n\n  return fvel.addMeta({title: title})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"mapALCPlantPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in given file, along with needed equip and\n connector info to add these points to equips that already exist.\n  \n The file includes a match to the most current tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(types: [0,1,2,3,4,5,19,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b6/b6_hhw.csv`)\n  \n  i: 0\n  \n  // Cycle through connectors\n  alcPtList.unique(\"connRef\").colToList(\"connRef\").each connRef => do\n    // Load bacnet info for connector\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, \"MS\", \"TL\"]\n    \n    connectorId: parseRef(connRef)\n    types.each type => do\n      learn: bacnetLearn(connectorId, type)\n      bacnetPtList= bacnetPtList.set(type, learn)\n    end\n  \n    // Cycle through points of interest on given connector\n    alcPtList.findAll(row => row->connRef == connRef).each row => do\n      // Update job message\n      jobProgress((i / alcPtList.size())*100.as(1%), row->alcDisplay)\n      i= i+1\n      \n      // Find related equip\n      eq: readById(parseRef(row->eq))\n      \n      // Get info from bacnetPtList by matching bacnetCur\n      curType: row->bacnetCur[0..1]\n      bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n      if (bacnetGrid == null) bacnetGrid= [].toGrid()\n      bacnetCurRow: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n      if (bacnetCurRow == null)\n        bacnetCurRow= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n        \n      // Find bacnetHis\n      bacnetHisGrid: bacnetPtList[20]\n      if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n      bacnetHisRow: bacnetHisGrid.find(his => his[\"dis\"]==row[\"bacnetHisName\"])\n      if (bacnetHisRow == null) bacnetHisRow= {}\n\n      // Prepare new point dict\n\t\t\tptDict: {point,\n\t\t\t\t\t disMacro: \"\\\$equipRef \\\$navName\",\n\t\t\t\t\t bacnetConnRef: connectorId,\n\t\t\t\t\t connRef: connectorId,\n\t\t\t\t\t cur,\n\t\t\t\t\t bacnetCur: row->bacnetCur,\n\t\t\t\t\t bacnetHis: bacnetHisRow[\"bacnetHis\"], //optional\n\t\t\t\t\t bacnetCurName: row->bacnetCurName,\n\t\t\t\t\t bacnetHisName: row[\"bacnetHisName\"],\n\t\t\t\t\t kind: bacnetCurRow[\"kind\"], //optional\n\t\t\t\t\t unit: bacnetCurRow[\"unit\"], //optional\n\t\t\t\t\t enum: bacnetCurRow[\"enum\"], //optional\n\t\t\t\t\t equipRef: eq->id,\n\t\t\t\t\t his,\n\t\t\t\t\t notes: row[\"alcDisplay\"], //optional\n\t\t\t\t\t locationRef: eq->locationRef,\n\t\t\t\t\t siteRef: eq->siteRef,\n\t\t\t\t\t tz: \"Los_Angeles\",\n\t\t\t\t\t tmp: today()}\n      \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      if (finalize)\n        commit(diff(null, ptDict, {add}))\n        \n    end // Cycle through points\n  end // Cycle through connectors\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"test20181210",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  locationId: @p:lbnl:r:22dbdae2-0f98c395\n  \n  pumpSpeeds: readAll(locationRef==locationId\n                     and equipRef->pump\n                     and speed\n                     and sensor)\n  \n  pumpSpeeds= pumpSpeeds.hisRead(yesterday, {limit:null})\n                    .hisMap((val, ts, his) => do\n                      pumpId: his->equipRef\n                      pumpRef: readById(pumpId)\n                      if (not(pumpRef.has(\"pump\"))) return val\n                      \n                      // Find pump status\n                      pumpStatusPt: read(point and run and sensor and equipRef==pumpId, false)\n                      if (pumpStatusPt == null) return val\n                      \n                      // Read pump status\n                      statusHis: pumpStatusPt.hisRead(ts)\n                      if (isEmpty(statusHis)) return val\n                      status: statusHis.first[\"v0\"]\n                      \n                      if (status == true) val\n                      else null\n                    end)\n                    \n  pumpSpeeds= pumpSpeeds.hisFoldCols(avg)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolFoldSparkHis",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given history grid of sparks (periods), combine all sparks to return\n  a single history trend of combined sparks periods.\n  \n  Arguments: \n  sparkHisGrid   Grid of spark periods\n*/\n\n(sparkHisGrid) => do\n  hisList: []\n  ruCount: sparkHisGrid.colNames.size -1\n  sparkHisGrid.removeCol(\"ts\").colNames.each colName => do\n    hisList= hisList\n      .add(sparkHisGrid.keepCols([\"ts\",colName])\n                       .findAll(row => row[colName] != null))\n  end\n  \n  hisPeriodMatrix(hisList)\n  .findAll(r => r->numTrue > 0)\n  .keepCols([\"ts\",\"dur\"])\n  .addColMeta(\"dur\",\n              {dis: \"Summary: \"+ruCount+\" Rules Sparked\",\n               spark,\n               chartType:\"runtime\"})\n  .addMeta({view:\"chart\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"scrapeConvertStrToNum",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function scrapes data from a DENT meter by accessing the\n website, finding the name of the csv that contains the data,\n and parsing through that csv for relevant values.\n\n Arguments:\n   string              Given a string, remove commas, then turn\n                       convert to a number.\n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-08-01 //\n*/\n\n(string) => do\n  string = string.replace(\",\",\"\")\n  string = parseNumber(string,checked:false)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"toolRecursiveSearch",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all records that match the given filter string and that have\n  an equipRef (or other specified ref) located at or below the given\n  equipRef (called trunkRef)\n  e.g. allows to find all the power sensors in a high-level equipment\n  such as a cooling tower, even if the power sensors are located\n  under the cooling tower fans.\n  \n  Example use:\n  toolRecursiveSearch(@p:lbnl:r:2322ffa1-a7bd7110, \"power and sensor\")\n  \n  Return grid similar to readAll\n  \n  Arguments: \n  trunkRef         Ref to an equip to search under\n  filterStr        String that will be parsed as filter\n  refTypes         List of strings, refs to follow (e.g. equipRef)\n  maxDepth         Number, stop after given number of iterations\n*/\n\n(trunkRef, filterStr: \"point\", refTypes:[\"equipRef\", \"zoneRef\"],\n maxDepth:10) => do\n  filterStrLoc: \"(\" + filterStr + \") and equipRef->id==@\" + toStr(trunkRef)\n  grid: readAll(parseFilter(filterStrLoc))\n  \n  // Find other equips pointing to current trunkRef\n  eqRefsStr: refTypes.map(v => v+\"==\"+trunkRef).concat(\" or \")\n  eqFilterStr: \"equip and \" + eqRefsStr\n  eqList: readAll(equip and equipRef==trunkRef)\n  if (isEmpty(eqList) or maxDepth==0) return grid\n  else do\n    eqList.each subeq => do\n      newRows: toolRecursiveSearch(subeq->id, filterStr, refTypes, maxDepth-1)\n      if (not(isEmpty(newRows))) grid = grid.addRows(newRows)\n    end\n  end\n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldHisDerivMax",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, ts, acc) => do\n  if (val == foldStart()) return {vlast:na(), tlast:0, dmax: 0}\n  if (val == foldEnd()) return acc->dmax\n  if (val == na()) return na()\n  \n  if (acc->tlast == 0) return {vlast: val, tlast: ts, dmax: 0}\n  if (acc->tlast == ts) return acc\n  return {vlast: val, tlast: ts,\n          dmax: max(acc->dmax,\n                    (val - acc->vlast)/(ts - acc->tlast))}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuDuctGain"],,,,M,,,,,,"calculateReheatLoads",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates zone reheat loads based on available airflow\n  and discharge air temperature info.\n  \n  After calculation, the values are written to an existing virtual point.\n  \n  Arguments:\n  restartDate (optional)   Date to rewrite history from. Must be\n                           a date, not a dateTime.\n  newOnly (optional)       If true, calculate only for points that\n                           have no history (not hisEnd)\n*/\n\n(restartDate:null, newOnly:false) => do\n\n  today: now().date\n  // We expect all virtual delta points with a pointRef\n  //  and no hisFunc can go through this function\n  filter: \"virtual and heat and coil and power and sensor and his\"\n          + \" and equipRef->terminalUnit\"\n  if (newOnly) filter = filter + \" and not hisEnd\"\n  query: parseFilter(filter)\n             \n  ptList: readAll(query)\n  loops: ptList.size()\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  //////// Cycle through each virtual point ////////\n  ptList.each((pt, i) => do\n    jobProgress(i/loops * 100.as(\"%\"), pt.dis())\n    \n    hisEnd: pt[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    argument). Assign dates based on the 4 possibilities\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input: clear history from restartDate\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate-1day, time(23,59,59))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd.date()..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start-1day,time(23,59,59))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start-1day,time(23,59,59))\n      end\n    end\n    \n    //////// Calculate load ////////\n    // Estimate entering air temp based on AHU SAT and\n    // average duct heat gain\n    try do  // Added error catching on 2018-10-24\n        if (not(readById(pt->equipRef).has(\"ahuRef\"))) return null\n        ahuId: readById(pt->equipRef->ahuRef)->id\n        \n        if (read(air and flow and sensor and\n                 equipRef==pt->equipRef,false) == null)\n          return null\n        airflowPt: read(air and flow and sensor and equipRef==pt->equipRef)\n        \n        if (read(discharge and air and temp and sensor and\n                 equipRef==pt->equipRef,false) == null)\n          return null\n        datPt: read(discharge and air and temp and sensor\n                    and equipRef==pt->equipRef)\n        \n        // Perform calcs one day at a time (for average heat gain)\n        dates.eachDay day => do\n          heatGain: anAhuDuctGain(ahuId, day-7day..day, 90min, 10, 60)\n          if (heatGain == null) return null // Skip to next day\n          eat: read(discharge and air and temp and sensor and equipRef==ahuId)\n               .hisRead(day, {limit: null})\n               .addCol(\"eat\", row => row->v0 + heatGain)\n               .keepCols([\"ts\",\"eat\"])\n          \n          airflow: airflowPt.hisRead(day, {limit: null}).renameCol(\"v0\",\"flow\")\n          dat: datPt.hisRead(day, {limit: null}).renameCol(\"v0\",\"dat\")\n          \n          load: hisJoin([eat, dat, airflow]).hisInterpolate()\n                .addCol(\"load\", row =>\n                    (1.08 * (row[\"dat\"] - row[\"eat\"]) * row[\"flow\"])\n                    .as(\"BTU/h\"))\n                .keepCols([\"ts\",\"load\"])\n                .findAll(row => row[\"load\"] >= 0)\n                \n          // Filter out redundant data (already in history)\n          filteredLoad: load.findAll(row => row->ts > hisEnd)\n                            .findAll(row => date(row->ts)==day)\n                            .sort((a,b) => a->ts <=> b->ts)\n          \n          // Write calculated data to history.\n          hisWrite(filteredLoad, pt)\n        end  // dates.eachDay day\n    catch (ex) do\n        commit(diff(pt, {hisErr: ex->dis}, {transient}))\n    end\n  end)  // ptList.each pt\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDiffPressErrorHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all zones, and calculate the error between their\n  differential pressure and pressure setpoint. Then, display results as a heat map\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n  maxDev             Number in inH2O, maximum deviation to display\n  rollupMinutes      Number in minutes, use for rollup\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastWeek(),\n maxDev: 0.02, rollupMinutes:15) => do\n  // Params\n  unit: \"inH₂O\"\n  colors: \"blue, palegreen, red\"\n \n  // Retrieve location / site record, then retrieve all zone pressures\n  loc: readById(locRef)\n  if (loc.has(\"site\"))\n    zones: readAll(zone and equip and siteRef==locRef)\n  else\n    zones: readAll(zone and equip and locationRef==locRef)\n   \n  // Filter out zones that do not have a dP setpoint\n  zones= zones\n  .findAll(z => read(equipRef==z->id and air and pressure and sp, false)!=null)\n\n  // Exit if no zones were found\n  if(isEmpty(zones)) return null\n\n  // Create grid of calculated histories\n  hisGrid: {}.toGrid()\n  \n  // Cycle through zones and create history of pressure devations\n  zones.each(zone => do\n    // Find pressure and pressure setpoint\n    dp: read(air and pressure and sensor and equipRef==zone->id, false)\n    dpsp: read(air and pressure and sp and equipRef==zone->id, false)\n    \n    // If either is missing, skip zone\n    if (dp==null or dpsp==null) return null\n    \n    // Col name based on zone name\n    colName: zone->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    grid: [dp, dpsp].hisRead(dates, {limit: null})\n        .hisRollup(avg, rollupMinutes.as(\"min\"))\n        .addCol(colName, row => do\n          if (row.remove(\"ts\").any(v => v==null or v==na()))\n            return null\n          else do\n            sign: if (row->v0==0) 1 else (row->v1 / abs(row->v1)).as(1)\n            err: min(maxDev,max(-maxDev, row->v1 - row->v0)).as(unit)\n            return err * sign\n          end\n        end)\n    .keepCols([\"ts\",colName])\n    .hisFindAll(val => val != null)\n    .addColMeta(colName, {dis: zone->navName})\n    \n    // Add to hisGrid summary array\n    if (isEmpty(grid)) return null\n    if (isEmpty(hisGrid)) hisGrid=grid\n    else hisGrid= hisJoin([grid,hisGrid])\n  end)\n  \n  if (isEmpty(hisGrid)) return null\n\n  try do\n    hisGrid= hisGrid\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollupMinutes<60) \":mm\" else \"\")+\"a\"),\n                rm: his->dis,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: -maxDev.as(unit),\n                           chartMax: maxDev.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: colors})\n  catch (ex) do\n    return null\n  end\n  \n  title: loc.dis()\n         + \" zone pressure errors, deviation towards zero, \"\n         + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n         + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")\n  if (loc.has(\"site\")) title= \"B\" + title\n\n  return hisGrid.addMeta({title: title})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  if (rec.missing(\"siteRef\"))\n    throw \"An associated equip or site is required\"\n  \n  if (rec.has(\"startDate\") or rec.has(\"endDate\")) do\n    startD: if (rec.has(\"startDate\") and rec[\"startDate\"]!=removeMarker()) rec[\"startDate\"]\n            else if (rec.has(\"id\")) readById(rec[\"id\"])[\"startDate\"]\n            else null\n    \n    endD: if (rec.has(\"endDate\") and rec[\"endDate\"]!=removeMarker()) rec[\"endDate\"]\n          else if (rec.has(\"id\")) readById(rec[\"id\"])[\"endDate\"]\n          else null\n          \n    if (startD != null and endD != null and startD > endD)\n      throw \"endDate needs to be after startDate\"\n  end\n    \n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"ptVirtualRatio",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load history of two points hisNumerator and hisDenominator, which\n  must have the same unit. Use hisRollup function specified by name\n  (attached to virtual point) to align histories then calculate\n  ratio.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n\n  Tags:\n  - virtual\n  --- hisFunc\n  --- hisRollup function with (val, acc) arguments\n  --- hisNumeratorRef\n  --- hisDenominatorRef\n  --- hisInterval (optional)\n*/\n\n(rec, dates, opts, yield) => do\n  // Normalize to absolute ref (for old Historian)\n  rec= rec->id.readById\n\n  // Determine numerator and denominator\n  numeratorPt: readById(rec->hisNumeratorRef)\n  denominatorPt: readById(rec->hisDenominatorRef)\n  if (numeratorPt->unit != denominatorPt->unit) return null\n  unit: if(rec.has(\"unit\") and rec->unit!=\"_\") rec->unit else 1\n  mult: if (unit==\"%\") 100 else 1\n  \n  // Check for presence of hisInterval tag\n  minRollup: if (rec.has(\"hisInterval\")) rec->hisInterval\n             else 0min\n  \n  // Determine rollup function\n  rollupFunc: eval(\"(val,acc)=>\"+rec->hisRollup+\"(val,acc)\")\n\n  // Read available history, align, calculate ratio, yield\n  hisGrid: [numeratorPt, denominatorPt]\n           .hisRead(dates, {limit:null})\n  hisGrid.toolHisAlign(rollupFunc, min,  // rollupFunc, intervalFunc\n                       true, minRollup)  // removeMissing, minRollup\n         .addCol(\"ratio\", row => do\n           numerator: row->v0.as(1)\n           denominator: row->v1.as(1)\n           if (denominator==0) return na()\n           return (numerator / denominator * mult).as(unit)\n         end)\n         .each(row => yield(row->ts, row->ratio))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["foldHisDiffMin"],,,,M,,,,,,"foldHisDiffMinNonZero",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  history fold function, to be used with hisRollup functions.\n  This function is equivalent to foldHisDiffMin, but excludes\n  decreases associated with a zeroing of the accumulator,\n  including a fixed margin of 100.\n*/\n\n(val, ts, acc) => do\n  // Fixed threshold for identifying a zeroing of the accumulator\n  threshZero: 100\n\n  // Initialization, end and treatment of na()\n  if (val == foldStart()) return {vlast:na(), dmin: 0}\n  if (val == foldEnd()) return acc->dmin\n  if (val == na()) return na()\n  \n  // Special cases: first value and zeroing\n  if (acc->vlast == na()) return {vlast: val, dmin: 0}\n  if ((val >=0) and (val <= threshZero))\n    return {vlast: val, dmin: acc->dmin}\n    \n  // Update of accumulator\n  return {vlast: val,\n          dmin: min(acc->dmin, (val - acc->vlast))}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anRegElecCddCalculate_v1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate regression of daily electricity usage versus CDD,\n  with factor of weekday / weekend (total 2 variables).\n  Return dictionary with:\n    results:  dict of model coefficients and fit statistics\n    graph:    chart grid for measured & fitted points\n    dataset:  grid of original dataset, plus fitted values\n  \n  Arguments: \n  meterUsageRef      Ref of elec meter usage data point (kWh)\n  dateSpan           Span of dates to perform analysis on\n  ddRefTemp          Reference temp for calculation of degree days\n  titlePrefix        (Optional) Title prefix for graph title\n\n  Notes:\n  For degree days calculation, the weather station associated with\n  the site associated with the meter usage point is used. Function\n  will fail if weatherRef is not defined on the corresponding site.\n*/\n\n(meterUsageRef, dateSpan, ddRefTemp, titlePrefix:\"\") => do\n  // Read usage from meter energy point\n  usage: readById(meterUsageRef)\n        .hisRead(dateSpan, {limit:null})\n        .hisRollup(sum, 1day)\n        .renameCol(\"v0\", \"usage\")\n  \n  // Reference value with unit, for later unit casting\n  refValue: 1kWh //.as(usage.first[\"usage\"])\n\n  // Read outside air temperature from weather station associated with\n  //   meterUsage point, and calculate degree days\n  cdd: read(weatherRef==readById(meterUsageRef)->siteRef->weatherRef\n            and weatherPoint and air and temp  // OAT is input to degreeDays\n            and not secondary)  // Do not use secondary sensor if one exists\n       .degreeDays(dateSpan, ddRefTemp)\n       .keepCols([\"ts\",\"cool\"])\n  \n  // Join regression data and filter out missing gas data points\n  dataset: hisJoin([cdd.hisRollup(sum, 1day), \n                    usage.hisRollup(sum, 1day)])\n             // Filter out dates with missing gas data\n             .findAll(row => row.has(\"usage\"))\n   \n  // Create design matrix, specifically apply day type factoring\n  //   to CDD, to separate weekdays and weekends\n  regMatrix: dataset.map row => {\n    ts: row->ts,\n    cddWeekday: if(isWeekday(row->ts)) row->cool else 0,\n    cddWeekend: if(isWeekday(row->ts)) 0 else row->cool,\n    usage: row->usage\n  }\n       \n  // Isolate dependent and independent variables for regression\n  y: regMatrix.keepCols([\"usage\"])\n  x: regMatrix.keepCols([\"cddWeekday\",\"cddWeekend\"])\n\n  // Perform regression and extract coefficients\n  reg: matrixFitLinearRegression(y, x)\n  intercept: reg.meta[\"bias\"]\n  slopeWeekday: reg[0][\"b\"]\n  slopeWeekend: reg[1][\"b\"]\n\n  // Calculate fitted values using coefficients and join with dataset\n  slope: null\n  dataset = dataset.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->cool).as(refValue)\n    end)\n  \n  // Calculate statistics\n  measuredTotal: y.foldCol(\"usage\", sum)\n  n: reg.meta[\"rowCount\"]\n  measuredAvg: measuredTotal / n\n  sqError: dataset.addCol(\"se\", row => pow(row->fittedUsage - row->usage,2))\n                  .foldCol(\"se\", sum)\n  p: 2\n  mse: sqError / (n-p)\n  rmse: sqrt(mse)\n  cvrmse: rmse / measuredAvg\n  \n  // Build dictionary of results\n  regRes: {\n    intercept: intercept,\n    slopeWeekday: slopeWeekday,\n    slopeWeekend: slopeWeekend,\n    rSquared: reg.meta[\"r2\"],\n    n: n,\n    p: p,\n    measuredAvg: measuredAvg,\n    mse: mse,\n    rmse: rmse,\n    cvrmse: (cvrmse*100).as(1%),\n    ddRefTemp: ddRefTemp\n  }\n\n  // Apply day type factoring to usage, for graphing purposes\n  usage_factor: dataset.map row => {\n    ts: row->ts,\n    usageWeekday: if(isWeekday(row->ts)) row->usage else null,\n    usageWeekend: if(isWeekday(row->ts)) null else row->usage\n  }\n\n  // Create graph of data, scatter plot of usage vs CDD\n  graph: hisJoin([cdd, usage_factor])\n    // Keep only useful data for scatter plot\n    .keepCols([\"cool\",\"usageWeekday\",\"usageWeekend\"])\n    // Sort so scatter plot uses proper xmin and xmax\n    .sort(\"cool\")\n    // Calculate fitted values per day type to show regression results\n    .addCol(\"regressionWeekday\", row => if(row.has(\"cool\"))\n      (intercept+regRes[\"slopeWeekday\"]*row->cool).as(refValue)\n      else null)\n    .addCol(\"regressionWeekend\", row => if(row.has(\"cool\"))\n      (intercept+regRes[\"slopeWeekend\"]*row->cool).as(refValue)\n      else null)\n    // Reorder columns to control overlay\n    .reorderCols([\"cool\",\"regressionWeekend\",\"regressionWeekday\",\n                  \"usageWeekend\",\"usageWeekday\"])\n    // Add meta data to control graph display\n    .addColMeta(\"usageWeekday\", {chartType:\"scatter\", chartGroup:\"main\",\n                                 color:\"#1D80F1\", chartMin: 0.as(1kWh)})\n    .addColMeta(\"usageWeekend\", {chartType:\"scatter\", chartGroup:\"main\",\n                                 color:\"#07203C\", chartMin: 0.as(1kWh)})\n    .addColMeta(\"regressionWeekday\", {chartType:\"scatter\", chartGroup:\"main\",\n                                      color:\"#C7DFFB\", chartMin: 0.as(1kWh)})\n    .addColMeta(\"regressionWeekend\", {chartType:\"scatter\", chartGroup:\"main\",\n                                      color:\"#C1C7CE\", chartMin: 0.as(1kWh)})\n    .addMeta({title:titlePrefix+\"Daily elec usage vs CDD grouped by day type\"})\n    \n  // Return dict of: (dict) regression results, (grid) graph, (grid) dataset\n  return {results:regRes, graph:graph, dataset:dataset}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Elec Power Norm (W/ft²)",,M,"Site electrical 15-minute average demand min, max, average normalized by ft².",,,"site",,"kpiElecPowerNorm",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(power and sensor and equipRef->elec\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n  if (pt == null or site->area==0) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisMap(v => if (v==na()) null else v)\n                                       .hisMap(v => v.to(1W))\n                                       .hisRollup(avg, 15min)\n                                       .energyNormByArea\n\n  if (his.isEmpty or\n      his.meta[\"hisEnd\"] < pt[\"hisStart\"] or\n      his.missing(\"v0\")) return null\n\n  kpi: {min: his.foldCol(\"v0\", min),\n        max: his.foldCol(\"v0\", max)}\n\n  if (kpi.any v => na() == v ) null else kpi.map v => v.as(1)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viContinuousAhuOp",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of run sensor data from ahu equips\n that have the continuousOp tag; grid is optimized for use as a chart.\n \n Arguments:\n span      dateSpan, span of dates for which to return data\n*/\n\n(span) => do\n  data: readAll(run and sensor and equipRef->ahu and equipRef->continuousOp)\n          //.addCol(\"equipName\", row => row->equipRef->navName)\n          //.sort(\"equipName\") // sort currently makes hisRead fail on long queries\n          .hisRead(span)\n  \n  data.colNames()[1..-1].each colName => do\n    data = data.addColMeta(colName, {chartGroup: data.col(colName).meta->siteRef->dis})\n  end\n  \n  return(data)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recNewDeficiency"],,,,M,,,,,,"recDuplicateDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Record duplication action for deficiency\n  \n  Arguments:\n  deficiencyDict       Dict containing only changes to the original\n                       selected record the duplication is based on.\n*/\n\n(deficiencyDict) => do\n  // Normalize action input\n  deficiencyDict= actionNormInput(deficiencyDict, \"dict\")\n  \n  // Load original dictionary based on id, this dict will contain\n  // all fields\n  originalDict: readById(deficiencyDict->id)\n  \n  // Initialize new dictionary for our new record\n  newDict: originalDict\n  \n  // Any record present in deficiencyDict represents a change\n  // from the originalDict. Apply change to newDict.\n  deficiencyDict.each((v,n) => do\n    newDict= newDict.set(n, v)\n  end)\n\n  // This will be a new record, remove \"id\" and \"mod\" fields\n  newDict= newDict\n  .remove(\"id\")\n  .remove(\"mod\")\n  \n  // Save record\n  recNewDeficiency(newDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","ptMetricsCoolingLoopPpue"],,,,M,,,,,,"viPPUECoolLine",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the cooling loop pPUE points for NERSC along with the contributing power trends\n  and construct a line chart with respect to for display on a graph\n    \n  Arguments: \n  dates            Span of dates we want to calculate the metric on\n  rollup           Rollup increment\n  bldgRef          siteRef, default to B59 \n*/\n\n(dates: today, rollup: 15min, bldgRef: null) => do\n  // Default to B59 if no bldgRef is provided\n  if(bldgRef==null)\n    bldgRef = read(site and dis==\"59\")->id\n  \n  //Grab each subsequent equipRef given the location\n    compRef: read(equip and siteRef==bldgRef and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id\n\n    wbRef: read(equip and siteRef==bldgRef and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n    pumpRef: read(equip and siteRef==bldgRef and locationRef->dis==\"B59 CW\" and navName==\"Plant\")->id\n  \n  // Get the Cooling Loop pPUE under this computer\n  loopPPUE: toolRecursiveSearch(compRef,\n                   \"hisFunc==\\\"ptMetricsCoolingLoopPpue\\\"\")\n\n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  // Get the compute meter, CW pumps and CRAY fans meter which contribute to this metric\n  compMeter: read(equipRef==compRef and navName==\"Compute Meter\")->id\n  fansMeter: read(equipRef==compRef and navName==\"Fans Meter\")->id\n      pumps: readAll(equipRef==pumpRef and pump and vfd and water)\n      \n  // Get the power point from each meter and read the history\n  compPower: read(equipRef==compMeter and power)\n                .hisRead(dates,{limit:null})\n                .hisRollup(avg, rollup)\n                .findAll(row => row.all(v => v != null))\n                .renameCol(\"v0\", \"compute\")\n  fansPower: read(equipRef==fansMeter and power)\n                .hisRead(dates,{limit:null})\n                .hisRollup(avg, rollup)\n                .findAll(row => row.all(v => v != null))\n                .renameCol(\"v0\", \"fans\")\n  \n  //Get the power points for the pumpps and fold them\n  pumpsPower: readAll(equipRef->pump and locationRef==pumpRef->locationRef and power)\n                .hisRead(dates,{limit:null})\n                .hisRollup(avg, rollup)\n                .findAll(row => row.all(v => v != null))\n  // sum pump power for total cw pump power              \n                .hisFoldCols(sum)\n                .renameCol(\"v0\", \"pumps\")\n\n  // Read the loop pPUE\n  loopTrend: hisRead(loopPPUE,dates,{limit:null})\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly\n                 .renameCol(\"v0\", \"loopppue\")\n  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .hisRollup(avg, rollup)\n                  .renameCol(\"v0\",\"oaWB\")\n\n  //Add OA Wetbulb, pPUE, and power trends the same graph\n  \n  metric: hisJoin([compPower, fansPower, pumpsPower, oaWetBulb, loopTrend])\n             .addColMeta(\"compute\",\n              {dis: \"CRAY Compute Power\",\n               unit: \"kW\", color: \"#FB8C00\",\n               chartGroup: \"a\"})\n             .addColMeta(\"fans\",\n              {dis: \"CRAY Fans Power\",\n               unit: \"kW\", color: \"#FDD835\",\n               chartGroup: \"b\"}) \n             .addColMeta(\"pumps\",\n              {dis: \"CW Pumps Power\",\n               unit: \"kW\", color: \"#5499C7\",\n               chartGroup: \"b\"}) \n             .addColMeta(\"oaWB\",\n              {dis: \"OAT WB\",\n               unit: \"°F\", color: \"#5E35B1\",\n               chartGroup: \"b\"})\n            .addColMeta(\"loopppue\",\n              {dis: \"Cooling Loop pPUE\",\n               unit: \"_\", color: \"#3F51B5\",\n               chartGroup: \"a\"})\n  return metric\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"viHeatRejectionEffectiveness",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find input and output power points under a certain system and calculate\n  heat rejection effectiveness.\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n  addedPtRecs      Optional, grid of additional points to show on graph\n*/\n\n(sysRef:null, dates: today, addedPtRecs: [null], rollup: null) => do\n  // Default to B59 TW Sys if no ref is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and navName==\"TW Sys\")->id\n\n  // Get all power sensor points under sysRef (recursive)\n  // All input powers must be in kW and not on a load meter\n  // Output power is from a load meter\n  inputPowerPts: toolRecursiveSearch(sysRef,\n                   \"point and power and sensor and unit==\\\"kW\\\"\" +\n                   \" and not equipRef->load and not equipRef->meter\")\n  outputPowerPts: toolRecursiveSearch(sysRef,\n                    \"point and power and sensor\" +\n                    \" and equipRef->load and equipRef->meter\")\n\n  // Interpolate, filter and calculate total input and output power\n  inputPowers: hisRead(inputPowerPts,dates,{limit:null})\n                 .hisInterpolate\n                 .findAll(row => row.all(v => v != null))\n  outputPowers: hisRead(outputPowerPts,dates,{limit:null})\n                  .hisInterpolate\n                  .findAll(row => row.all(v => v != null))\n\n  totalInputPower: inputPowers.hisFoldCols(sum)\n  totalOutputPower: outputPowers.hisFoldCols(sum)\n\n  //convert totalOutputPower to kW\n  totalOutputPower= hisMap(totalOutputPower, v => v.to(\"kW\"))\n\n  // Join input and output, then calculate effectiveness\n  totals: hisJoin([totalInputPower,totalOutputPower])\n            .hisInterpolate\n            .findAll(row => row.all(v => v != null))\n\n  totals= addCol(totals, \"heatRejectionEffectiveness\",\n                 row=> if(row->v1 != 0) row->v0 / row->v1 else null)\n  metric: keepCols(totals, [\"ts\",\"heatRejectionEffectiveness\"])\n            .hisMap(v => v.to(1))\n            .addColMeta(\"heatRejectionEffectiveness\",\n              {dis: readById(sysRef).dis + \" Heat Rejection Effectiveness\",\n               unit: \"\"})\n  \n  // Roll up metric if rollup not null\n  if (rollup != null) do\n    metricRollup: metric.hisRollup(covAvg, rollup)\n                    .map(row => {ts: row->ts+rollup/2, heatRejEffRollup:\n                                 row[\"heatRejectionEffectiveness\"]})\n                    .addColMeta(\"heatRejEffRollup\",\n                      {dis: readById(sysRef).dis +\n                       \" Heat Rejection Effectiveness, \" +\n                       rollup + \" average\"})\n    metric= hisJoin([metric, metricRollup])\n  end\n  \n  // Add other points to graph if addedPtRecs is not null\n  if (addedPtRecs != null and addedPtRecs.first != null\n      and not(isEmpty(addedPtRecs)))\n    metric= hisJoin([metric, addedPtRecs.hisRead(dates,{limit:null})])\n  \n  return metric\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"hisFixValuesMultiplierModhopper",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Fixing old data (history) from some meters that are off by a multiple of 10.\n*/\n\n\n(id_of_his, multiply_by, end_datetime) => do\n /* his: hisRead(readById(id_of_his), \n    readById(id_of_his)->hisStart..parseDateTime(end_datetime, pattern: \"YYYY-MM-DD hh:mm\"), {limit:null})\n  \n  list: []\n  his.each row => do\n    time: row.vals[0]\n    value: row.vals[1] * multiply_by\n    list = add(list, {ts: time, val: value})    \n    end\n  hisClear(readById(id_of_his), readById(id_of_his)->hisStart..end_datetime.parseDateTime(\"YYYY-MM-DD hh:mm\"))  \n  hisWrite(list, readById(id_of_his))   \n  */\n  list: [{ts: \"2019-07-31 12:55\".parseDateTime(\"YYYY-MM-DD hh:mm\"), val: \"6102410\".parseFloat()}]\n  hisRemove(readById(id_of_his), \"2019-07-31 12:55\".parseDateTime(\"YYYY-MM-DD hh:mm\"))\n  hisWrite(list, readById(id_of_his))\n  \nend  \n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viAhuZoneReheats",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, load reheat valve positions for all TUs\n  served by that AHU then display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  rollup       duration, interval for rollup\n  colors       optional, colors string for heat map\n*/\n\n(ahuRef, dates: yesterday(), rollup: 15min, colors: \"green, red\") => do\n  pts: readAll(heat and valve and cmd\n               and equipRef->supply and equipRef->terminalUnit\n               and equipRef->ahuRef==ahuRef)\n               \n  if(isEmpty(pts)) return null\n  \n  try do\n    pos: pts.hisRead(dates, {limit:null})\n    \n    if (rollup>0)\n      pos= pos.hisRollup(avg, rollup)\n    else\n      pos= pos.toolHisAlign(avg, max)\n    \n    pos=pos.hisFlatten((val, ts, his) => do\n        eq: readById(his->equipRef)\n        room: if (eq.has(\"equipRef\"))\n                readById(eq->equipRef)\n              else\n                eq\n        dis: if (readAll(supply and terminalUnit and equipRef==room->id).size >= 2)\n               room->navName + \" \" +\n               reGroups(\"\"\"(Supply,? )?(.*)\"\"\", eq->navName)[2]\n             else room->navName\n        {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n         rm: dis,\n         v0: val}\n    end)\n    .reorderCols([\"ts\",\"rm\",\"v0\"])\n    .addColMeta(\"v0\", {chartMin: 0%,\n                       chartMax: 100%})\n    .addMeta({view: \"chart\", chartType:\"heatMap\", \n              title: \"Reheat valve commands, zones served by \"\n                     + readById(ahuRef).dis() + \", \"\n                     + pos.meta[\"hisRollupInterval\"],\n              colors: colors})\n  catch (ex) do\n    pos: null\n  end\n  return pos\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recMarkMonthlyReadSkipped",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Assign ignore:\"Skipped\" tag to selected monthly read.\n  \n  Arguments:\n  sel        Selection, id of monthly read to edit.\n*/\n\n(sel) => do\n  // Normalize action input\n  sel= actionNormInput(sel, \"id\")\n  \n  // Edit record\n  rec: readById(sel)\n  rec= rec.set(\"ignore\",\"Skipped\")\n  \n  // Submit change\n  recEdit(rec)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuDuctGain"],,,,M,,,,,,"calculateZoneLoads",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates zone loads based on available airflow\n  and discharge air temperature info.\n  \n  After calculation, the values are written to an existing virtual point.\n  \n  Arguments:\n  restartDate (optional)   Date to rewrite history from. Must be\n                           a date, not a dateTime.\n  newOnly (optional)       If true, calculate only for points that\n                           have no history (not hisEnd)\n*/\n\n(restartDate:null, newOnly:false) => do\n\n  today: now().date\n  // We expect all virtual delta points with a pointRef\n  //  and no hisFunc can go through this function\n  filter: \"virtual and zone and power and sensor and his\"\n          + \" and equipRef->terminalUnit\"\n  if (newOnly) filter = filter + \" and not hisEnd\"\n  query: parseFilter(filter)\n             \n  ptList: readAll(query)\n  loops: ptList.size()\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  //////// Cycle through each virtual point ////////\n  ptList.each((pt, i) => do\n    jobProgress(i/loops * 100.as(\"%\"), pt.dis())\n    \n    hisEnd: pt[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    argument). Assign dates based on the 4 possibilities\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input: clear history from restartDate\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate-1day, time(23,59,59))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd.date()..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start-1day,time(23,59,59))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start-1day,time(23,59,59))\n      end\n    end\n    \n    //////// Calculate load ////////\n    // Estimate entering air temp based on AHU SAT and\n    // average duct heat gain\n    try do  // Added error catching on 2018-10-24\n        if (not(readById(pt->equipRef).has(\"ahuRef\"))) return null\n        ahuId: readById(pt->equipRef->ahuRef)->id\n        \n        if (read(air and flow and sensor and\n                 equipRef==pt->equipRef,false) == null)\n          return null\n        airflowPt: read(air and flow and sensor and equipRef==pt->equipRef)\n        \n        datPt: read(discharge and air and temp and sensor\n                    and equipRef==pt->equipRef, false)\n\n        if (read(zone and air and temp and sensor and\n                 equipRef==pt->equipRef,false) == null)\n          return null\n        zatPt: read(zone and air and temp and sensor and equipRef==pt->equipRef)\n        \n        // Perform calcs one day at a time (for average heat gain)\n        dates.eachDay day => do\n          heatGain: anAhuDuctGain(ahuId, day-7day..day, 90min, 10, 60)\n          if (heatGain == null) return null // Skip to next day\n          eat: read(discharge and air and temp and sensor and equipRef==ahuId)\n               .hisRead(day, {limit: null})\n               .addCol(\"eat\", row => row->v0 + heatGain)\n               .keepCols([\"ts\",\"eat\"])\n          \n          airflow: airflowPt.hisRead(day, {limit: null}).renameCol(\"v0\",\"flow\")\n          \n          if (datPt != null)\n            dat: datPt.hisRead(day, {limit: null}).renameCol(\"v0\",\"dat\")\n          else\n            dat: eat.renameCol(\"eat\",\"dat\")\n          \n          zat: zatPt.hisRead(day, {limit: null}).renameCol(\"v0\",\"zat\")\n          \n          load: hisJoin([zat, dat, airflow]).hisInterpolate()\n                .addCol(\"load\", row =>\n                    (1.08 * (row[\"zat\"] - row[\"dat\"]) * row[\"flow\"])\n                    .as(\"BTU/h\"))\n                .keepCols([\"ts\",\"load\"])\n                .findAll(row => row[\"load\"] != null)\n                \n          // Filter out redundant data (already in history)\n          filteredLoad: load.findAll(row => row->ts > hisEnd)\n                            .findAll(row => date(row->ts)==day)\n                            .sort((a,b) => a->ts <=> b->ts)\n          \n          // Write calculated data to history.\n          hisWrite(filteredLoad, pt)\n        end  // dates.eachDay day\n    catch (ex) do\n        commit(diff(pt, {hisErr: ex->dis}, {transient}))\n    end\n  end)  // ptList.each pt\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Elec Meter Uptime",,M,"Site electricity meter uptime as a percentage of the observed time period. By default electricity meter data is expected every 15 minutes and zeros are considered invalid.",,,"site",,"kpiElecMeterUptime",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates the percentage of time electricity\n meter power data is available from the meter; for example if\n there is no missing data or invalid data during the given\n period, this function will return 100%\n  \n  \n Arguments:\n *** Typical arguments for kpiFunc\n interval    time interval at which we expect data to come in\n zeroValid   if false, then 0 is not considered a valid reading\n*/\n\n(site, dates, interval: 15min, zeroValid: false) => do\n  pt: read(power and sensor and equipRef->elec and equipRef->siteMeter and\n           siteRef==site->id and not equipRef->duplicate, false)\n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisRollup(max, interval)\n  \n  if (his.isEmpty or\n      his.meta[\"hisEnd\"] < pt[\"hisStart\"] or\n      his.missing(\"v0\")) return null\n\n  checked: his.map row => do\n    {val: if (row[\"v0\"] == null or (row[\"v0\"] == 0 and not zeroValid)) 0 else 1}\n  end\n  \n  expected: checked.foldCol(\"val\",count)\n  valid: checked.foldCol(\"val\",sum)\n  \n  if (expected == 0) return 0%\n  \n  kpiValid: valid / expected * 100\n  if (kpiValid == na()) null else {avg: kpiValid.as(1%)}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolExportFunc"],,,,M,,,,,,"toolExportFunc",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given function name or list of names, load function records \n  as well as any func dependencies. Remove transient tags. Export results\n  to `io/tmp/func.zinc`\n  \n  Arguments: \n  fNamesList     List of Str, names of target functions\n                    Can also be one Str, will be converted to [Str]\n  level             Number, used for recursiveness, 0 is main call\n*/\n\n(fNamesList, level:0) => do\n  // If single name given, convert to list\n  if (isStr(fNamesList)) fNamesList= [fNamesList]\n  // Remove duplicates\n  fNamesList= fNamesList.unique()\n  // Initialize updated list of fNames to keep track of changes\n  fNamesListU: fNamesList\n  \n  // Go through list and add dependencies within list\n  fNamesList.each fName => do\n    // Find function by name\n    f: read(func and name==fName, false)\n    // Remove name from list if function not found\n    if (f==null) fNamesListU= fNamesListU.findAll(v => v!=fName)\n    // Add dependencies if function found\n    else if (f.has(\"depends\"))\n      fNamesListU= fNamesListU.addAll(f->depends)\n  end\n  \n  // Remove duplicates from new list\n  fNamesListU= fNamesListU.unique()\n\n  // Compare lists to determine if any changes were made\n  noChanges: fNamesListU.all(fName => fNamesList.contains(fName))\n             and\n             fNamesList.all(fName => fNamesListU.contains(fName))\n\n  // If changes were made, call function again to evaluate\n  // dependencies of the functions that were added\n  if (not(noChanges))\n    fNamesListFinal: toolExportFunc(fNamesListU, level+1)\n  else\n    fNamesListFinal: fNamesListU\n  \n  // Recursive calls return\n  if (level > 0) return fNamesListFinal\n  // Main call continues (level == 0), if list is empty exit\n  if (fNamesListFinal.size==0) return null\n \n  // Load function and all dependencies\n  fs: readAll(func).findAll(r => fNamesListFinal.contains(r->name))\n  \n  // Remove empty columns\n  nullColNames: fs.colNames.findAll colName => do\n    fs.all row => row[colName] == null\n  end\n  fs= fs.removeCols(nullColNames)\n\n  // Remove transient tags\n  fs= fs.removeCols([\"id\",\"mod\"])\n  \n  // Store results\n  fs.ioWriteZinc(`io/tmp/func.zinc`)\nend\n\n/*\n  Updates\n  2019-10-14  Raphael Vitti\n    Added recursiveness for dependency trees\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"suOpFacilities",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// super user only\n// modifies user records\n\n/*\n\nOriginal\n  appAccess: \"doc,favs,his,lbnlIonMeterDashboard,kpi,lbnlWeather,lbnlMeasuresMonitoring,spark,weather,hisUi2\"\n\nDefault\n  appAccess: \"als,doc,favs,his,lbnlWeather,spark,trendAnalysis,weather,hisUi2\"\n\n\n*/\n\n() => do\n  appAccess: \"als,doc,favs,his,lbnlWeather,spark,trendAnalysis,weather,hisUi2\"\n  projAccessFilter: \"name == \\\"lbnl\\\"\"\n\n  userReadAll(userGroup==\"opFacilities\")\n    .each user => userEdit({id:user->id,\n                            mod:user->mod,\n                            appAccess:appAccess,\n                            projAccessFilter:projAccessFilter,\n                            reportCanSave})\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualAny",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a Bool virtual point, which \n  equals true if any of the points which have a virtualRef equal\n  to the id of the virtual point are true.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap(x => if (x==null) na() else if(x) 1 else 0)\n         .hisFoldCols(max)\n         .hisMap(x => if(x==na()) null else if(x==1) true else false)\n         .each(row => if(row[\"v0\"] != null) yield(row->ts, row->v0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualAnyAbove",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a Bool virtual point, which \n  equals true if any of the points which have a virtualRef equal\n  to the id of the virtual point have a value greater than or\n  equal to their virtualAbove. For example, use with supply fan\n  speed feedbacks to calculate a status.\n \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  pts:readAll(virtualRef==rec->id)\n  \n  if (isEmpty(pts)) return null\n  \n  pts.hisRead(dates, {limit: null})\n     .hisInterpolate()\n     .hisMap((val, ts, his) => if (val==null) na() else\n                               if(val > his->virtualAbove) 1 else 0)\n     .hisFoldCols(max)\n     .hisMap(x => if(x==na()) null else if(x==1) true else false)\n     .each(row => if(row[\"v0\"] != null) yield(row->ts, row->v0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap91RoomS",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create terminal units\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b91/zones_and_supply.csv`)\n  \n  siteDis: \"91\"\n  siteId: read(site and dis==siteDis)->id\n  \n  // Cycle through each row of CSV file\n  file.each row => do\n    // Prepare location\n    floorDis: row[\"floor\"]\n    locationDis: \"B91 Floor \" + floorDis    \n    location: read(location and siteRef==siteId and\n                   dis==locationDis, false) \n                   \n    // Create location if it doesn't exist\n    if (location==null) do\n      locDict: {\n        dis: locationDis,\n        location,\n        siteRef: siteId,\n      }\n      \n      locationId: commit(diff(null, locDict, {add}))->id\n    end else locationId: location->id\n    \n    // If the equipment serves multiple rooms, create HVAC zone\n    zones: file.findAll(r => r->vav==row->vav)\n    mult: if (zones.size > 1) true else false\n    \n    if (mult) do\n      // Prepare HVAC zone\n      hvacZoneDis: \"Rm \"+zones.colToList(\"room\").concat(\", \")\n      hvacZone: read(zone and locationRef==locationId and\n                     navName==hvacZoneDis, false)\n      // Create zone if it doesn't exist\n      if (hvacZone==null) do\n        hvacZoneDict: {\n          disMacro: \"\\\$locationRef \\\$navName\",\n          equip,\n          locationRef: locationId,\n          navName: hvacZoneDis,\n          siteRef: siteId,\n          zone,\n        }\n      \n        hvacZoneId: commit(diff(null, hvacZoneDict, {add}))->id\n      end else hvacZoneId: hvacZone->id\n    end\n    \n    // Prepare zone\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    zone: read(zone and locationRef==locationId and\n               navName==roomDis, false)\n    \n    // Create zone if it doesn't exist\n    if (zone==null) do\n      zoneDict: {\n        disMacro: \"\\\$locationRef \\\$navName\",\n        equip,\n        locationRef: locationId,\n        navName: roomDis,\n        equipRef: if(mult) hvacZoneId else null,\n        siteRef: siteId,\n        zone,\n      }\n      \n      zoneId: commit(diff(null, zoneDict, {add}))->id\n    end else zoneId: zone->id\n    \n    // Prepare supply equip\n    eqDis: reGroups(\"^91-(.{3}-\\\\d\\\\d\\\\d)\",row[\"vav\"])[1]\n    // Add \"S\" to \"VAV\", all supply VAVs in this file\n    if (eqDis[0..2]==\"VAV\") eqDis= \"S\"+eqDis\n\n    eq: read(locationRef==locationId and\n             equip and navName==eqDis, false)\n    \n    // Create equip if it doesn't exist\n    if (eq==null) do\n      eqDict: {\n        navName: eqDis,\n        disMacro: \"\\\$equipRef \\\$navName\",\n        supply: if(eqDis[1..3]==\"VAV\") marker() else null,\n        terminalUnit: if(eqDis[1..3]==\"VAV\") marker() else null,\n        fcu: if(eqDis[0..2]==\"FCU\") marker() else null,\n        equip,\n        locationRef: locationId,\n        siteRef: siteId,\n        equipRef: if (mult) hvacZoneId else zoneId,\n      }\n\n      commit(diff(null, eqDict, {add}))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap34PCHWSCHW",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_b6/b6_hhw.csv`\n to add these points to zone equips that already exist.\n  \n The file includes a match to the 2018-10-22 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(types: [0,1,2,3,4,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b34/b34_pchw_schw.csv`)\n  \n  i: 0\n  \n  // Cycle through connectors\n  alcPtList.unique(\"connRef\").colToList(\"connRef\").each connRef => do\n    // Load bacnet info for connector\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, \"MS\", \"TL\"]\n    \n    connectorId: parseRef(connRef)\n    types.each type => do\n      learn: bacnetLearn(connectorId, type)\n      bacnetPtList= bacnetPtList.set(type, learn)\n    end\n  \n    // Cycle through points of interest on given connector\n    alcPtList.findAll(row => row->connRef == connRef).each row => do\n      // Update job message\n      jobProgress((i / alcPtList.size())*100.as(1%), row->alcDisplay)\n      i= i+1\n      \n      // Find related equip\n      eq: readById(parseRef(row->eq))\n      \n      // Get info from bacnetPtList by matching bacnetCur\n      curType: row->bacnetCur[0..1]\n      bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n      if (bacnetGrid == null) bacnetGrid= [].toGrid()\n      bacnetCurRow: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n      if (bacnetCurRow == null)\n        bacnetCurRow= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n        \n      // Find bacnetHis\n      bacnetHisGrid: bacnetPtList[20]\n      if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n      bacnetHisRow: bacnetHisGrid.find(his => his[\"dis\"]==row[\"bacnetHisName\"])\n      if (bacnetHisRow == null) bacnetHisRow= {}\n\n      // Prepare new point dict\n\t\t\tptDict: {point,\n\t\t\t\t\t disMacro: \"\\\$equipRef \\\$navName\",\n\t\t\t\t\t bacnetConnRef: connectorId,\n\t\t\t\t\t connRef: connectorId,\n\t\t\t\t\t cur,\n\t\t\t\t\t bacnetCur: row->bacnetCur,\n\t\t\t\t\t bacnetHis: bacnetHisRow[\"bacnetHis\"], //optional\n\t\t\t\t\t bacnetCurName: row->bacnetCurName,\n\t\t\t\t\t bacnetHisName: row[\"bacnetHisName\"],\n\t\t\t\t\t kind: bacnetCurRow[\"kind\"], //optional\n\t\t\t\t\t unit: bacnetCurRow[\"unit\"], //optional\n\t\t\t\t\t enum: bacnetCurRow[\"enum\"], //optional\n\t\t\t\t\t equipRef: eq->id,\n\t\t\t\t\t his,\n\t\t\t\t\t notes: row[\"alcDisplay\"], //optional\n\t\t\t\t\t locationRef: eq->locationRef,\n\t\t\t\t\t siteRef: eq->siteRef,\n\t\t\t\t\t tz: \"Los_Angeles\",\n\t\t\t\t\t tmp: today()}\n      \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      if (finalize)\n        commit(diff(null, ptDict, {add}))\n        \n    end // Cycle through points\n  end // Cycle through connectors\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAirChangeRate"],,,,M,,,,,,"viAirChangeRateHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all zones, and calculate\n  their air change rate using the function anAirChangeRate. Then,\n  display results as a heat map\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n  rollupMinutes      Number in minutes, use for rollup\n  focus              Str, enum:\"All,Occupied,Unoccupied\"\n  scheduleRef        Ref for schedule to use along with focus\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastWeek(),\n rollupMinutes:15, focus:\"All\", scheduleRef:null,\n showErrors: false, clip:12_ach, exhaust:true, relative:true,\n overrideMinAcr:null) => do\n  unit: if (relative) \"%\" else \"_ach\"\n  clipMin: if (relative) 90% else 0_ach\n  clipMax: if (relative) 130% else clip\n  colors: if (relative)\n    \"#ff0000, #ff9933, #5cd65c, #5cd65c, #5cd65c, #45a185, #2e6bae, #1736d6, #0000ff\"\n          else\n    \"#ff3385,#bf26a4,#801ac2,#400de1,#0000ff\"\n  \n  // Retrieve location / site record, then retrieve all fume hoods\n  loc: readById(locRef)\n  if (loc.has(\"site\"))\n    zones: readAll(zone and equip and minAirChangeRate and siteRef==locRef)\n  else\n    zones: readAll(zone and equip and minAirChangeRate and locationRef==locRef)\n    \n  // Exit if no fume hoods were found\n  if(isEmpty(zones)) return null\n  \n  // Create grid of calculated histories\n  hisGrid: null\n  \n  // Filter by focus / schedule\n  if (focus != \"All\" and scheduleRef != null) do\n    schedule: readById(scheduleRef)\n      \n    if (schedule->navName == \"Occupancy Sensors\")\n      // Placeholder, retrieve occ sensor info and filter\n      filterPeriods: null\n    else do\n      if (focus==\"Occupied\")\n        filterFunc: v => v\n      else\n        filterFunc: v => not(v)\n    \n      filterPeriods: scheduleHis(schedule, dates)\n                     .hisFindPeriods(filterFunc)\n    end\n  end else filterPeriods: null\n  \n  // Calculate sash heights and combine\n  zones.each zone => do\n    airChange: anAirChangeRate(zone->id, dates, exhaust, true)  \n    if (airChange==null or isEmpty(airChange)) return null\n    \n    if (relative) do\n      airChange= airChange\n      .addCol(\"achievedACRpcent\", row => do\n        minAcr: if (overrideMinAcr==null) row[\"minACR\"] else overrideMinAcr\n        if (row[\"achievedACR\"]==null or minAcr==null) return null\n        else if (row[\"achievedACR\"]==na() or minAcr==na()) return na()\n        else return (row[\"achievedACR\"] / minAcr * 100).as(\"%\")\n      end)\n      .addColMeta(\"achievedACRpcent\",\n        {equipRef: airChange.col(\"achievedACR\").meta[\"equipRef\"],\n         airChangeRatePercent, sensor, virtual,\n         kind:\"Number\", unit:\"%\"})\n      .keepCols([\"ts\",\"achievedACRpcent\"])\n      .renameCol(\"achievedACRpcent\",\"acr\")\n    end else do\n      airChange= airChange\n      .keepCols([\"ts\",\"achievedACR\"])\n      .renameCol(\"achievedACR\",\"acr\")\n    end\n    \n    if (showErrors == false)\n      airChange= airChange\n        .hisMap(v => if (v==null or v==na()) return null else return v)\n    \n    if (filterPeriods != null)\n      airChange= hisFindInPeriods(airChange, filterPeriods)\n    \n    if (hisGrid==null) hisGrid= airChange\n    else hisGrid= hisJoin([hisGrid, airChange])\n  end\n  \n  hisGrid= hisGrid.hisRollup(avg, rollupMinutes.to(\"min\"))\n\n  try do\n    hisGrid= hisGrid.hisMap(v => if (v == null) null\n                            else if (v == na()) na()\n                            else min(max(v.to(unit),clipMin),clipMax))\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollupMinutes<60) \":mm\" else \"\")+\"a\"),\n                rm: his->equipRef->navName,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: clipMin.as(unit),\n                           chartMax: clipMax.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: colors})\n  catch (ex) do\n    return null\n  end\n  \n  title: loc.dis() + (if (relative) \" relative\" else \"\")\n         + \" air change rates, heat map, \"\n         + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n         + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")\n  if (loc.has(\"site\")) title= \"B\" + title\n  if (focus != \"All\")\n    title= title + \", \" + focus.decapitalize + \" hours only\"\n\n  return hisGrid.addMeta({title: title})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneCoolingNeeds","toolRecursiveSearch","anAhuZonePressureNeeds","anAhuZoneHeatingNeeds"],,,,M,,,,,,"viAhuSatTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find AHU data points related to the AHU SAT, as well as related\n  terminal unit trends of interest. Analyzes the zone trends to\n  return a summary of zones in need of more cooling or more heating.\n  Load and display historical data for all these points across\n  the given date span.\n  \n  Arguments: \n  ahuRef       ref, id of the AHU\n  dates        dateSpan, dates of data to display\n  oatSat       bool, if true, display AHU OAT with SAT trends\n  heatNeeds    bool, it true, display count of TUs that need heating\n  statusFilter bool, if true, display trends only when AHU is ON\n  ahuReqs      bool, if true, display AHU request sensor trends\n  tolerance    number, increases ZAT cooling setpoint and reduces\n               ZAT heating setpoint\n  threshold    number, threshold to compare damper position to\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), oatSat: true, heatNeeds: false,\n statusFilter: false, ahuReqs:true, ahuVlvDpr: false, ahuSpd: false,\n ahuPwr: false, tolerance: 1°F, threshold: 95%,\n rollup: 15min, add:\"\") => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Calculation of total requests requires a rollup\n  reqRollup: if(rollup < 5min) 5min else rollup\n  \n  // Retrieve and compile counts of zones that need more cooling,\n  // heating or pressure\n  coolCount: anAhuZoneCoolingNeeds(ahuRef, dates, tolerance, reqRollup)\n  presCount: anAhuZonePressureNeeds(ahuRef, dates, threshold, reqRollup)\n  \n  needs: try [coolCount,presCount]\n             .findAll(v => v != null)\n             .hisJoin\n         catch null\n  \n  if (heatNeeds) do\n    heatCount: anAhuZoneHeatingNeeds(ahuRef, dates, tolerance, reqRollup)\n    if (heatCount != null)\n      if (needs != null)\n        needs= hisJoin([needs,heatCount])\n      else needs= heatCount\n  end\n  \n  // Retrieve weather station points of interest\n  wsOat: read(weatherPoint and weatherRef==ahu->siteRef->weatherRef\n              and air and temp and sensor and not secondary)\n         .hisRead(dates, {limit: null})\n         .addColMeta(\"v0\", {weatherPoint: null, chartGroup: \"OAT\",\n                            color: \"#225600\"})\n  \n  // Retrieve one copy of AHU OAT, if available, to superimpose\n  oatPt: read(point and outside and air and temp and equipRef==ahuRef,\n              false)\n  if (oatPt != null) do\n    oat: oatPt.hisRead(dates, {limit:null})\n              .addColMeta(\"v0\", {color: \"#02ce93\"})\n    oatHis: hisJoin([wsOat, oat.addColMeta(\"v0\", {chartGroup: \"OAT\"})])\n  end else\n    oatHis: wsOat\n  \n  // Retrieve AHU points of interest\n  //ahuFilter: \"equipRef==@\"+ toStr(ahuRef) + \" and point and (\"\n  //           + \"(air and temp and discharge)\"\n  //           + (if(ahuReqs) \" or (request and sensor)\" else \"\")\n  //           + (if(ahuVlvDpr) \" or ((valve or damper) and cmd)\" else \"\")\n  //           + (if(ahuSpd) \" or (speed and sensor)\" else \"\")\n  //           + (if(ahuPwr) \" or (power and sensor)\" else \"\")\n  //           + (if(add!=\"\") \" or (\" + add + \")\" else \"\")\n  //           + \")\"\n  recursiveFilter: \"point and (\"\n                   + \"(air and temp and discharge)\"\n                   + \" or (zone and air and temp)\"\n                   + (if(ahuReqs) \" or (request and sensor)\" else \"\")\n                   + (if(ahuVlvDpr) \" or ((valve or damper) and cmd)\" else \"\")\n                   + (if(ahuSpd) \" or (speed and sensor)\" else \"\")\n                   + (if(ahuPwr) \" or (power and sensor)\" else \"\")\n                   + (if(add!=\"\") \" or (\" + add + \")\" else \"\")\n                   + \")\"\n  //satHis: readAll(parseFilter(ahuFilter))\n  //        .hisRead(dates, {limit: null})\n  satHis: toolRecursiveSearch(ahuRef, recursiveFilter)\n          .hisRead(dates, {limit: null})\n   \n   if (isEmpty(satHis)) return null\n  \n  // Add AHU status, if available, and prepare status filter\n  statusPt: read(run and sensor and point and equipRef==ahuRef, false)\n  if (statusPt != null) do\n    statusHis: statusPt.hisRead(dates, {limit:null})\n    satHis= hisJoin([satHis, statusHis])\n    filterPeriods: statusHis.hisFindPeriods(val =>\n        if(val != null) val else null)\n  end else filterPeriods: null\n  \n  if (oatSat and oatPt != null) do\n    ahuHis: hisJoin([satHis,oat])\n  end else ahuHis: satHis\n  \n  // Apply rollup\n  if (rollup > 0) do\n    oatHis= oatHis.hisInterpolate.hisRollupAuto(rollup)\n    ahuHis= ahuHis.hisInterpolate.hisRollupAuto(rollup)\n  end\n  \n  // Join all trends and return\n  if (needs == null)\n    hisGrid: hisJoin([oatHis,ahuHis])\n  else\n    hisGrid: hisJoin([oatHis,ahuHis,needs])\n    \n  // Filter by status (optional)\n  if (statusFilter and filterPeriods != null)\n    hisGrid= hisGrid.hisFindInPeriods(filterPeriods)\n  \n  // Format hisGrid with meta\n  hisGrid.removeCols([\"ts\"]).colNames.each colName => do\n    hisGrid= hisGrid.addColMeta(colName, {strokeWidth: 2})\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"viSysCOP",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find input and output power points under a certain system and calculate\n  heat rejection effectiveness.\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n  addedPtRecs      Optional, grid of additional points to show on graph\n*/\n\n(sysRef:null, dates: today, addedPtRecs: [null], rollup: null) => do\n  // Default to B59 TW Sys if no ref is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and navName==\"TW Sys\")->id\n\n  // Get all power sensor points under sysRef (recursive)\n  // All input powers must be in kW and not on a load meter\n  // Output power is from a load meter\n  inputPowerPts: toolRecursiveSearch(sysRef,\n                   \"point and power and sensor and unit==\\\"kW\\\"\" +\n                   \" and not equipRef->load and not equipRef->meter\")\n  outputPowerPts: toolRecursiveSearch(sysRef,\n                    \"point and power and sensor\" +\n                    \" and equipRef->load and equipRef->meter\")\n\n  // Interpolate, filter and calculate total input and output power\n  inputPowers: hisRead(inputPowerPts,dates,{limit:null})\n                 .hisInterpolate\n                 .findAll(row => row.all(v => v != null))\n  outputPowers: hisRead(outputPowerPts,dates,{limit:null})\n                  .hisInterpolate\n                  .findAll(row => row.all(v => v != null))\n\n  totalInputPower: inputPowers.hisFoldCols(sum).renameCol(\"v0\",\"in\")\n  totalOutputPower: outputPowers.hisFoldCols(sum).renameCol(\"v0\",\"out\")\n                                .hisMap(v => if (v != null) v.to(\"kBTU/h\"))\n\n  //convert totalOutputPower to kW\n  totalOutputPower= totalOutputPower.addCol(\"out_kW\",\n      row => if(row->out == null) null else row->out.to(\"kW\"))\n\n  // Join input and output, then calculate effectiveness\n  totals: hisJoin([totalInputPower,totalOutputPower])\n            .hisInterpolate\n            .findAll(row => row.all(v => v != null))\n\n  totals= addCol(totals, \"sysCOP\",\n                 row => if(row->in != 0) (row->out_kW / row->in).as(\"_\") else null)\n  metric: keepCols(totals, [\"ts\",\"sysCOP\",\"in\",\"out\"])\n            .addColMeta(\"sysCOP\",\n              {dis: readById(sysRef).dis + \" Coeff. of Performance\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"in\",\n              {dis: readById(sysRef).dis + \" Total Input Power (kW)\",\n               unit: \"kW\", chartGroup: \"p\", color: \"#ba7c00\"})\n            .addColMeta(\"out\",\n              {dis: readById(sysRef).dis + \" Total Plant Load (kBTU/h)\",\n               unit: \"kBTU/h\", chartGroup: \"p\", color: \"#42b6f4\"})\n            \n  // Roll up metric if rollup not null\n  if (rollup != null) do\n    metricRollup: metric.hisRollup(covAvg, rollup)\n                    .map(row => {ts: row->ts+rollup/2, sysCOPRollup:\n                                 row[\"sysCOP\"]})\n                    .addColMeta(\"sysCOPRollup\",\n                      {dis: readById(sysRef).dis +\n                       \" Coeff. of Performance, \" +\n                       rollup + \" average\", unit: \"_\",\n                       color: \"#595959\", strokeWidth: 3})\n    metric= hisJoin([metric, metricRollup])\n  end\n  \n  // Add other points to graph if addedPtRecs is not null\n  if (addedPtRecs != null and addedPtRecs.first != null\n      and not(isEmpty(addedPtRecs)))\n    addedPtRecs= hisRead(addedPtRecs,dates,{limit:null})\n                 .addColMeta(\"v0\",\n                   {unit: \"°F\", chartGroup: \"added\",\n                  color: \"#483D8B\"})\n                 .addColMeta(\"v1\",\n                   {unit: \"°F\", chartGroup: \"added\",\n                   color: \"#4682B4\"})\n    metric= hisJoin([metric, addedPtRecs])\n  \n  // Tweak units of other points to get COP towards top of chart\n  metric= metric.hisMap(v => if (v != null and unit(v) != \"_\") v.as(\"_\" + unit(v)) else v)\n  \n  return metric\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Compared Deviation",,M,,,,,,"hisDeviationCompare_v1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// duration: time shift for comparison\n// number:   low percentile threshold, high threshold will be 1-number (symmetrical)\n\n(point, dates, duration, number) => do\n  // Number input defines our low percentile threshold, limit to 0 - 30\n  if (number>30) do percentile:30\n  end else if (number<0) do percentile:0\n  end else do percentile:number end\n\n  // Read data from current historian display, get meta info needed for proper display\n  r_current: point.hisRead(dates)\n  his_meta: r_current.meta\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_c_lo: round(r_current.size*percentile/100,0)\n  i_c_hi: round(r_current.size*(1.0 - percentile/100),0)\n  current_ref: r_current.sort(\"v0\")[i_c_lo..i_c_hi].foldCol(\"v0\",avg)\n  r_current = r_current.addCol(\"v0_ref\", row => current_ref)\n  \n  // Read data from earlier, shift timestamps to current historian display, make grid\n  r: point.hisRead(dates - duration)\n  list_ts: colToList(r,\"ts\")\n  list_v1: colToList(r,\"v0\")\n  list_ts0: list_ts.map s => s + duration\n  r_past: list_ts0.toGrid.map( (row,index) => {ts:row->val, v1:list_v1[index]} )\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_p_lo: round(r_past.size*percentile/100,0)\n  i_p_hi: round(r_past.size*(1.0 - percentile/100),0)\n  past_ref: r_past.sort(\"v1\")[i_p_lo..i_p_hi].foldCol(\"v1\",avg)\n  r_past = r_past.addCol(\"v1_ref\", row => past_ref)\n  \n  // Merge current and past grids and set meta information for proper display\n  r_past_meta: r_past.addMeta(his_meta)\n  r_joined: hisJoin([r_current, r_past_meta])\n  \n  point_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"dis\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  r_out: r_joined.addColMeta(\"v0\", {dis: point_dis, color: \"#3d80df\"})\n                 .addColMeta(\"v0_ref\", {dis: point_dis+\" reference value\", color: \"#4dcde1\"})\n                 .addColMeta(\"v1\", {dis: duration+\" earlier: \"+point_dis, color: \"#d73d40\"})\n                 .addColMeta(\"v1_ref\", {dis: duration+\" earlier: \"+point_dis+\" reference value\", color: \"#c123b0\"})\n                 .addMeta({dis: \"LAGGED \"+duration+\" \"+point_dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolSplitTrends"],,,,M,,,,,,"anRegCddCalculate_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate regression of daily natural gas usage versus HDD,\n  with factor of weekday / weekend (total 2 variables).\n  Return dictionary with:\n    results:  dict of model coefficients and fit statistics\n    graph:    chart grid for measured & fitted points\n    dataset:  grid of original dataset, plus fitted values\n  \n  Arguments: \n  meterUsageRef      Ref of gas meter usage data point (Btu or therm)\n  dateSpan           Span of dates to perform analysis on\n  ddRefTemp          Reference temp for calculation of degree days\n  titlePrefix        (Optional) Title prefix for graph title\n  datesHighlight     Span of dates to highlight in graph\n\n  Notes:\n  For degree days calculation, the weather station associated with\n  the site associated with the meter usage point is used. Function\n  will fail if weatherRef is not defined on the corresponding site.\n*/\n\n(meterUsageRef: @p:lbnl:r:2204f59c-5e34a792, dateSpan:2018, ddRefTemp:60°F,\n titlePrefix:\"\", datesHighlight:pastMonth()) => do\n  // Read usage from meter energy point\n  usage: readById(meterUsageRef)\n        .hisRead(dateSpan, {limit:null})\n        .hisRollup(sum, 1day)\n        .renameCol(\"v0\", \"usage\")\n  \n  // Reference value with unit, for later unit casting\n  refValue: 1.as(usage.first[\"usage\"])\n\n  // Read outside air temperature from weather station associated with\n  //   meterUsage point, and calculate degree days\n  cdd: read(weatherRef==readById(meterUsageRef)->siteRef->weatherRef\n            and weatherPoint and air and temp  // OAT is input to degreeDays\n            and not secondary)  // Do not use secondary sensor if one exists\n       .degreeDays(dateSpan, ddRefTemp)\n       .keepCols([\"ts\",\"cool\"])\n  \n  // Join regression data and filter out missing gas data points\n  dataset: hisJoin([cdd.hisRollup(sum, 1day), \n                    usage.hisRollup(sum, 1day)])\n             // Filter out dates with missing gas data\n             .findAll(row => row.has(\"usage\"))\n   \n  // Create design matrix, specifically apply day type factoring\n  //   to HDD, to separate weekdays and weekends\n  regMatrix: dataset.map row => {\n    ts: row->ts,\n    cddWeekday: if(isWeekday(row->ts)) row->cool else 0,\n    cddWeekend: if(isWeekday(row->ts)) 0 else row->cool,\n    usage: row->usage\n  }\n       \n  // Isolate dependent and independent variables for regression\n  y: regMatrix.keepCols([\"usage\"])\n  x: regMatrix.keepCols([\"cddWeekday\",\"cddWeekend\"])\n\n  // Perform regression and extract coefficients\n  reg: matrixFitLinearRegression(y, x)\n  intercept: reg.meta[\"bias\"]\n  slopeWeekday: reg[0][\"b\"]\n  slopeWeekend: reg[1][\"b\"]\n\n  // Calculate fitted values using coefficients and join with dataset\n  slope: null\n  dataset = dataset.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->cool).as(refValue)\n    end)\n  \n  // Calculate statistics\n  measuredTotal: y.foldCol(\"usage\", sum)\n  n: reg.meta[\"rowCount\"]\n  measuredAvg: measuredTotal / n\n  sqError: dataset.addCol(\"se\", row => pow(row->fittedUsage - row->usage,2))\n                  .foldCol(\"se\", sum)\n  p: 2\n  mse: sqError / (n-p)\n  rmse: sqrt(mse)\n  cvrmse: rmse / measuredAvg\n  \n  // Build dictionary of results\n  regRes: {\n    intercept: intercept,\n    slopeWeekday: slopeWeekday,\n    slopeWeekend: slopeWeekend,\n    rSquared: reg.meta[\"r2\"],\n    n: n,\n    p: p,\n    measuredAvg: measuredAvg,\n    mse: mse,\n    rmse: rmse,\n    cvrmse: (cvrmse*100).as(1%),\n    ddRefTemp: ddRefTemp\n  }\n\n  // Apply day type factoring to usage, for graphing purposes\n  usage_factor: dataset.map row => {\n    ts: row->ts,\n    usageWeekday: if(isWeekday(row->ts)) row->usage else null,\n    usageWeekend: if(isWeekday(row->ts)) null else row->usage\n  }\n  usage_factor= usage_factor\n    .addColMeta(\"usageWeekday\", {dis: \"Weekday\"})\n    .addColMeta(\"usageWeekend\", {dis: \"Weekend\"})\n\n  usage_factor= toolSplitTrends(usage_factor, datesHighlight, \"orange\")\n  selectedCols: usage_factor.colNames().findAll(v => v != \"ts\")\n                .insert(0, \"cool\")\n  selCols2: selectedCols.insert(1, \"regressionWeekend\")\n                        .insert(2, \"regressionWeekday\")\n\n  // Create graph of data, scatter plot of usage vs HDD\n  graph: hisJoin([cdd, usage_factor])\n    // Keep only useful data for scatter plot\n    .keepCols(selectedCols)\n    // Sort so scatter plot uses proper xmin and xmax\n    .sort(\"cool\")\n    // Calculate fitted values per day type to show regression results\n    .addCol(\"regressionWeekday\", row => if(row.has(\"cool\"))\n      (intercept+regRes[\"slopeWeekday\"]*row->cool).as(refValue)\n      else null)\n    .addCol(\"regressionWeekend\", row => if(row.has(\"cool\"))\n      (intercept+regRes[\"slopeWeekend\"]*row->cool).as(refValue)\n      else null)\n    // Reorder columns to control overlay\n    .reorderCols(selCols2)\n    // Add meta data to control graph display\n    .addColMeta(\"usageWeekday\", {color:\"#1D80F1\", chartGroup:\"all\"})\n    .addColMeta(\"usageWeekend\", {color:\"#07203C\", chartGroup:\"all\"})\n    .addColMeta(\"regressionWeekday\", {color:\"#C7DFFB\", chartGroup:\"all\"})\n    .addColMeta(\"regressionWeekend\", {color:\"#C1C7CE\", chartGroup:\"all\"})\n    .addMeta({title:titlePrefix+\"Daily gas usage vs CDD grouped by day type\"})\n    \n  // Force all on same graph\n  graph.colNames.findAll(v => v != \"cool\").each colName =>\n    graph= graph.addColMeta(colName, {chartType:\"scatter\", chartGroup:\"all\"})\n    \n  // Return dict of: (dict) regression results, (grid) graph, (grid) dataset\n  return {results:regRes, graph:graph, dataset:dataset}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap67AhuVav",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  file: ioReadCsv(`io/integration_b67/b67_ahu_vav.csv`)\n  siteId: read(site and dis==\"67\")->id\n  \n  file.each row => do\n    zone: read(zone and equip and siteRef==siteId and navName==\"Rm \"+row->room)\n    ahuName: \"AHU-0\" + reGroups(r\"67-AHU-00(\\d)\", row->ahu)[1]\n    \n    ahu: read(ahu and equip and siteRef==siteId and navName==ahuName)\n    \n    supplyTUs: readAll(equip and supply and terminalUnit and equipRef==zone->id)\n    \n    supplyTUs.each(eq => commit(diff(eq, {ahuRef: ahu->id, tmp: today()})))\n  end  // file.each row\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolSplitTrends"],,,,M,,,,,,"viSystemPowerWetBulbScatter",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of 15-minute CT Fan Power, CW Pump Power \n  and TW Pump Power vs OA WB Temp data at B59 (in °F)\n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01), dateRangePost: lastWeek().toSpan(),\n min: null, max: null, selectTrend: \"All\", rollup:15min) => do\n  // Default to B59 for siteRef\n  bldgRef: read(site and dis==\"59\")   \n  bldgRefId: bldgRef->id\n\n  // Define full range from pre and post date ranges\n  rangeStart: dateRangePre.start().date()\n  rangeEnd: dateRangePost.end().date()\n  \n  fullRange: toDateSpan(rangeStart..rangeEnd)\n   \n  // Look up B59 Data Center Computers for compute power filter\n  compRef: read(siteRef==bldgRefId and locationRef->dis==\"B59 Data Center\"\n                and navName==\"Computers\")->id  \n\n  // Get compute power for given computers filter\n  compFilter: read(equipRef==compRef and compute and meter and virtual and equip)\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n\n    \n  // Get the reference for the TW and CW Plants\n  cwPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and treatedWaterPlant\n                    and navName == \"Plant\")\n  \n  \n  twPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and condenserWaterPlant\n                    and navName == \"Plant\")\n                    \n  //wetbulb temperature (defaulting to the same location as the default \n   wbTemp: read(equipRef==twPlantEquip->id and outside and point and sensor and wetBulb)\n           .hisRead(fullRange, {limit:null})\n           .hisRollup(avg, rollup)\n           .renameCol(\"v0\",\"oaWetbulb\")\n\n  // Get the power points for the TW pumps, CT Fans, and CW Pumps\n  twPumpPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n  ctFanPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->fan\n                    and power\n                    and sensor)\n  \n  cwPumpPowers: readAll(locationRef==cwPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n   // Sum the power histories for each system, TW Pumps, CT Fans, and CW Pumps\n   totTWPumpPower: hisRead(twPumpPowers, fullRange, {limit:null})\n                   .hisRollup(avg, rollup)\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"twPump\")\n   \n   totCTFanPower: hisRead(ctFanPowers, fullRange, {limit:null})\n                   .hisRollup(avg, rollup)  \n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"ctFan\")\n\n   totCWPumpPower: hisRead(cwPumpPowers, fullRange, {limit:null})\n                   .hisRollup(avg, rollup) \n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"cwPump\")\n   \n    // join power trends\n   allTrends: hisJoin([totTWPumpPower, totCTFanPower, totCWPumpPower]).\n              keepCols([\"ts\",\"twPump\",\"ctFan\",\"cwPump\"])\n\n              \n  // use toolSplitTrends to highlight the post range\n   allSysPost:   toolSplitTrends(allTrends, dateRangePost)\n                   .renameCol(\"twPump0\",\"twPumpPost\")\n                   .removeCol(\"twPump\")\n                   .renameCol(\"ctFan0\",\"ctFanPost\")\n                   .removeCol(\"ctFan\")\n                   .renameCol(\"cwPump0\",\"cwPumpPost\")\n                   .removeCol(\"cwPump\")\n                   \n  // use toolSplitTrends to highlight the pre range\n   allSysPre:   toolSplitTrends(allTrends, dateRangePre)\n                   .renameCol(\"twPump0\",\"twPumpPre\")\n                   .removeCol(\"twPump\")\n                   .renameCol(\"ctFan0\",\"ctFanPre\")\n                   .removeCol(\"ctFan\")\n                   .renameCol(\"cwPump0\",\"cwPumpPre\")\n                   .removeCol(\"cwPump\")\n          \n   allSysPower: hisJoin([allSysPost,allSysPre])\n  \n  //select columns to be used in graph\n   selectCols:  allSysPower.colNames().findAll(v => v != \"ts\")\n                   .insert(0, \"oaWetbulb\")\n  \n\n  //define compute power filter\n  powerFilter: hisRead(compPower, fullRange, {limit:null})\n  // Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))                  \n  \n  // join wetbulb and total power pre trend to prep for the scatter chart\n  // add title and meta to graph\n       graph: hisJoin([wbTemp, allSysPower])\n             .hisFindInPeriods(powerFilter)\n             .keepCols(selectCols)\n             .addMeta({chartType: \"scatter\",\n              title: \"Components of Total System Power (Pre or Post)\"})\n             .addColMeta(\"oaWetbulb\", {chartMin: 40°F, chartMax: 70°F})\n             .addColMeta(\"twPumpPre\", \n                     {dis: \"Baseline TW Pump Power\",\n                      color: \"#B482D2\",\n                      chartMin: 0kW,\n                      chartMax: 300kW,\n                      chartGroup: \"all\"})\n             .addColMeta(\"ctFanPre\", \n                     {dis: \"Baseline CT Fan Power\",\n                      color: \"#F3D085\",\n                      chartGroup: \"all\"})\n             .addColMeta(\"cwPumpPre\",\n                      {dis: \"Baseline CW Pump Power\",\n                      color: \"#87B880\",\n                      chartGroup: \"all\"}) \n             .addColMeta(\"twPumpPost\", \n                     {dis: \"Post TW Pump Power\",\n                      color: \"#6A04A5\",\n                      chartGroup: \"all\"})\n             .addColMeta(\"ctFanPost\", \n                     {dis: \"Post CT Fan Power\",\n                      color: \"#E8A10B\",\n                      chartGroup: \"all\"})\n             .addColMeta(\"cwPumpPost\",\n                      {dis: \"Post CW Pump Power\",\n                      color: \"#0E7101\",\n                      chartGroup: \"all\"}) \n  \n  //Select columns to include in graph based on filter\n  \n  if(selectTrend == \"Tower Water Pump\")\n  graph = graph.keepCols([\"oaWetbulb\",\"twPumpPre\",\"twPumpPost\"])\n  \n  if(selectTrend == \"Cooling Water Pump\")\n  graph = graph.keepCols([\"oaWetbulb\",\"cwPumpPre\",\"cwPumpPost\"])\n  \n  if(selectTrend == \"Cooling Tower Fan\")\n  graph = graph.keepCols([\"oaWetbulb\",\"ctFanPre\",\"ctFanPost\"])\n  \n  return graph\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptMetricsCoolingSystemPpue","toolRecursiveSearch"],,,,M,,,,,,"viPPUESysScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the pPUE points for the computer cooling system\n  and construct a scatter chart with respect to outside\n  air wetbulb temperature for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(dates: today, sysRef:null, wbRef:null) => do\n  // Default to B59 Data Center Computers if no sysRef is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id\n\n  // Default to B59 TW if no wbRef is provided\n  if(wbRef==null)\n    wbRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n  // Get the pPUEs under this computer\n  sysPPUE: toolRecursiveSearch(sysRef,\n                   \"hisFunc==\\\"ptMetricsCoolingSystemPpue\\\"\")\n\n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  // Interpolate, filter and calculate total input and output power\n  sysTrend: hisRead(sysPPUE,dates,{limit:null})\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"sysppue\")\n\n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .renameCol(\"v0\",\"oaWB\")\n\n  //Add OA Wetbulb to the collection of pPUEs\n  \n  \n  metric: hisJoin([oaWetBulb, sysTrend])\n            .addColMeta(\"oaWB\",\n              {chartType: \"scatter\",\n               dis: \"OAT WB\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"sysppue\",\n              {chartType: \"scatter\",\n               dis: \"TUE\",\n               unit: \"_\", color: \"#9B59B6\",\n               chartGroup: \"all\"})\n            \n  metricScatter: metric.keepCols([\"oaWB\",\"sysppue\"])\n                       .addMeta({chartType: \"scatter\", \n                               title: \"TUE vs. Outside Air Wetbulb Temperature\"})\n  \n  return metricScatter\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"psyHumidityRatioPw",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate humidity ratio,\n    from ASHRAE Fundamentals (2009) p 1.8, equation 22\n  \n  Arguments (unit conversions applied as first step):        \n  pressureWater     partial pressure of water vapor [kpa]\n  ambientPressure   Ambient pressure [kPa]\n*/\n\n(pressureWater, ambientPressure) => do\n  // Unit conversions\n  pressureWater = pressureWater.to(\"kPa\")\n  ambientPressure = ambientPressure.to(\"kPa\")\n  \n  // Drop units for calculations\n  pressureWater = pressureWater.as(1)\n  ambientPressure = ambientPressure.as(1)\n\n  // Calcs and return with unit\n  humidityRatio: 0.621945 * pressureWater / (ambientPressure - pressureWater)\n  return (humidityRatio*1000).as(1gH₂O/kgAir)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["backfillJace","backfillJaceJob"],,,,M,,,,,,"backfillJaceJob",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// This function is the outline for the job to test if it will work\n// For pt and col inputs, see backfillJace()\n// range: csv numbers. There are only TWO options for this:\n      // (1) 20..0\n      // (2) 40..21\n      \n// Example: backfillJaceJob(20..0,readById(@p:lbnl:r:258a7b4a-90993339),1)\n\n(range,pt,col) => do\n  list: (range).map i => do\n    val: echo(i)\n      if(i<10) do\n        name: \"JACE_without_elec_00\"+val+\".csv\"\n      end else if (i>=10 and i<100) do\n        name: \"JACE_without_elec_0\"+val+\".csv\"\n      end else if (i>=100) do\n        name: \"JACE_without_elec_\"+val+\".csv\"\n      end\n    {name:name}\n  end\n  \n  list.each csv => do\n    backfillJace(csv[\"name\"],pt,col)\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["foldHisDiffMin"],,"Accumulator Decreased",,M,"Accumulator decreased and decrease did not meet rollover conditions",,,,,"ruMeterAccDecreaseNotRollover",,"meter","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates) => do\n  // Get all accumulator points\n  accs: readAll(point and accumulator and sensor\n                and not virtual\n                and equipRef==equip->id)\n  if (isEmpty(accs)) return null\n  \n  accs.hisRead(dates, {limit:null})\n      .hisRollup(foldHisDiffMin, 24hr)\n      .hisFindPeriods((val, ts, his) => do\n        rollover: his[\"rollover\"]\n        maxStep: his[\"maxAccStep\"]\n        if (rollover != null and maxStep == null)\n          maxStep= rollover / 10\n        if (rollover == null or maxStep == null)\n          return (val < 0)\n        else\n          return (val < 0) and\n                 (val < -rollover or\n                  val > (-rollover + maxStep))\n      end)\n end\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptPowerIntegrator","toolRecursiveSearch"],,,,M,,,,,,"ptVirtualTotalPowerIntegrator",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  total energy value, calculated from power history from all \n  power sensor points which are in the same equip or\n  in a subequip. Uses ptPowerIntegrator function.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  equipId: rec->equipRef\n  maxGap: rec->hisMaxGap\n  interpolateNaN: rec->hisInterpolateNaN\n  \n  filterStr: \"point and power and sensor and not virtual\"\n  pts: toolRecursiveSearch(equipId, filterStr)\n  \n  hisGrid: null\n  pts.each pt => do\n    energyHisGrid: ptPowerIntegrator(pt->id, dates, maxGap)\n                   .hisRollup(sum, maxGap)\n    \n    // If interpolating across NaN values, switch NaN to null then interpolate\n    if (interpolateNaN)\n      energyHisGrid= energyHisGrid\n                     .hisMap(v => if(v==na()) null else v)\n                     .hisInterpolate()\n    // Else, interpolate with NaN values to spread them across gaps\n    else energyHisGrid= energyHisGrid.hisInterpolate()\n    \n    if (hisGrid==null) hisGrid= energyHisGrid\n    else hisGrid= hisJoin([hisGrid, energyHisGrid])\n  end\n  \n  // Totalize energy\n  hisGrid= hisGrid.hisFoldCols(sum)\n  \n  // Return results\n  hisGrid.each(row => yield(row[\"ts\"], row[\"v0\"]))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"analyzeBuildingOS",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function compares\n \n ***Before running this script, two things must be done:\n   1.) A csv of the format Link##-##.csv must be uploaded to Folio.\n       The beginning must be \"Link.\" The first ## may be 1 or 2\n       digits, depending on the link number. The second ## must be\n       2 digits.\n   2.) A point with the tag \"BuildingOS\" must already exist. The\n       value of the tag should be the link as a string.\n\n Arguments:\n link        Link is a string of the link number you want to fill\n             BuildingOS data.\n             \n tolerance   (optional) Tells what value of percent difference you\n             would like returned. The default is a 10% tolerance,\n             meaning the function will return data where SkySpark and\n             csv data are more than\n             10% different from \n                          \n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-12-5 //\n*/\n\n(link,tolerance:0.1) => do\n  skysparkPt: readAll(point and gas).find(accumulator and siteRef==\"Links (meters)\" and link==link and not virtual and not buildingOS) // figure out how to be precise\n  buildingOSPt: readAll(point and gas).find(buildingOS and link==link)\n  \n  dates: skysparkPt->hisStart..skysparkPt->hisEnd\n  \n  skysparkHis: hisRead(skysparkPt,dates)\n  buildingOSHis: hisRead(buildingOSPt,dates)\n  \n  error: (skysparkHis-buildingOSHis)/buildingOSHis\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpImportDeficiencies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(csvFileName:`io/tmp/sprint24.csv`) => do\n  grid: ioReadCsv(csvFileName)\n  grid.each row => do\n    sprintRef: if (row.has(\"sprint\")) read(sprint==parseNumber(row->sprint))->id\n               else null\n    siteDis: if (row->building==\"0\") \"TOT HILL\"\n             else if (row->building==\"50\") \"50s\"\n             else try parseInt(row->building, 10).format(\"00\")\n                  catch row->building\n    siteRef: read(site and dis==siteDis)->id\n    links: if (row[\"links\"]==null) []\n           else [row[\"links\"]]\n    navName: try reGroups(r\"\\[.*\\] - .* - (.*)\", row->title)[1]\n             catch row->title\n    assignedTo: if (row[\"assignedTo\"]==\"Ricardo Brambila\") \"Ricky Brambila\"\n                else row[\"assignedTo\"]\n    size: if (row.has(\"size\")) parseNumber(row->size)\n          else null\n    priority: if ([\"Medium\",\"High\"].contains(row[\"priority\"])) row[\"priority\"]\n              else null\n    state: row->state\n    endDate: if (row[\"dateClosed\"]==null) null\n             else parseDate(row[\"dateClosed\"], \"M/D/YYYY\")\n    energyValue: if ([\"N\",\"No\",\"None\"].contains(row[\"es\"])) \"None\"\n                 else if ([\"L\",\"Lo\",\"Low\"].contains(row[\"es\"])) \"Low\"\n                 else if ([\"M\",\"Med\",\"Medium\"].contains(row[\"es\"])) \"Medium\"\n                 else if ([\"H\",\"Hi\",\"High\"].contains(row[\"es\"])) \"High\"\n                 else if (row[\"es\"]==\"Maint\") \"Maintenance\"\n                 else null\n    operationalValue: if ([\"N\",\"No\",\"None\"].contains(row[\"oip\"])) \"None\"\n                      else if ([\"L\",\"Lo\",\"Low\"].contains(row[\"oip\"])) \"Low\"\n                      else if ([\"M\",\"Med\",\"Medium\"].contains(row[\"oip\"])) \"Medium\"\n                      else if ([\"H\",\"Hi\",\"High\"].contains(row[\"oip\"])) \"High\"\n                      else null\n    disMacro: if (siteDis==\"TOT HILL\") \"\\\$siteRef \\\$navName\"\n              else \"B\\\$siteRef \\\$navName\"\n    \n    defDict: {\n      deficiency,\n      navName: navName,\n      description: \"\",\n      disMacro: disMacro,\n      siteRef: siteRef,\n      state: state,\n      endDate: endDate,\n      links: links,\n      createdBy: \"Imported\",\n      assignedTo: assignedTo,\n      sprintRef: sprintRef,\n      size: size,\n      energyValue: energyValue,\n      operationalValue: operationalValue,\n      priority: priority,\n    }\n    \n    commit(diff(null, defDict, {add}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateMonthlyReg"],,,,M,,,,,,"recNewMonthlyReg",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(monthlyRegressionDict) => do\n  // Normalize action input\n  regDict: actionNormInput(monthlyRegressionDict, \"dict\")\n  \n  meter: readById(regDict->meterRef)\n  \n  // Assemble disMacro\n  disMacro: if (meter.has(\"gas\")) \"Gas\" else if (meter.has(\"elec\")) \"Elec\" else \"?\"\n  disMacro= disMacro+ \", Base \\\$baseSpan\"\n  if (regDict.has(\"postSpan\")) disMacro= disMacro+ \", Post \\\$postSpan\"\n  disMacro= disMacro+ \" (\"\n  list: []\n  if (regDict.has(\"hddBase\")) list= list.add(\"HDD \\\$hddBase\")\n  if (regDict.has(\"cddBase\")) list= list.add(\"CDD \\\$cddBase\")\n  disMacro= disMacro+ list.concat(\", \") + \")\"\n  \n  regDict= regDict\n  .set(\"disMacro\", if (regDict.has(\"dis\")) \"\\\$dis\" else disMacro)\n\n  // Add siteRef\n  regDict= regDict\n  .set(\"siteRef\", meter->siteRef)\n\n  // Validate record\n  regDict= recValidateMonthlyReg(regDict)\n\n  recNew(regDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74SingleVav",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point, add these points to zone and to equips that already exist.\n \n The file includes a match to the 2018-11-28 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(file: `io/integration_b74/single_vav.csv`,\ntypes: [0,1,2,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(file)\n  \n  siteId: read(site and dis==\"74\")->id\n  failedList: []\n\n  // Cycle through existing terminal units\n  tus: readAll(supply and terminalUnit and equip\n               and siteRef==siteId)\n  \n  tus.each((tu, i) => do\n    jobProgress(round(i/tus.size()*100).as(\"%\"), tu.dis())\n    locationId: tu->locationRef\n    zoneId: tu->equipRef\n    connectorId: tu->connRef\n    \n    // Find exhaust TU if it exists\n    etu: read(exhaust and terminalUnit and equip and equipRef==zoneId,\n              false)\n    \n    // Prepare list of bacnet grids containing all bacnet info for given types\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"TL\"]\n    \n    try do\n      types.each type => do\n        learn: bacnetLearn(connectorId, type)\n        bacnetPtList= bacnetPtList.set(type, learn)\n      end\n    end catch (ex) do\n      failedList= failedList.add(tu.dis())\n      // Skip terminal unit\n      return null\n    end\n\n    // Cycle through given points of interest, find and integrate\n    alcPtList.each pt => do\n      // Find corresponding tag set info in tagging standard\n      tagRow: tagStd.find(tag => tag->index==pt->indexTagStandard)\n    \n      // Initialize found bacnet rows to null\n      bacnetCurRow: null\n      bacnetHisRow: null\n    \n      // If bacnetCur is available, retrieve corresponding info\n      if (pt[\"bacnetCurName\"] != null) do\n        curType: bacnetObjMap.index(pt[\"bacnetCurType\"])\n        \n        // Find available BACnet point info\n        bacnetCurGrid: bacnetPtList[curType]\n        if (bacnetCurGrid == null) bacnetCurGrid= [].toGrid()\n        bacnetCurRow= bacnetCurGrid.find(row => row[\"dis\"]==pt->bacnetCurName)\n        \n        // If point not found in BACnet, it is hidden or does not\n        // exist for this zone. Skip point only if bacnetHis also missing\n      end // If bacnetCur is available\n      \n      // If bacnetHis is available, retrieve corresponding info\n      if (pt[\"bacnetHisName\"] != null) do      \n        // Find available BACnet point info\n        bacnetHisGrid: bacnetPtList[20]\n        if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n        bacnetHisRow= bacnetHisGrid.find(row => row[\"dis\"]==pt->bacnetHisName)\n      end\n\n      // If we did not find BACnet info for either Cur or His, skip point\n      if ((bacnetCurRow == null) and (bacnetHisRow == null)) return null\n      \n      // Check equipment type to determine proper equipRef\n      equipId: if (pt->eq==\"supply\") tu->id else etu->id\n          \n      // If point already exists, skip\n      ptFilter: \"point and equipRef==@\" + equipId + \" and \"\n                + tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n      if (read(parseFilter(ptFilter),false) != null) return null\n          \n      // Prepare polling variables as needed (null if bacnetHis)\n      hisCollectCov: if (pt[\"hisCollectCov\"]==null) null else marker()\n      hisCollectInterval: if (pt[\"hisCollectCov\"]==null) null else 12h\n      \n      // Prepare new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: if (bacnetCurRow != null) bacnetCurRow[\"bacnetCur\"],\n               bacnetHis: if (bacnetHisRow != null) bacnetHisRow[\"bacnetHis\"],\n               bacnetCurName: pt[\"bacnetCurName\"],\n               bacnetHisName: pt[\"bacnetHisName\"],\n               kind: if (bacnetCurRow != null) bacnetCurRow[\"kind\"] else pt[\"kind\"],\n               unit: if (bacnetCurRow != null) bacnetCurRow[\"unit\"] else pt[\"unit\"],\n               enum: if (bacnetCurRow != null) bacnetCurRow[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               hisCollectCov: hisCollectCov,\n               hisCollectInterval: hisCollectInterval,\n               notes: if (bacnetCurRow != null) bacnetCurRow[\"bacnetDesc\"], //optional\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp: today()}\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n    end  // alcPtList.each pt\n  end)  // each tu\n  \n  return failedList\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"boilerStatusCodetoFiredStatus",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// This function translates boiler status codes to a binary fired status\n// using thresholds provided in equipment tags\n(rec, dates, opts, yield) => do\n  thresholdLo:rec->equipRef->codeFiredThresholdLo\n  thresholdHi:rec->equipRef->codeFiredThresholdHi\n\n  read(boiler and run and sensor and equipRef==rec->equipRef)\n    .hisRead(dates, opts)\n    .each(row => yield(row->ts, (row->v0)>=thresholdLo and (row->v0)<=thresholdHi))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpIntgB59Zones",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  // Start from CSV file with controller addresses and corresponding\n  // UFT & BL names & numbers\n  ioReadCsv(`io/integration_b59/uft_devices.csv`)\n  \n  // For each row, create one connector and one zone\n  .each r => do\n    // Parse floor name and attribute number\n    siteId: read(site and dis==\"59\")->id\n    floorName: reGroups(\"LVL(.).\", r[\"gAreaName\"])[1]\n    floorNum: if (floorName==\"G\") 3 else 4\n    floorId: read(location and siteRef==siteId and dis==\"B59 Floor \"+floorNum)->id\n  \n    // Check if connector already exists\n    exConn: read(conn and uri==parseUri(r[\"connectorAddr\"]), false)\n  \n    // Build connector dictionary\n    connDict: {\n      bacnetConn,\n      conn,\n      dis: \"59 Floor \"+floorNum+\" - \"+r[\"blName\"],\n      siteRef: siteId,\n      uri: parseUri(r[\"connectorAddr\"]),\n      vavZn: r[\"blName\"],\n    }\n    \n    // Commit to DB, update if connector exists, else create new\n    if (exConn==null)\n      commit(diff(null, connDict, {add}))\n    else\n      commit(diff(exConn, connDict))\n      \n    // Build zone dictionary\n    zoneDict: {\n      disMacro: \"\\\$locationRef \\\$navName\",\n      equip,\n      locationRef: floorId,\n      navName: r->blName,\n      siteRef: siteId,\n      zone,\n      uftName: r->uftName\n    }\n    \n    // Find if a zone already exists with same navName\n    exZone: read(zone and equip and locationRef==floorId\n                 and navName==r->blName, false)\n                 \n    // Commit to DB, update if zone exists, else create new\n    if (exZone==null)\n      commit(diff(null, zoneDict, {add}))\n    else\n      commit(diff(exZone, zoneDict))\n    \n    // Find zone\n    zoneId: read(zone and equip and locationRef==floorId\n                 and navName==r->blName)->id\n    \n    // Build supply terminal unit dictionary\n    tuDict: {\n      disMacro: \"\\\$equipRef \\\$navName\",\n      equip,\n      equipRef: zoneId,\n      locationRef: floorId,\n      navName: r->uftName,\n      siteRef: siteId,\n      supply,\n      terminalUnit\n    }\n    \n    // Find if a TU already exists in the same zone with the same name\n    exTU: read(supply and terminalUnit and equipRef==zoneId and navName==r->uftName, false)\n    \n    // Commit to DB, update if zone exists, else create new\n    if (exTU==null)\n      commit(diff(null, tuDict, {add}))\n    else\n      commit(diff(exTU, tuDict))\n  end\n  \n  // Associate cached connector points with the terminal unit that's under\n  // the zone identified on connector's vavZn tag\n  readAll(siteRef->dis==\"59\" and supply and terminalUnit)\n  .each tu => do\n    // Find conn associated with TU's zone\n    zoneId: tu->equipRef\n    zoneRec: readById(zoneId)\n    siteId: zoneRec->siteRef\n    blName: zoneRec->navName\n    connRec: read(conn and siteRef==siteId and vavZn==blName)\n    connId: connRec->id\n    \n    // Apply equipRef to all cached points associated with that connector\n    readAll(connPointCache and connRef==connId)\n    .each pt => commit(diff(pt, {equipRef: tu->id}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualWeightedAverage",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  weighted average value of all points which have a virtualRef\n  equal to the id of the virtual point. Weights are stored\n  under the virtualWeight tag of each point to be averaged.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap((val, ts, his) => if (val==null) na() else\n                                   val * his->virtualWeight)\n         .hisFoldCols(sum)\n         .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viNoHistory",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Points in the database should have trends associated with them. If not,\n  setup of the point may be incomplete or integration may have failed or\n  point has failed on BMS side.\n  Return grid with:\n    idNoHistory:   point id\n    connRef:       ref, connector, if any \n    virtual:       marker, if any\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  noHis: readAll(point and not hisFunc and not hisEnd)\n         .findAll(row => not row.has(\"connRef\")\n                  or not readById(row->connRef).has(\"disabled\"))\n         .map(row =>\n           {idNoHistory: row->id,\n            connRef: row[\"connRef\"],\n            virtual: row[\"virtual\"]\n           }\n         )\n   \n  if (isEmpty(noHis))\n    noHis = {success: \"All points have history data\"}\n            .toGrid\n  \n  return noHis\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d9bce9-061451a1 "dbHisHealth",
,[],,,,M,,,,,,"toolSplitTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Given a grid of historical trends, separate points that belong to\n  a given date span into additional trend(s) and assign the new trends\n  a given color\n  \n  Arguments: \n  hisGrid         Grid of historical trends\n  dates           Datespan\n  color           (optional) html color name or hex code\n*/\n\n(hisGrid: read(power and not virtual and equipRef->elec)\n          .hisRead(lastMonth),\n dates: null, color: \"red\") => do\n  // Convert dates to DateSpan\n  try dates= dates.toDateSpan()\n  catch return {error: \"dates argument invalid\"}.toGrid()\n \n  // Create original copy of grid\n  oGrid: hisGrid\n \n  // From working grid, remove all points during given dates\n  hisGrid= hisGrid.findAll(row => not(dates.contains(date(row->ts))))\n  hisGrid.colNames.findAll(v => v != \"ts\").each colName =>\n    hisGrid= hisGrid.addColMeta(colName, {chartType: \"scatter\"})\n  \n  // Create grid of values during dates, apply new color\n  selGrid: oGrid.findAll(row => dates.contains(date(row->ts)))\n  selGrid.colNames.findAll(v => v != \"ts\").each colName =>\n    selGrid= selGrid.addColMeta(colName,\n        {chartType: \"scatter\",\n         color: color,\n         dis: selGrid.col(colName).meta.dis()+\" \"+dates})\n                                          \n  // Combine grids and return result\n  return hisJoin([hisGrid, selGrid])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpB59CT2Power",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  hisGrid: ioReadCsv(`io/tmp/b59_ct2_power.csv`)\n  .addCol(\"ts\",r=>r->timestamp.parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\"))\n  .keepCols([\"ts\",\"v0\"])\n  .reorderCols([\"ts\",\"v0\"])\n  \n  dates: (hisGrid.first->ts..now()).toDateSpan\n  \n  dates.eachDay day => do\n    subGrid: hisGrid.findAll(r=>r->ts.date()==day)\n                    .hisMap(v=>parseNumber(v))\n    subGrid.hisWrite(readLink(@p:lbnl:r:232309f8-0c2e1ebd), {limit:null})\n    hisSync()\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"bacnetObjConvert",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Convert a given, valid BACnet object name to the abbreviated name\n  that we typically use. By default, return given object name if\n  conversion could not be performed.\n*/\n\n(bacnetObjName: \"1:123\") => do\n  file: ioReadCsv(`io/config/bacnet_obj_types.csv`)\n  \n  // Case 1, e.g. 1:123\n  if (reMatches(r\"(\\d{1,2}):(\\d*)\",bacnetObjName)) do\n    index: reGroups(r\"(\\d{1,2}):(\\d*)\",bacnetObjName)[1]\n    objNumber: reGroups(r\"(\\d{1,2}):(\\d*)\",bacnetObjName)[2]\n    match: file.find(row => row[\"int\"]==index)\n    if (match==null) return bacnetObjName\n    return match[\"abbr\"]+objNumber\n  end\n  \n  // Case 2, e.g. ANALOG_INPUT:123\n  if (reMatches(r\"([a-zA-Z_]*):(\\d*)\",bacnetObjName)) do\n    name: reGroups(r\"([a-zA-Z_]*):(\\d*)\",bacnetObjName)[1]\n    objNumber: reGroups(r\"([a-zA-Z_]*):(\\d*)\",bacnetObjName)[2]\n    match: file.find(row => row[\"name\"]==name)\n    if (match==null) return bacnetObjName\n    return match[\"abbr\"]+objNumber\n  end\n  \n  return bacnetObjName\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgMaintainTags",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Perform maintenance operations on the following point tags based on\n  available, most recent cached information:\n  hisMode\n  bacnetLogInterval\n  bacnetLogBufferSize\n  bacnetLogCovIncrement\n*/\n\n(connRef:null) => do\n  // Find all points with a BACnet connector, or all points associated with\n  // a given BACnet connector if provided\n  grid: if (connRef==null) readAll(point and bacnetConnRef)\n        else readAll(point and bacnetConnRef==connRef)\n  \n  grid\n  .each pt => do\n    // Find matching cached record\n    cached: read(connPointCache and pointRef==pt->id, false)\n    if (cached==null) return null\n    else do\n      changesDict: {\n        hisMode: if ((cached.has(\"bacnetHis\") and cached[\"bacnetLogInterval\"]==0) or\n                     pt.has(\"hisCollectCov\"))\n                   \"cov\"\n                 else null,\n        bacnetLogInterval: cached[\"bacnetLogInterval\"],\n        bacnetLogBufferSize: cached[\"bacnetLogBufferSize\"],\n        bacnetLogCovIncrement: cached[\"bacnetLogCovIncrement\"],  \n      }\n      commit(diff(pt, changesDict))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"facCreateZoneReqIgnorePoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create optional points to keep track of ignored requests (heat, cool, pressure) for\n  a zone. These are not required for the zone rogue detection and AHU ignores algorithm\n  to work properly. Individual zone ignores are only used for documentation purposes.\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  equipRef     Id of the equip to create 3 request ignore points for\n*/\n(equipRef, createCool:true, createPres:true, createHeat:true) => do\n  // Standardize to ref / id from rec (for easy map / each usage)\n  equipRef= if (isRef(equipRef)) equipRef\n            else equipRef->id\n  equip: readById(equipRef)\n            \n  // Create air cool ignore cmd point dict\n  coolPtDict: {disMacro: \"\\\$equipRef \\\$navName\",\n               equipRef: equipRef,\n               his,\n               kind:\"Number\",\n               locationRef: equip->locationRef,\n               point,\n               siteRef: equip->siteRef,\n               tz: \"Los_Angeles\",\n               unit: \"_request\",\n               air,\n               cool,\n               ignore,\n               cmd,\n               navName:\"Ignored Requests - Colder Supply Air\"\n              }\n\n  // Create air pressure ignore cmd point dict\n  presPtDict: {disMacro: \"\\\$equipRef \\\$navName\",\n               equipRef: equipRef,\n               his,\n               kind:\"Number\",\n               locationRef: equip->locationRef,\n               point,\n               siteRef: equip->siteRef,\n               tz: \"Los_Angeles\",\n               unit: \"_request\",\n               air,\n               pressure,\n               ignore,\n               cmd,\n               navName:\"Ignored Requests - Increased Air Pressure\"\n              }\n          \n  // Create general heat ignore cmd point dict\n  heatPtDict: {disMacro: \"\\\$equipRef \\\$navName\",\n               equipRef: equipRef,\n               his,\n               kind:\"Number\",\n               locationRef: equip->locationRef,\n               point,\n               siteRef: equip->siteRef,\n               tz: \"Los_Angeles\",\n               unit: \"_request\",\n               general,\n               heat,\n               ignore,\n               cmd,\n               navName:\"Ignored Requests - More Heat (Generic)\"\n              }\n          \n  // Check if air cool ignore cmd exists, create if not\n  coolPt: read(air and cool and ignore and cmd and equipRef==equipRef, false)\n  if (coolPt==null and createCool)\n    commit(diff(null, coolPtDict, {add}))\n    \n  // Check if air pressure ignore cmd exists, create if not\n  presPt: read(air and pressure and ignore and cmd and equipRef==equipRef, false)\n  if (presPt==null and createPres)\n    commit(diff(null, presPtDict, {add}))\n    \n  // Check if general heat ignore cmd exists, create if not\n  heatPt: read(general and heat and ignore and cmd and equipRef==equipRef, false)\n  if (heatPt==null and createHeat)\n    commit(diff(null, heatPtDict, {add}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viTaggingStats",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This analyzes all the tags used in the database and can return the top 10\n  or bottom 10 tags based on number of records they are used in, excluding\n  tags in `io/tagsToIgnore.csv`\n  Return grid with columns:\n    tag        text, tag name\n  \n  Arguments:\n  filter        text, filter to determine set of records to analyze,\n                default is \"point\"\n  function      text,\n                \"most\"     - return 10 most used tags\n                \"least\"    - return 10 least used tags\n*/\n\n(filter: \"point\", function: \"least\") => do\n  // Test if provided filter is valid, and create associated query\n  try\n    query : parseFilter(filter, true)\n  catch do\n    query : parseFilter(\"point\", true)\n    filter = \"point\"\n  end\n  \n  // Get list of tags from sb and list of tags to ignore\n  tags: readAll(query).colNames\n  ignore: ioReadCsv(`io/tagsToIgnore.csv`).colToList(\"tags\")\n  \n  // Cycle through tags and count occurences\n  stats: tags\n         .map(tag => do\n                if (ignore.contains(tag)) return {tag: tag, count: null}\n                else do\n                  grid: readAll(parseFilter(filter +\" and \"+ tag))\n                  return {tag: tag, count: grid.foldCol(\"id\", count)}\n                end\n              end\n             )\n  \n  // Remove null counts and sort by number of occurences\n  stats = stats.findAll(row => row[\"count\"] > 0).toGrid.sort(\"count\")\n  \n  // Return most or least used depending on function\n  if (function == \"least\") return stats[0..9]\n  if (function == \"most\") return stats[-10..-1]\n  return stats\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"viTWPumpOperations",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find tower water supply temperature\n  and tower fan speed for a given time range\n  \n  find cooling water supply setpoint and temperature\n  and tower pump speed for the same time range\n  \n  Return history grid ready for display on a graph (maybe two graphs?)\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(twSysRef:null, dates: today, rollup:5min, spdThreshold:1%) => do\n  // Default to B59 TW Plant if no ref is provided\n  if(twSysRef==null)\n    twSysRef= read(equip and siteRef->dis==\"59\" and condenserWaterPlant and navName==\"Plant\")\n    \n  twSysId: twSysRef->id\n    \n  // Get the supply setpoint and temp for tower water\n  twSupplyTempPts: read(equipRef==twSysId\n                    and temp\n                    and sensor\n                    and water)\n                    \n  cwSysRef: read(equip and siteRef->dis==\"59\" and treatedWaterPlant and navName==\"Plant\")->id\n\n  // Get the supply setpoint and temp for cooling water\n  cwSupplyTempPts: read(equipRef==cwSysRef\n                    and temp\n                    and sensor\n                    and water\n                    and leaving)\n  cwSP: read(equipRef==cwSysRef\n                    and temp\n                    and sp\n                    and water\n                    and leaving)\n  \n                    \n  // Read out the histories for the three temperatures\n  twSupplyTrend: hisRead(twSupplyTempPts, dates, {limit:null})\n                    .renameCol(\"v0\",\"twSupply\")\n                    .hisRollup(avg, rollup)\n\n  cwSupplyTrend: hisRead(cwSupplyTempPts, dates, {limit:null})\n                    .renameCol(\"v0\",\"cwSupply\")\n                    .hisRollup(avg, rollup)\n  \n  cwSPTrend: hisRead(cwSP, dates, {limit:null})\n                    .renameCol(\"v0\",\"cwSP\")\n                    .hisRollup(avg, rollup)\n\n  // Get all the Tower Pump Speeds\n  pumpSpeeds: readAll(locationRef==twSysRef->locationRef\n                     and equipRef->pump\n                     and speed\n                     and cmd)\n  \n  // Average the histories for all the pump speeds where the pump speed is greater than given threshold\n  avgPumpSpeeds: hisRead(pumpSpeeds, dates, {limit:null})\n                   .hisRollup(avg, rollup)\n                   .hisMap((val, ts, his) => do\n                     return if (val>spdThreshold) val else null\n                   end)\n     \n  avgPumpSpeeds= avgPumpSpeeds.hisFoldCols(avg)\n                \n        \n  //Join the histories into a common map\n        combined: hisJoin([twSupplyTrend, cwSupplyTrend, cwSPTrend, avgPumpSpeeds])\n                    .addColMeta(\"twSupply\",\n                      {dis: \"TW Supply Temp\",\n                      unit: \"°F\", color: \"#008080\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"cwSupply\",\n                      {dis: \"CW Supply Temp\",\n                      unit: \"°F\", color: \"#4169E1\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"cwSP\",\n                      {dis: \"CW Supply Temp Setpoint\",\n                      unit: \"°F\", color: \"#B0C4DE\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"v0\",\n                      {dis: \"Average TW Pump Speed\",\n                      unit: \"%\", color: \"#4B0082\",\n                      chartMin: 60%,\n                      chartMax: 100%,\n                      chartGroup: \"all\"})\n  return combined\nend\n                    \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptPowerIntegrator"],,,,M,,,,,,"tmpFunc20190405",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  hisJoin(\n  [ptPowerIntegrator(@p:lbnl:r:23d4fc7f-6db76065, 2019-04-02, 1min)\n     .hisRollup(sum, 1min).hisInterpolate(),\n   readById(@p:lbnl:r:23d4fc7f-6db76065)\n     .hisRead(2019-04-02, {limit:null})])\n  .addCol(\"gapDetected\", row => if(row[\"v0\"]==na()) true else false)\n  .addColMeta(\"gapDetected\", {dis:\"Data Gaps > 1 minute\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],[`io/config/ignoreTags.csv`],,,M,,,,,,"toolRecTags",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given record, filter out tags that match the ignoreTags list\n  and return the remaining tags\n  \n  Arguments: \n  point            Record or Ref of the point\n*/\n\n(point) => do\n  // If a Ref was provided, load corresponding record\n  if (isRef(point))\n    try point= readById(point)\n    catch return {\"point not valid\"}.toGrid()\n    \n  // Load dependencies\n  try ignoreTags: ioReadCsv(`io/config/ignoreTags.csv`)\n                  .colToList(\"ignoreTagsRegex\")\n  catch\n    return {error: \"io/config/ignoreTags.csv could not be loaded\"}.toGrid()\n\n  if (not(isDict(point)))\n    return {\"point not valid\"}.toGrid()\n    \n  allTags: point.findAll(v => v != null).names()\n  filteredTags: allTags.findAll(tag => do\n        regexMatch: false\n        ignoreTags.each regex => if (regex.reMatches(tag)) regexMatch= true\n        return not(regexMatch)\n      end)\n  \n  return filteredTags\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anAhuZonePressureNeeds",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze zupply terminal unit trends for all terminal units related\n  to given AHU and return one historical trend of zones that need more\n  air pressure, as calculated by comparing supply terminal unit\n  damper command to a given threshold (inclusive).\n  \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  threshold    number, inclusive threshold\n  rollup       duration, interval for rollup of damper command\n  total        bool, if true return the total, if false return\n               the individual terminal unit trends\n*/\n\n(ahuRef, dates: yesterday(), threshold:99%, rollup: 15min,\n total: true) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve a grid of all supply terminal units associated with AHU\n  tus: readAll(supply and terminalUnit and ahuRef==ahuRef)\n  \n  // Return null if no associated terminal units are found\n  if (isEmpty(tus)) return null\n  \n  // Cycle through zones and create history of cooling needs\n  needs: {}.toGrid()\n  tus.each(tu => do\n    // Find ZAT and ZAT cooling setpoint\n    damper: read(point and damper and cmd\n                 and equipRef==tu->id, false)           \n            \n    // If any point is missing, skip terminal unit\n    if (damper==null) return null\n    \n    // Col name based on zone name\n    if (tu.has(\"equipRef\"))\n      colName: tu->equipRef->navName.toTagName()\n    else\n      colName: tu->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    flags: [damper].hisRead(dates, {limit: null})\n        .hisRollup(avg, rollup)\n        .hisInterpolate()\n        .addCol(colName, row => do\n          if (row[\"v0\"]==null or row[\"v0\"]==na())\n            return null\n          else if (row[\"v0\"] >= threshold)\n            return 1\n          else return 0\n        end)\n        .keepCols([\"ts\",colName])\n        .hisFindAll(val => val != null)\n        .addColMeta(colName, {dis: tu.dis()+\" Need Air\"})\n        \n    // Add to needCooling summary array\n    if (isEmpty(flags)) return null\n    if (isEmpty(needs)) needs=flags\n    else needs= hisJoin([flags,needs])\n  end)\n  \n  if (isEmpty(needs)) return null\n  if (not(total)) return needs\n  \n  // Sum up all terminal units into one trend\n  tot: needs.cols.size()-1\n  disName: \"Count, terminal units need more air (supply damper >= \"\n           + threshold.as(\"%\") + \" open), out of max \" + tot\n  count: needs\n      .hisFoldCols(sum)\n      .findAll(row => row[\"v0\"] != na() and row[\"v0\"] != null)\n      .addColMeta(\"v0\", {dis: disName, color:\"#000000\",\n                         chartMin: 0})\n      \n  return count\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolImportView",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load `io/tmp/view.zinc` grid. Commit new view or function records that\n  do not have a duplicate on the project (based on name).\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  // Load records\n  ts: try ioReadZinc(`io/tmp/view.zinc`)\n      catch return {error:\"File `io/tmp/view.zinc` not found\"}\n                   .toGrid\n\n  // Commit new records if no duplicate found\n  ts. each t => do\n    exRec: if (t.has(\"func\")) read(func and name==t->name, false)\n           else read(view==t->view, false)\n    if (exRec==null)\n      commit(diff(null, t, {add}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolPrepExport",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(recs) => do\n  recs\n  .addCol(\"origId\", row => row->id)\n  .removeCols([\"id\",\"mod\",\"hisEnd\",\"hisErr\",\"hisSize\",\"hisStart\",\"hisStatus\",\"connState\",\"connStatus\",\"curStatus\",\"hisStatus\",\"curErr\",\"hisErr\"])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anAhuDuctGain",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Review data from all terminal units served by a given AHU and returns\n  the estimated duct heat gain as one value for the entire period.\n  The heat gain is first calcualted over time, based on the 10th percentile\n  of observed zone DATs for zones not actively reheating (percentile allows\n  for a few DAT sensors reading too low). The global heat gain for the\n  period is then calculated as the 80th percentile heat gain in that period.\n \n  Arguments: \n  ahuId      id of ahu to analyze\n  span       dates to analyze\n  rhDelay    allowed time delay for residual heat to leave heat coil\n  pctSensor  percentile used, for each time stamp, to select a DAT\n             default 10\n  pctTime    percentile used to select the resulting period-wide heat gain\n             default 80\n*/\n\n(ahuId: read(ahu and equip and siteRef->dis==\"67\" and navName==\"AHU-01\")->id,\n span:yesterday(), rhDelay: 90min, pctSensor: 10, pctTime: 80) => do\n  // Load SAT history, return null if SAT is missing\n  sat: read(discharge and air and temp and sensor\n            and equipRef==ahuId,false)\n  if (sat == null) return null\n  sat= sat.hisRead(span, {limit: null})\n       \n  if (sat.foldCol(\"v0\",count) < 2) return 0°F\n \n  // Find all terminal units served by AHU\n  tus: readAll(terminalUnit and equip and ahuRef==ahuId)\n  \n  // Cycle through terminal units, and for each return valid DAT data\n  // for periods when the RH valve has been closed long enough\n  eats: tus.map(tu => do\n    dat: read(discharge and air and temp and sensor and equipRef==tu->id,\n              false)\n    rh: read(heat and valve and cmd and equipRef==tu->id,\n             false)\n    \n    // If DAT is missing, skip\n    if (dat==null) return null\n    // If terminal unit has reheat coil but valve cmd is missing, skip\n    if (rh==null and tu.has(\"hotWaterHeat\")) return null\n    \n    // If terminal unit has no reheat, then entire period is valid\n    if (rh==null) norh: dat.hisRead(span, {limit: null})\n                           .hisFindPeriods(v => true)\n    // Otherwise, period is valid only when reheat valve has been closed\n    // for at least rhDelay\n    else do\n      extSpan: span.toDateSpan().start-1day..span.toDateSpan().end+1day\n      norh: rh.hisRead(extSpan, {limit: null})\n              .hisFindPeriods(v => v == 0%)\n              .hisPeriodShift(rhDelay, 0min)\n    end\n    \n    datHis: dat.hisRead(span, {limit: null})\n    if (datHis.foldCol(\"v0\",count) < 2) return null\n    \n    eat: hisJoin([datHis, sat])\n            .hisInterpolate()\n            .keepCols([\"ts\",\"v0\"])\n            .hisFindInPeriods(norh)\n            .addMeta({forceConst})\n\n    return {eat: eat}\n  end)\n  \n  // Combine all valid zone DATs into one grid\n  eats= hisJoin(eats.colToList(\"eat\"))\n  \n  // Select for each timestamp a DAT based on percentile\n  min: eats.addCol(\"selected\", row => do\n               vals: row.findAll((v,n) => n != \"ts\" and v != null).vals\n               sz: vals.size\n               if(sz > 1) vals.sort()[round(sz * pctSensor / 100)]\n               else null\n           end)\n           .keepCols([\"ts\",\"selected\"])\n           .addColMeta(\"selected\", {dis: \"DAT, no reheat\",\n                              chartType: \"scatter\",\n                              chartGroup: \"temps\",\n                              chartMin: 50°F,\n                              chartMax: 100°F,\n                              strokeWidth: 1})\n \n  sat= sat.addColMeta(\"v0\", {chartGroup: \"temps\",\n                             chartMin: 50°F,\n                             chartMax: 100°F,\n                             strokeWidth: 5})\n  \n  // Calculate difference between SAT and the selected DAT\n  temps: hisJoin([sat, min]).addCol(\"diff\", row => row[\"selected\"] - row[\"v0\"])\n  \n  // Based on percentile, return one heat gain value\n  gains: temps.colToList(\"diff\").findAll(v => v != null)\n  samples: gains.size\n  \n  if (samples > 1)\n    return max(0, gains.sort()[floor(samples * pctTime / 100)])\n  else\n    return null\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recSprintSnap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a sprint velocity snapshot for latest sprint using current\n  deficiency statuses\n  \n  Arguments:\n  N/A\n*/\n\n() => do\n  // Find latest sprint (highest number)\n  latestSpr: readAll(sprint)\n             .sortr((a,b) => a->sprint <=> b->sprint)\n             .first\n  \n  deficiencies: readAll(deficiency and sprintRef==latestSpr->id)\n  \n  sprintSnapDict: {\n       sprintVelocitySnap,\n       date: today(),\n       disMacro: \"Sprint \\\$sprintRef (\\\$date)\",\n       sprintRef: latestSpr->id,\n       wuToDo: deficiencies.findAll(d => d[\"state\"]==\"To Do\").foldCol(\"size\", sum),\n       wuInProgress: deficiencies.findAll(d => d[\"state\"]==\"In Progress\").foldCol(\"size\", sum),\n       wuPending: deficiencies.findAll(d => d[\"state\"]==\"Pending\").foldCol(\"size\", sum),\n       wuResolved: deficiencies.findAll(d => d[\"state\"]==\"Resolved\").foldCol(\"size\", sum),\n       wuClosed: deficiencies.findAll(d => d[\"state\"]==\"Closed\").foldCol(\"size\", sum),\n       wuAbandoned: deficiencies.findAll(d => d[\"state\"]==\"Abandoned\").foldCol(\"size\", sum),\n      }\n      \n  commit(diff(null, sprintSnapDict, {add}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viZoneOccByFloor",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of occupancy sensor data from zones,\n grouped by locationRef; grid is optimized for use as a chart.\n \n Arguments:\n siteRef   reference of site to retrieve data from\n span      dateSpan, span of dates for which to return data\n*/\n\n(siteRef, span) => do\n  data: readAll(zone and occupied and sensor and siteRef==siteRef)\n          .sort((a,b) => a.dis <=> b.dis)\n          .hisRead(span, {limit:null})\n  \n  data.colNames()[1..-1].each colName => do\n    data = data.addColMeta(colName, {chartGroup: data.col(colName).meta->locationRef->dis})\n  end\n  \n  return(data)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolRecursiveSearch"],,,,M,,,,,,"anZoneEnabled",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given zone, review available trends for the given period and return a period trend\n  that shows when the zone controls are considered enabled.\n  \n  Zone controls are considered disabled if:\n  Occupied Mode exists and is False\n  OR Supply Airflow Setpoint exists and is less than airflowSetpointMin, default 10 cfm\n  OR Supply Airflow exists and is less than airflowSetpointMin, default 10 cfm\n  OR Window Switch exists and is True\n  \n  Conversely, zone controls are considred enabled if:\n  Occupied Mode is True or does not exist\n  AND Supply Airflow Septoint is equal to or above the airflowSetpointMin or does not exist\n  AND Supply Airflow is equal to or above the airflowSetpointMin or does not exist\n  AND Window Switch is False or does not exist\n  \n  \n  Arguments: \n  zoneRef            Reference of zone equip\n  dates              Span, dates to run analysis on\n  airflowSetpointMin Number in CFM below which the setpoint is considered to be zero,\n                     default 10 cfm\n  rollup             Time interval to use for rollup, default 15min\n*/\n\n(zoneRef: @p:lbnl:r:22756fdf-411ba8fd, dates: pastWeek(),\n airflowSetpointMin: 10cfm, rollup:15min) => do\n  // Check / convert inputs\n  airflowSetpointMin= airflowSetpointMin.as(\"cfm\")\n \n  // Retrieve zone record\n  zone: readById(zoneRef)\n  \n  // Check that provided reference is for a zone equip\n  if (not(zone.has(\"zone\")))\n    return null\n  \n  // Retrieve needed values and points\n  saSps: toolRecursiveSearch(zoneRef,\n    \"point and equipRef->supply and air and flow and effective and sp\")\n  saSensor: toolRecursiveSearch(zoneRef,\n    \"point and equipRef->supply and air and flow and sensor\")\n  occModes: toolRecursiveSearch(zoneRef, \"point and occupied and zone and cmd\")\n  windowSwitches: toolRecursiveSearch(zoneRef, \"point and windowSwitch and sensor\")\n  \n  // Supplay airflow setpoint test\n  sspT: if (isEmpty(saSps))\n             hisSlidingWindows(dates, 1hr, 1hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF SP not found\"})\n        else saSps\n             .hisRead(dates, {limit:null})\n             .toolHisAlign(avg, min)\n             .hisFoldCols(sum)\n             .hisFindPeriods(v => v!= na() and v != null and v >= airflowSetpointMin)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF SP >= \"+airflowSetpointMin})\n\n  // Measured supplay airflow  test\n  safT: if (isEmpty(saSensor))\n             hisSlidingWindows(dates, 1hr, 1hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF sensor not found\"})\n        else saSensor\n             .hisRead(dates, {limit:null})\n             .toolHisAlign(avg, min)\n             .hisFoldCols(sum)\n             .hisFindPeriods(v => v!= na() and v != null and v >= airflowSetpointMin)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" SAF sensor >= \"+airflowSetpointMin})\n\n  // Occupied mode test\n  occT: if (isEmpty(occModes))\n             hisSlidingWindows(dates, 1hr, 1hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" Occ mode not found\"})\n        else do \n          occPeriods: []\n          occModes.each(occMode => occPeriods= occPeriods\n                                   .add(occMode\n                                        .hisRead(dates, {limit:null})\n                                        .hisFindPeriods(v => v)))\n          occPeriods.hisPeriodUnion()\n                    .addColMeta(\"v0\", {dis:zone.dis()+\" Occupied mode\"})\n        end\n             \n  // Window closed switch test\n  wdcT: if (isEmpty(windowSwitches))\n             hisSlidingWindows(dates, 1hr, 1hr)\n             .addColMeta(\"v0\", {dis:zone.dis()+\" Window switch not found\"})\n        else do \n          wdcPeriods: []\n          windowSwitches.each(wdcS => wdcPeriods= wdcPeriods\n                                      .add(wdcS\n                                           .hisRead(dates, {limit:null})\n                                           .hisFindPeriods(v => not(v))))\n          wdcPeriods.hisPeriodUnion()\n                    .addColMeta(\"v0\", {dis:zone.dis()+\" Window closed\"})\n        end\n  \n  // Combine all tests\n  return hisPeriodIntersection([sspT, safT, occT, wdcT])\n         .addColMeta(\"v0\", {dis:zone.dis()+\" Zone controls enabled\"})\n         .addMeta({view:\"chart\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"syncModhopper",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function takes a point reference, \n  extracts the modhopper device and point address,\n  and requests data from the acquisuite data collector.\n  It should then save that data (after checking validity) into \n  the history for the point in question.\n  \n  Arguments: \n  point             point with a modhopperDevAddr and modhopperPointAddr\n  start_date        dateTime for beginning of sliding window\n  end_date          dateTime for ending of sliding window\n  \n  // LBNL // JS // Last Update: 2020-03-02 //\n*/\n\n(point, start_datetime, end_datetime) => do\n\n  addr: point->modhopperDevAddr\n  pt: point->modhopperPointAddr\n  id: point->id\n\n  datetime_string: toStr(start_datetime)\n  date_string: split(datetime_string, \"T\")[0]\n  time_string: split(split(datetime_string, \"T\")[1], \"-\")[0]\n  \n  if (end_datetime!=\"now\") do\n    end_datetime_string: toStr(end_datetime)\n    end_date_string: split(end_datetime_string, \"T\")[0]\n    end_time_string: split(split(end_datetime_string, \"T\")[1], \"-\")[0]\n    end_string: \"&end=\" + end_date_string + \"_\" + end_time_string\n  end else\n    end_string: \"&end=\" + end_datetime\n  \n  link: \"http://fmcs-svc-mgr.lbl.gov/get_data?address=\" + toStr(addr) + \"&point=\" + toStr(pt) + \n        \"&start=\" + date_string + \"_\" + time_string + end_string\n  his: ioReadCsv(`` +  link) \n\n//  list: his.each reading => do\n//    {ts: parseDateTime(reading->time, pattern: \"YYYY-MM-DD hh:mm:ss\"), val:  reading->value}\n//  end\n\n  list: []\n  his.each reading => do\n    if (reMatches(r\"[a-zA-Z]{3}\", reading->time)) do\n      time: toTimeZone(parseDateTime(reading->time, pattern: \"YYYY-MM-DD hh:mm:ss zzz\"), \"Los_Angeles\")\n    else do\n      time: toTimeZone(parseDateTime(reading->time + \" UTC\", pattern: \"YYYY-MM-DD hh:mm:ss zzz\"), \"Los_Angeles\")\n      end\n    value: reading->value.parseFloat()\n    list = add(list, {ts: time, val: value})\n      end\n  //return list\n  \n  // Sort and trim list\n  lastStored: if (point.has(\"hisEnd\")) point->hisEnd else null\n  list\n  .toGrid\n  .sort((a,b) => a->ts <=> b->ts)\n  .findAll(row => row.all(v => v!=null)\n                  and (lastStored==null or row->ts > lastStored)\n                  and row->ts < now())\n  // write his\n  .hisWrite(point)\nend\n\n/*\n  Updates\n  2020-03-02   Added lastStored variable and proper management for points that don't yet have\n               a history in SkySpark.\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06AHU",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point stored in `io/integration_b6/b6_ahu18.csv`\n to add these points to existing equips.\n \n This file includes a match to the 2018-10-03 tagging standard for the\n purpose of associating the proper tags and navName to each point.\n Also includes equip id.\n*/\n\n(filePath: `io/integration_b6/b6_ahu18.csv`, connectorId: @p:lbnl:r:23491915-56ef89df,\n finalize: true) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(filePath)\n  \n  siteId: @p:lbnl:r:211cc8a4-6dc3ebdd\n  \n  bacnetPtList: [null, null, null, null, null, null]\n  bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\"]\n  \n  [0,1,2,3,4,5].each type => do\n    bacnetLearn(connectorId)\n    learn: bacnetLearn(connectorId, type)\n    bacnetPtList= bacnetPtList.set(type, learn)\n  end\n  \n  alcPtList= alcPtList.addCol(\"newPt\", row => do\n    equip: readById(parseRef(row->eq))\n    equipId: equip->id\n    locationId: equip->locationRef->id\n    \n    // Get info from bacnetPtList by matching bacnetCur\n    curType: row->bacnetCur[0..1]\n    bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n    if (bacnetGrid == null) bacnetGrid= [].toGrid()\n    ptRowMatch: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n    if (ptRowMatch == null)\n      ptRowMatch= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n    \n    // Prepare new point dict\n    ptDict: {point,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: connectorId,\n             connRef: connectorId,\n             cur,\n             bacnetCur: row->bacnetCur,\n             bacnetHis: row[\"bacnetHis\"], //optional\n             bacnetCurName: row->bacnetCurName,\n             bacnetHisName: row[\"bacnetHisName\"],\n             kind: ptRowMatch[\"kind\"], //optional\n             unit: ptRowMatch[\"unit\"], //optional\n             enum: ptRowMatch[\"enum\"], //optional\n             equipRef: equipId,\n             his,\n             notes: row[\"alcDisplay\"], //optional\n             locationRef: locationId,\n             siteRef: siteId,\n             tz: \"Los_Angeles\",\n             tmp: today()}\n               \n    // Set collection interval / cov if no bacnetHis\n    if (row[\"bacnetHis\"] == null)\n      if (ptRowMatch[\"kind\"] == \"Bool\") do\n        ptDict= ptDict.set(\"hisCollectCov\", marker())\n        ptDict= ptDict.set(\"hisCollectInterval\", 12h)\n      end else do\n        ptDict= ptDict.set(\"hisCollectInterval\", 15min)\n      end\n\n    // Add navName and meaningful tags from standard\n    tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n    ptDict= ptDict.set(\"navName\", tagRow->dis)\n    tagSet: tagRow->tagsPtOnly.split(\",\")\n    tagSet.each tag => do\n      ptDict= ptDict.set(tag, marker())\n    end\n\n    // Commit if finalize == true\n    if (finalize) do\n      commit(diff(null, ptDict, {add}))\n    end\n\n    return ptDict\n  end) // alcPtList.addRow(\"newPt\", row\n  \n  return alcPtList\nend\n \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"syncALC",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Backfill ALC point data starting from 1 years ago\n  and ending either now OR first successful write of\n  data that was pulled via Raph's function. Then calls\n  second function that backfills from 2 years ago to\n  1 year ago so as to avoid data bottlenecking.\n  \n  Arguments: \n  point    ALC Device point with point->alcPath variable\n  \n  // LBNL // JBR // Last Update: 2019-01-28 //\n*/\n\n\n(point) => do\n\nfirst_write: (point_again) => do\n  // If no historical data available, then backfill data from 1 years to now\n  if(point_again[\"hisStart\"] == null) do\n    start_date: now() - 1year - 7day // Start query 1 years + 7 days ago (to avoid any buffer issues)\n    end_date: now()\n    end\n    \n  // Else backfill from 1 years to first successful write date\n  else do\n    start_date: now() - 1year - 7day\n    end_date: point_again->hisStart // End query at history start of trusted data\n    end\n    \n  // Set link number to appropriate id for hisWrite\n  link: readById(point_again->id)\n  \n  // Format datetime strings\n  start_string: start_date.format(\"YYYY-MM-DD kk:mm:ss aa\")\n  end_string: end_date.format(\"YYYY-MM-DD kk:mm:ss aa\")\n  \n  // Construct URI from alcPath and previous history timestamps.\n  uri: point_again->alcPath.toStr() + \"?\" + start_string + \"?\" + end_string + \"?alc\"\n \n  // Local Python server is running on port 9000\n  query: \"http://localhost:9000/?\"+uri\n  \n  // Call ioReadJson to Python server for middleman request\n  // Parse returned timeseries string into JSON format\n  data: ioReadJson(``+query)\n\n  resultList: []\n  // Iterate on rows, parse and store/write data\n  data[\"value\"].map row => do\n    datum_list: row[1]\n    time_list: row[0]\n    time_list = parseDateTime(time_list+\" Los_Angeles\", \"YYYY-MM-DD hh:mm:ss\", \"Los_Angeles\")\n    resultList = resultList.add({ts: time_list, val: datum_list})\n  end\n  \n  resultGrid: resultList.toGrid\n  filteredGrid: resultGrid.findAll(row => row->ts < link[\"hisStart\"] - 1s)\n  hisWrite(filteredGrid, link)\n  hisSync(10min) // block until all writes are complete\n  \n  point_again = readById(point_again->id)\n  second_write(point_again) // call second write\n  \nend // end first_write\n\n\n/*************************************************/\n\n\n// Doing same function but for the year before last. Avoiding too much data pull at once.\nsecond_write: (point_second) => do\n// If no historical data available, then backfill data from 2 years to 1 year\n  if(point_second[\"hisStart\"] == null) do\n    start_date2: now() - 2year - 7day // Start query 2 years + 7 days ago (to avoid any buffer issues)\n    end_date2: now()\n    end\n    \n  // Else backfill from 2 years to first successful write date\n  else do\n    start_date2: now() - 2year - 7day\n    end_date2: point_second->hisStart // End query at history start of trusted data\n    end\n    \n  // Set link number to appropriate id for hisWrite\n  link2: readById(point_second->id)\n  \n  // Format datetime strings\n  start_string2: start_date2.format(\"YYYY-MM-DD kk:mm:ss aa\")\n  end_string2: end_date2.format(\"YYYY-MM-DD kk:mm:ss aa\")\n  \n  // Construct URI from alcPath and previous history timestamps.\n  uri2: point_second->alcPath.toStr() + \"?\" + start_string2 + \"?\" + end_string2 + \"?alc\"\n \n  // Local Python server is running on port 9000\n  query2: \"http://localhost:9000/?\"+uri2\n  \n  // Call ioReadJson to Python server for middleman request\n  // Parse returned timeseries string into JSON format\n  data2: ioReadJson(``+query2)\n\n  resultList2: []\n  // Iterate on rows, parse and store/write data\n  data2[\"value\"].map row => do\n    datum_list2 : row[1]\n    time_list2 : row[0]\n    time_list2 = parseDateTime(time_list2+\" Los_Angeles\", \"YYYY-MM-DD hh:mm:ss\", \"Los_Angeles\")\n    resultList2 = resultList2.add({ts: time_list2, val: datum_list2})\n  end\n  \n  resultGrid2: resultList2.toGrid\n  filteredGrid2: resultGrid2.findAll(row => row->ts < link2[\"hisStart\"] - 1s)\n  hisWrite(filteredGrid2, link2)\n  \nend //end second_write\n/******************************************************************/\n\n\nfirst_write(point)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptEnergyToPower",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual power point based on\n  the first delta energy point located in the same equip.\n  First, roll up energy using sum at provided hisVirtualInterval.\n  Then, multiply results by 60 / hisVirtualInterval.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  meterEq: readById(rec->equipRef)\n  energyPt: read(energy and delta and not hidden and equipRef==meterEq->id,false)\n  if (energyPt==null) return null\n  \n  try interval: rec->hisVirtualInterval\n  catch return null\n  \n  if (interval==0) return null\n  \n  energyPt.hisRead(dates, {limit: null})\n          .hisRollup(sum, interval)  // Must sum for energy values, NAs will roll up\n          .hisMap(v => if (v==null or v==na()) na()\n                       else (v * 60min / interval.to(\"min\"))\n                            .as(if(unit(v)==\"kWh\") \"kW\"\n                                else if(unit(v)==\"BTU\") \"BTU/h\"\n                                else if(unit(v)==\"kBTU\") \"kBTU/h\"\n                                else 1)\n                 )\n         .each(row => yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anAhuZoneTempDeadbands",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze terminal unit trends for all terminal units related to\n  given AHU and return historical trends of zone temperature\n  deadband widths.\n  \n  Can specify max deadband (e.g. 10°F)\n  \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDb        number, cap deadband width at this number\n  rollup       duration, interval for rollup of trends\n*/\n\n(ahuRef, dates: yesterday(), maxDb: 8°F, rollup: 15min, zoneIdList: null) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve a grid of all supply terminal units associated with AHU\n  tus: readAll(supply and terminalUnit and ahuRef==ahuRef)\n  \n  // Optional filter by zone ID\n  if (zoneIdList != null)\n    tus= tus.findAll(row => zoneIdList.contains(row->equipRef))\n  \n  // Return null if no associated terminal units are found\n  if (isEmpty(tus)) return null\n  \n  // Cycle through zones\n  dbs: {}.toGrid()\n  tus.each(tu => do\n    // Find ZAT setpoints\n    coolSp: read(point and zone and air and temp\n                 and effective and cooling and sp\n                 and equipRef==tu->id, false)\n\n    heatSp: read(point and zone and air and temp\n                 and effective and heating and sp\n                 and equipRef==tu->id, false)\n   \n    // If any setpoint is missing, return NA values (blank)\n    if (coolSp==null) coolSp= {}\n    if (heatSp==null) heatSp= {}\n    \n    room: if (tu.has(\"equipRef\")) readById(tu->equipRef)\n          else tu\n    dis: if (readAll(supply and terminalUnit and equipRef==room->id).size >= 2)\n           room->navName + \" \" + reGroups(\"\"\"(Supply,? )?(.*)\"\"\",tu->navName)[2]\n         else room->navName\n    \n    // Col name based on zone name\n    if (tu.has(\"equipRef\"))\n      colName: tu->equipRef->navName.toTagName()\n    else\n      colName: tu->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    flags: [heatSp, coolSp].hisRead(dates, {limit: null})\n        .hisInterpolate()\n        .hisRollup(avg, rollup)\n        .addCol(colName, row => do\n          if (row[\"v0\"]==null or row[\"v1\"]==null\n              or row[\"v0\"]==na() or row[\"v1\"]==na()\n              or row[\"v0\"]==0 or row[\"v1\"]==0)\n            return na()\n          else do\n            clg: row[\"v1\"].to(\"°F\")\n            htg: row[\"v0\"].to(\"°F\")\n            db: min(maxDb, (clg-htg).as(\"°F\")).as(\"°F\")\n            return db\n          end\n        end)\n        .keepCols([\"ts\",colName])\n        .addColMeta(colName, {dis: dis, unit:\"°F\"})\n             \n    // Add to deadbands summary array\n    if (isEmpty(flags)) return null\n    if (isEmpty(dbs)) dbs=flags\n    else dbs= hisJoin([flags,dbs])\n  end)\n  \n  return dbs\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"sqlTestScript5",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  sql: \"SELECT *\" +\n       \" FROM ION_Data.dbo.Source S\"\n\n  data: read(sqlConn and dis==\"ionDB2019\").sqlQuery(sql)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Elec Usage vs Prev Year (kWh)",,M,"Delta of electricity consumption between selected time range and previous year.",,,"site",,"kpiElecUsageVsPrevYear",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(energy and delta and sensor and not hidden and equipRef->elec\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n           \n  if (pt == null) return null\n\n  try do\n    cur: hisRead(pt, dates, {limit:null}).hisClip().foldCol(\"v0\", sum)\n    base: hisRead(pt, dates - 364day, {limit:null}).hisClip().foldCol(\"v0\", sum)\n    {delta: (cur - base).as(1)}\n  end catch null\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptMetricsSiteWUE",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This virtual point function (hisFunc) calculates the site WUE\n  (water utilization effectiveness) simply as the CT Make-up Water \n  Flow/Compute Power.\n  \n  **This does not account for evaporative cooling at the AHUs or the \n  additional IT loads in the building.\n  \n  \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n\n  computerRef: rec->equipRef\n  computeMeter: read(meter and compute and equipRef==computerRef, false)\n  computePowerPt: read(power and sensor and equipRef==computeMeter->id, false)\n  fanMeter: read(meter and fan and equipRef==computerRef, false)\n  fanPowerPt: read(power and sensor and equipRef==fanMeter->id, false)  \n  \n  interval: rec->hisVirtualInterval\n  \n  //Name the location for the water meter(s)\n  twLocRef: @p:lbnl:r:22dbdae2-0f98c395\n  \n  \n  //Grab make-up water trends for B59\n  muWaterPts:readAll(locationRef==twLocRef\n                    and equipRef->makeup\n                    and flow\n                    and sensor)\n  \n  //hisRead and rollups for these histories\n  muWaterFlow: muWaterPts.hisRead(dates, {limit:null})\n                             .hisRollup(avg, interval)\n                             .hisMap(v=> v.to(\"L/h\"))\n                             .renameCol(\"v0\",\"muFlow\")\n  \n  computePower: computePowerPt.hisRead(dates, {limit:null})\n                              .hisRollup(avg, interval)\n                              .renameCol(\"v0\",\"compute\")\n\n  \n  grid: hisJoin([muWaterFlow, computePower])\n        .addCol(\"sitewue\", row => do\n          if (row.any(v => v==null or v==na() or v==0)) return na()\n          else return (row->muFlow / row->compute).as(1)\n        end)\n        .each(row => yield(row->ts, row->sitewue))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"initNerscElastic",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This script is meant to handle initial population of\n LBNL NERSC point histories using a large query from Elasticsearch.\n \n NOTE: Since it is through recursion, stack overflow may occur due to large data pulls.\n // Last Update: 2019-01-17 //\n*/\n(point, start_time) => do\n  // Set parameters: range of dates to query from Elasticsearch\n  // First iteration will grab from beginning of history\n  // Rest of interations will grab in 1 hour increments onwards until current time is reached\n\n write_to_point: (point_again, start_time_again) => do\n   link: readById(point_again->id)\n   factor: point_again->factor\n \n   if (start_time_again > (now() - 2min))\n     return 1\n   \n   // Prepare query\n   start_string: start_time_again.format(\"YYYY-MM-DD'T'hh:mm:ss\") // Start query at last record OR initialized start for first run\n   \n   if (start_time_again + 6hr > now())\n      end_string: now()\n   else\n      end_string: start_time_again + 6hr\n    \n   end_string = end_string.format(\"YYYY-MM-DD'T'hh:mm:ss\")\n\n   // Prepare query\n   baseURI: \"{\\\"index\\\":\\\"\"+ point->elasticIndex + \"\\\",\\\"metric\\\":\\\"\"+ point->elasticMetric + \"\\\"\"\n   fullURI: baseURI + \",\\\"value\\\":\\\"data.datum\\\",\\\"time\\\":\\\"@timestamp\\\",\\\"start\\\":\\\"<start_time>\\\",\\\"end\\\":\\\"<end_time>\\\"}?elastic\"\n  \n   uri: fullURI.toStr().replace(\"<start_time>\",start_string).replace(\"<end_time>\", end_string)\n \n   // Local Python server is running on port 9000\n   query: \"http://localhost:9000/?\"+uri\n\n   // Call ioReadJson to Python server for middleman request\n   // Parse returned timeseries string into JSON format\n   data: ioReadJson(``+query)\n\n   // Iterate on rows, parse and store data\n   data[\"value\"].map row => do\n     datum_list: row[1] / factor // Divide by factor for kW\n     time_list: row[0]\n     time_list = parseDateTime(time_list+\" Los_Angeles\", \"YYYY-MM-DD'T'hh:mm:ss.zzz\", \"Los_Angeles\")\n     {ts: time_list, val: datum_list}.hisWrite(link)\n   end\n   \n   hisSync() // block until all writes are complete\n   \n   link = readById(point_again->id)\n   start_time_new: link->hisEnd // update start time to equal last successful measurement\n   \n   write_to_point(point_again, start_time_new) // Make recursive call to function\n end // end write_to_point\n \n \n  write_to_point(point, start_time)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateDeficiencyGroupNote","recValidateDeficiency","recValidateDeficiencyGroup"],,,,M,,,,,,"recNewDeficiencyGroupNote",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyGroupNoteDict) => do\n  // Normalize action input\n  deficiencyGroupNoteDict= actionNormInput(deficiencyGroupNoteDict, \"dict\")\n  \n  if (deficiencyGroupNoteDict.has(\"id\") and not(deficiencyGroupNoteDict.has(\"deficiencyGroupRef\")))\n  deficiencyGroupNoteDict= deficiencyGroupNoteDict\n    .set(\"deficiencyGroupRef\", readById(deficiencyGroupNoteDict->id)[\"deficiencyGroupRef\"])\n  \n  deficiencyGroupNoteDict= deficiencyGroupNoteDict\n    .set(\"author\", userCur()->dis)\n   \n  deficiencyGroupNoteDict= deficiencyGroupNoteDict\n    .findAll((v,n) => [\"deficiencyGroupRef\",\n                       \"timestamp\",\n                       \"author\",\n                       \"deficiencyGroupNote\"].contains(n))\n\n  // Validate record\n  deficiencyGroupNoteDict= recValidateDeficiencyGroupNote(deficiencyGroupNoteDict)\n\n  recNew(deficiencyGroupNoteDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateDeficiencyGroup",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  validateNotBlank(rec->navName)\n    \n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["facZoneClgReqIgnoresNow"],,,,M,,,,,,"facAhuClgReqIgnoresNow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, scan all zones for cooling requests to ignore and\n  return one calculated value of total number of cooling requests\n  to ignore now.\n  See:\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  ahuRef       Id of an ahu equip\n  reqTime      Time, duration a zone request is valid\n  disqualTime  Time, duration a spark disqualifies the zone requests\n  fixedIgnores Added fixed number of requests to ignore to avoid having a system\n               driven by just a few zones\n*/\n(ahuRef, reqTime: 30min, disqualTime: 24h, fixedIgnores:4) => do\n  // Normalization\n  ahuId: if (isRef(ahuRef)) ahuRef else ahuRef->id\n  ahu: readById(ahuId)\n  \n  // Locate all zones served by the AHU\n  tus: readAll(terminalUnit and equip and ahuRef==ahuId)\n  zones: tus.colToList(\"equipRef\")\n            .unique\n            .findAll(v => readById(v).has(\"zone\"))\n  \n  // Combine ignored requests from all zones\n  ignores: zones.map(z => facZoneClgReqIgnoresNow(z, reqTime, disqualTime))\n                .findAll(v => v != null)\n  \n  // Return sum\n  return (ignores.fold(sum) + fixedIgnores)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viMeterMonthlyRegression","toolFormatGrid","viMeterMonthly","viMeterMonthlyRegression_v2"],,,,M,,,,,,"viMeterMonthlyAnomalies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given date, load the previous 12 months of monthly readings for all electricity\n  and gas meters. For each meter, create a model based on that period, and check the reading\n  on the month of the given date versus the model-predicted reading. If absolute difference is\n  greater than provided threshold, flag the meter reading as anomalous.\n  \n  Arguments: \n  anDate               Date, run analysis on most recent read prior to given date\n  allowedPercentError  Allowed difference in % between actual and predicted read\n  allowedError         Allowed absolute difference between actual and predicted read if\n                       percent error is greater than threshold (filter out very low \n                       consumption)\n  showDataErrors       Bool, if true show missing readings and other data errors\n  filterStr            Str, (gas or elec) / gas / elec\n*/\n(anDate:today(), allowedPercentError:25%, allowedError:1000kWh, showDataErrors:false,\n filterStr:\"(gas or elec)\") => do\n  // Previous 12 months period\n  basePeriod: (date(anDate.year-1,anDate.month,1)..(date(anDate.year,anDate.month,1)-1day))\n  \n  grid: readAll(parseFilter(\"meter and sblid and \"+filterStr))\n  .findAll(m => m->sblid!=\"\")\n  .map(m => do\n    res: try viMeterMonthlyRegression_v2(m, \"Input\", null,\n                                         if (m.has(\"gas\")) 65°F else null,\n                                         if (m.has(\"elec\")) 55°F else null,\n                                         basePeriod, null, null, \"Anomaly\")\n       catch (ex) return {meterRef:m->id, errorDis:ex->dis}\n    dict: if (isGrid(res)) res.first else res\n    return dict.set(\"meterRef\",m->id)\n  end)\n  \n  // Show only readings (cons) that differ from model prediction (adjustedBase)\n  // by more than allowedError\n  .addCol(\"diff\", r => if (r[\"cons\"]==null) null\n                       else r[\"cons\"]-r[\"adjustedBase\"])\n  .addCol(\"error\", r => if (r[\"cons\"]==null) null\n                       else abs(r[\"cons\"]-r[\"adjustedBase\"]))\n  // Convert to kWh for filtering, with removal of optional \"_\" in front of unit\n  .addCol(\"errorkWh\", r => if (r[\"error\"]==null) null\n                          else r[\"error\"].as(reGroups(\"_?(.*)\",r[\"error\"].unit)[1]).to(\"kWh\"))\n  .addCol(\"percentError\", r => if (r[\"cons\"]==null or r[\"adjustedBase\"]==0) null\n                          else (r[\"error\"]/r[\"adjustedBase\"]*100).as(\"%\"))\n  .addCol(\"percentDiff\", r => if (r[\"cons\"]==null or r[\"adjustedBase\"]==0) null\n                          else (r[\"diff\"]/r[\"adjustedBase\"]*100).as(\"%\"))\n  .findAll(r => (showDataErrors and r[\"cons\"]==null) or\n                (r[\"percentError\"] > allowedPercentError and r[\"errorkWh\"] > allowedError))\n  // Add site display name for sorting\n  .addCol(\"siteDis\", r => try parseNumber(r->meterRef->siteRef->dis).format(\"000\")\n                          catch r->meterRef->siteRef->dis)\n  // Add reading id back in (removed during regression)\n  .addCol(\"id\", row =>\n      if (row.missing(\"readDate\") or row.missing(\"meterRef\")) null\n      else read(monthlyRead and meterRef==row->meterRef and readDate==row->readDate)[\"id\"])\n  // Add reading context notes back in (removed during regression)\n  .addCol(\"notes\", row =>\n      if (row.missing(\"id\")) null\n      else readById(row->id)[\"notes\"])\n  // Add mod back in (removed during regression)\n  .addCol(\"mod\", row =>\n      if (row.missing(\"id\")) null\n      else readById(row->id)[\"mod\"])\n  // Show only more important columns, in specified order\n  .toolFormatGrid([\"meterRef\",\"readDate\",\"cons\",\"adjustedBase\",\"error\",\n                   \"percentError\",\"percentDiff\",\"notes\",\"errorDis\"])\n  if (isEmpty(grid)) return {dis:\"None\"}\n                            .toGrid()\n                            .addColMeta(\"dis\", {dis:\"Meter with potential anomaly\"})\n  \n  // Display names\n  if (grid.has(\"meterRef\")) grid= grid.addColMeta(\"meterRef\", {dis:\"Meter with potential anomaly\"})\n  if (grid.has(\"readDate\")) grid= grid.addColMeta(\"readDate\", {dis:\"Read date\"})\n  if (grid.has(\"cons\")) grid= grid.addColMeta(\"cons\", {dis:\"Measured consumption\"})\n  if (grid.has(\"adjustedBase\")) grid= grid.addColMeta(\"adjustedBase\", {dis:\"Predicted consumption\"})\n  if (grid.has(\"error\")) grid= grid.addColMeta(\"error\", {dis:\"Error\"})\n  if (grid.has(\"percentError\")) grid= grid.addColMeta(\"percentError\", {dis:\"Percent error\"})\n  if (grid.has(\"percentDiff\")) grid= grid.addColMeta(\"percentDiff\", {dis:\"Percent difference\"})\n  if (grid.has(\"notes\")) grid= grid.addColMeta(\"notes\", {dis:\"Context notes\"})\n  if (grid.has(\"errorDis\")) grid= grid.addColMeta(\"errorDis\", {dis:\"Data error message\"})\n  return grid\n         .sort((a,b) => a->siteDis <=> b->siteDis)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"facZoneHtgReqIgnoresNow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given zone calculate if and how many heating requests should be ignored \n  by the AHU now based on recent data (~15min) and recent sparks (~5h).\n  See:\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  zoneRef      Id of a zone equip\n  reqTime      Time, duration a zone request is valid\n  disqualTime  Time, duration a spark disqualifies the zone requests\n*/\n(zoneRef, reqTime: 30min, disqualTime: 24h) => do\n  // Normalization\n  zoneId: if (isRef(zoneRef)) zoneRef else zoneRef->id\n  zone: readById(zoneId)\n  \n  // List disqualifying spark rules\n  disqualSparks: readAll(sparkRule and (\n    id==@p:lbnl:r:25a8f1eb-122139f5     // Zone RHV Open & Low DAT\n    or id==@p:lbnl:r:23349ae7-9e15f6d0  // Airflow SP not met\n    or id==@p:lbnl:r:254ccab9-f826ac0c  // Zone htg SP too high\n  ))\n  \n  // Load sparks\n  ruHis: ruleSparks(\n           toolRecursiveSearch(zoneId, \"equip and supply\")\n           .addRow(zone),\n           now()-disqualTime..now(),\n           disqualSparks)\n         .ruleSparkHis()\n  \n  // Combine periods\n  disqualPeriods: hisPeriodUnion(\n    // List of columns other than ts\n    ruHis.colNames.remove(0)\n    // Map from list creates a list, here a list of sub-grids\n    .map(colN => ruHis.keepCols([\"ts\", colN])\n                      .findAll(row => row[colN] != null)))\n  // Extend period by disqualTime\n  .hisPeriodShift(0min, disqualTime)\n  \n  // Find heating requests, any type except water\n  reqPt: toolRecursiveSearch(zoneId, \"heat and request and cmd and not water\") \n         .first  // Only one per zone for now\n  \n  // Exit with zero if no heating request\n  if (reqPt==null) return 0\n  \n  // Load history of heating requests\n  req: reqPt.hisRead(now()-reqTime..now(), {limit:null})\n  // Clip if not COV\n  if (reqPt[\"hisMode\"]!=\"cov\")\n    req= req.hisClip\n  \n  // Only keep last valid reading\n  if (isEmpty(req)) return null\n  else try req= req.find(r => r->ts==req.col(\"v0\").meta->hisEnd)\n       catch req= null\n\n  if (req==null) return null\n\n  // Check overlap between disqualifying conditions and last request\n  if (hisInWindows(if(reqPt[\"hisMode\"]!=\"cov\")req->ts else now(), disqualPeriods)) do\n    // Store terminal unit level value if corresponding point exists and this runs as a job\n    writePt: toolRecursiveSearch(zoneId, \"general and heat and ignore and cmd\").first\n    if (writePt!=null and jobIsRunning())\n      hisWrite({ts:now(), val:req->v0.as(1)}, writePt)\n    // Return value to main function\n    return req->v0.as(1)\n  end else do\n    // Store terminal unit level value if corresponding point exists and this runs as a job\n    writePt: toolRecursiveSearch(zoneId, \"general and heat and ignore and cmd\").first\n    if (writePt!=null and jobIsRunning())\n      hisWrite({ts:now(), val:0}, writePt)\n    // Return value to main function\n    return 0\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"syncNerscElasticSecondary",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function queries local server in 6hr increments according\n  to start and end dates. Makes recursive calls if range is greater\n  than 6hr and does so according to incremental tag variable.\n  Updates increment at end of calling.\n  \n  Arguments: \n  point             NERSC Elastic point\n  absolute_start    dateTime object specifying start of ranged query\n  absolute_end      dateTime object specifying end of ranged query\n  absolute_backfill dateTime object specifying the backfill start\n  first_run         Boolean variable specifying that backfill variable is used or not\n  \n  // LBNL // JBR // Last Update: 2019-03-14 //\n*/\n\n(point, absolute_start, absolute_end, absolute_backfill, first_run) => do\n\n  // Inner function for recursion purposes\n  first_write: (point_again, inner_abs_start, inner_abs_end, num, backFill, inner_first) => do\n  \n  // If 10 recursive calls are made then update backfill tag and exit\n  if(num == 10) do\n    diff(point_again, {tempBackFill:backFill, -oldTag}).commit\n    return \"60 hour backfill complete\"\n  end\n  \n  if(inner_abs_start == backFill)\n    return \"Point already backfilled to specified date\"\n  \n    \n  // Set link number to appropriate id for hisWrite and tempDate write\n  link: readById(point_again->id)    \n  \n  // If 6hr sync then set start and end accordingly\n  if(inner_abs_end - inner_abs_start <= 6hr ) do // 6 hour sync of data\n    start_date: inner_abs_start\n    end_date: inner_abs_end\n  // else if reach end of backfill period\n  else if(inner_abs_start > (backFill - 6hr) ) do\n    start_date: inner_abs_start\n    end_date: inner_abs_start + 6hr\n  // else if first run of new backfill period\n  else if(inner_first) do\n    start_date: inner_abs_end - 6hr\n    end_date: inner_abs_end\n  // Else backfill according to 6hr incremental tag variable\n  else do\n    start_date: backFill - 6hr\n    end_date: backFill\n  end\n  \n  // convert dateTime to UTC\n  start_date = start_date.toTimeZone(\"UTC\")\n  end_date = end_date.toTimeZone(\"UTC\")\n  \n  // Format datetime strings\n  start_string: start_date.format(\"YYYY-MM-DD'T'hh:mm:ss\")\n  end_string: end_date.format(\"YYYY-MM-DD'T'hh:mm:ss\")\n  \n  // Prepare query\n  baseURI: \"{\\\"index\\\":\\\"\"+ point_again->elasticIndex + \"\\\",\\\"metric\\\":\\\"\"+ point_again->elasticMetric + \"\\\"\"\n  fullURI: baseURI + \",\\\"value\\\":\\\"data.datum\\\",\\\"time\\\":\\\"@timestamp\\\",\\\"start\\\":\\\"<start_time>\\\",\\\"end\\\":\\\"<end_time>\\\"}?elastic\"\n  \n  uri: fullURI.toStr().replace(\"<start_time>\",start_string).replace(\"<end_time>\", end_string)\n  // Local Python server is running on port 9000\n  query: \"http://128.3.66.91:9000/?\"+uri\n\n  try do\n     // Call ioReadJson to Python server for middleman request\n     // Parse returned timeseries string into JSON format\n     data: ioReadJson(``+query)\n  end catch(ex) do // Catch any errors\n    // Skip over 6 hour period for next run\n    diff(point_again, {tempBackFill:start_date, -oldTag}).commit\n    return {message:\"Period Blackout - skipping over 6 hour period\",error:ex}\n  end // end try-catch\n  \n  result_list: []\n  // Iterate on rows, parse and store/write data\n  data[\"value\"].map row => do\n    datum_list: row[1] / point_again->factor\n    time_list: row[0]\n    time_list = parseDateTime(time_list+\" UTC\", \"YYYY-MM-DD'T'hh:mm:ss.zzz\", \"UTC\")\n    time_list = time_list.toTimeZone(\"Los_Angeles\") // Convert dateTime back to PST\n    result_list = result_list.add({ts: time_list, val: datum_list})\n  end\n  \n  result_grid: result_list.toGrid\n  \n  // If 6hr sync then write only the new data since hisEnd and exit\n  if(inner_abs_end - inner_abs_start <= 6hr ) do\n    filtered_grid: result_grid.findAll(row => row->ts > point_again->hisEnd + 1s)\n    hisWrite(filtered_grid, link)\n    hisSync()\n    return \"6 hour sync complete\"\n  // Else if last write for backFill then write and exit\n  else if(inner_abs_start > (backFill - 6hr) ) do\n    filtered_grid: result_grid.findAll(row => row->ts < end_date - 1s)\n    hisWrite(filtered_grid, link)\n    hisSync()\n    diff(point_again, {tempBackFill:inner_abs_start, -oldTag}).commit\n    return \"Backfill to start complete\"\n  // Else write backfill data that is older than current backfill date\n  else do\n    filtered_grid: result_grid.findAll(row => row->ts < end_date - 1s)\n    hisWrite(filtered_grid, link)\n    hisSync() // block until all writes are complete\n  end\n  \n  num = num + 1\n  inner_first = false\n  \n  first_write(point_again, inner_abs_start, inner_abs_end, num, start_date, inner_first)\n  \nend // end first_write\n\nfirst_write(point, absolute_start, absolute_end, 0, absolute_backfill, first_run)\n\nend // end all\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHierarchy","fandocDeficiencyLinks","fandocDeficiency"],,,,M,,,,,,"fandocDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyRef, limit:null) => do\n  def: readById(deficiencyRef)\n  \n  // Title\n  doc: dis(def)+\"\\n-----\\n\"\n  // Status\n  if (limit==null)\n    doc= doc+\"Current status: **\"+def->state+\"**\\n\\n\"\n  // Dates\n  datesDoc: []\n  if(def.has(\"startDate\"))\n    datesDoc= datesDoc.add(\"started on **\"\n                           +def->startDate.format(\"YYYY-MM-DD\")\n                           +\"**\")\n  if(def.has(\"endDate\"))\n    datesDoc= datesDoc.add(\"ended on **\"\n                           +def->endDate.format(\"YYYY-MM-DD\")\n                           +\"**\")\n  datesDoc= datesDoc.concat(\" and \")\n\n  if(isEmpty(datesDoc) and limit==null)\n    doc= doc+\"Deficiency start and end dates are unknown \"\n            +\"or not applicable.\"\n  else if (limit==null)\n    doc= doc+\"Deficiency \"+datesDoc+\".\"\n\n  // Description\n  if (limit==null)\n    doc= doc+\"\\n\\n---\\n*Description:*\\n\\n\"+ def->description\n  else do\n    clip: min(limit, def->description.size-1)\n    clipped: if (clip==limit) \"[...]\" else \"\"\n    desc: if (clip==limit) reGroups(r\"((.|\\n)* )\\S*\",def->description[0..clip])[1]\n          else def->description\n    return doc + \"\\n\\n\" + desc.replace(\"\\n\\n\",\" \") + clipped + \"\\n\\n---\\n\"\n  end\n  // Links\n  doc= doc+\"\\n\\n---\\n*Links:*\\n\\n\"+fandocDeficiencyLinks(deficiencyRef)\n  // Map\n  doc= doc+\"\\n\\n---\\n*Location:*\\n\\n\"\n  hierarchyList: if (def.has(\"equipRef\")) toolHierarchy(def->equipRef)\n                 else toolHierarchy(def->siteRef)\n  hierarchyList\n    .sort((a,b) => readById(a).dis.size <=> readById(b).dis.size)\n    .each((v,n) => do\n      sup: \"- \"\n      link: if (readById(v).has(\"filesLink\"))\n              \"[\"+readById(v).dis+\"]`\"+readById(v)->filesLink.toStr+\"`\"\n            else readById(v).dis\n      doc= doc+sup+link+\"\\n\"\n    end)\n  // Created\n  doc= doc+\"\\n\\n---\\nOriginally created by \"+ def->createdBy\n\n  return doc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"tmp_facZoneClgReqIgnores",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given zone and a given time span, calculate if and how\n  many cooling requests should be ignored by the AHU.\n  See:\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  zoneRef      Id of a zone equip\n  span         Time span to run analysis on\n*/\n(zoneRef, span, rollup:15min) => do\n  // Normalization\n  zoneId: if (isRef(zoneRef)) zoneRef else zoneRef->id\n  zone: readById(zoneId)\n  \n  // List disqaulifying spark rules\n  disqualSparks: readAll(sparkRule and (\n    id==@p:lbnl:r:233c485e-e5f94381     // Leaky reheat\n    or id==@p:lbnl:r:23349ae7-9e15f6d0  // Airflow SP not met\n    or id==@p:lbnl:r:254ccbf0-8e27e989  // Zone clg SP too low\n  ))\n  \n  // Load sparks\n  ruHis: ruleSparks(\n           toolRecursiveSearch(zoneId, \"equip and supply\")\n           .addRow(zone),\n           span,\n           disqualSparks)\n         .ruleSparkHis()\n  \n  // Combine periods\n  disqualPeriods: hisPeriodUnion(\n    // List of columns other than ts\n    ruHis.colNames.remove(0)\n    // Map from list creates a list, here a list of sub-grids\n    .map(colN => ruHis.keepCols([\"ts\", colN])\n                      .findAll(row => row[colN] != null)))\n                                   \n  // Load history of cooling requests\n  req: toolRecursiveSearch(zoneId, \"cool and air and request and cmd\")\n       .hisRead(span, {limit:null})\n       .hisRollup(min, 15min)\n  \n  // Filter (returns only rows / ts within disqualifying periods)\n  return req.hisMap((val, ts, his) => if (hisInWindows(ts, disqualPeriods)) val.as(1)\n                                      else 0)\n            .addColMeta(\"v0\", {dis:zone.dis+\n                               \" Ignored Requests - Colder Supply Air\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"zCustomB33DailyGasScatter",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of daily gas usage at B33 (in ft³) vs HDD\n  Compare pastWeek with the month prior\n  Also display baseline data\n*/\n\n() => do\n  x: read(weather and dis==\"LBNL Weather Station\").degreeDays(pastWeek, 65°F)\n  y: (read(siteRef->dis==\"33\" and equipRef->gas and volume and rate and not virtual).hisRead(pastWeek, {limit:null})\n      .hisRollup(avg, 1hr).hisInterpolate().hisMap pt => pt*60) // Average ft³/min over 1h and multiply by 60 to get hourly ft³\n    .hisRollup(sum, 1day).hisMap pt => pt.as(1ft³)\n  joined: hisJoin([x, y])\n  newSeries: joined.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsage\").findAll row => row->heat > 0\n  \n  xPrev: read(weather and dis==\"LBNL Weather Station\").degreeDays(pastMonth() - 7day, 65°F)\n  yPrev: (read(siteRef->dis==\"33\" and equipRef->gas and volume and rate and not virtual).hisRead(pastMonth() - 7day, {limit:null})\n           .hisRollup(avg, 1hr).hisInterpolate().hisMap pt => pt*60)\n         .hisRollup(sum, 1day).hisMap pt => pt.as(1ft³)  // Average ft³/min over 1h and multiply by 60 to get hourly ft³\n  joinedPrev: hisJoin([xPrev, yPrev])\n  newSeriesPrev: joinedPrev.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsagePrevious\").findAll row => row->heat > 0\n  \n  xBase: read(weather and dis==\"LBNL Weather Station\").degreeDays(2017-02-01..2017-05-31, 65°F)\n  yBase: (read(siteRef->dis==\"33\" and equipRef->gas and volume and rate and not virtual).hisRead(2017-02-01..2017-05-31, {limit:null})\n           .hisRollup(avg, 1hr).hisInterpolate().hisMap pt => pt*60)\n         .hisRollup(sum, 1day).hisMap pt => pt.as(1ft³)  // Average ft³/min over 1h and multiply by 60 to get hourly ft³\n  joinedBase: hisJoin([xBase, yBase])\n  newSeriesBase: joinedBase.keepCols([\"heat\",\"v0\"]).sort(\"heat\").renameCol(\"v0\",\"gasUsageBase\").findAll row => row->heat > 0\n  \n  allJoined: joinAll([newSeriesBase, newSeriesPrev, newSeries], \"heat\")\n  allJoined.addMeta({chartType: \"scatter\", title: \"Comparison of B33 daily natural gas usage versus HDD\"})\n    .addColMeta(\"gasUsage\", {chartType: \"scatter\", dis: \"Past week daily usage\"})\n    .addColMeta(\"gasUsagePrevious\", {chartType: \"scatter\", color: \"#CCCBCB\", dis: \"Prior month daily usage\"})\n    .addColMeta(\"gasUsageBase\", {chartType: \"scatter\", color: \"#D29A9A\", dis: \"Baseline daily usage\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viMeterQuality","viMeterQuality_v2"],,,,M,,,,,,"viMeterQualityAndDegreeDays",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, and a given span, return a chart with degree days\n  and timeline of data validity.\n  \n  Arguments: \n  meterRef        Target id\n  span            Datespan\n*/\n\n(meterRef, span, ddRef:65°F) => do\n  // Retrieve data quality chart\n  qChart: viMeterQuality_v2(meterRef, span)\n  \n  // Retrieve degree days chart\n  ddChart: readById(meterRef)->siteRef.degreeDays(span, ddRef)\n  \n  // Merge charts\n  chart: if (qChart==null or isEmpty(qChart)) ddChart else hisJoin([qChart, ddChart])\n  \n  // Format chart\n  chart= chart.map(\n      row => if(row.has(\"heat\"))\n             {ts: date(row->ts),//.format(\"D MMM-YYYY\"),\n              validity: row[\"validity\"],\n              heat: row->heat,\n              cool: row->cool*(-1)} else null)\n  if (chart.has(\"heat\"))\n    chart= chart.addColMeta(\"heat\", {chartType: \"bar\"})\n  if (chart.has(\"cool\"))\n    chart= chart.addColMeta(\"cool\", {chartType: \"bar\"})\n  if (chart.has(\"validity\"))\n    chart= chart.addColMeta(\"validity\", {chartType: \"runtime\"})\n  chart= chart.addMeta({chartNoScroll})\n\n  return chart\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viWUEScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the WUE points for b59 and construct a scatter \n  chart with respect to outside air wetbulb temperature \n  for display on a graph\n    \n  Arguments: \n  dates            Span of dates we want to calculate the metric on\n  min              Min compute power\n  max              Max compute power\n  wueName          navName for WUE intended (if multiple, such as site v source)\n*/\n\n(dates: today, min: null, max: null, oatRef:\"Wetbulb\", wueName: null, compFilter: null, site: null) => do\n  //Default to site WUE\n  if(wueName==null)\n    wueName= \"WUE (site)\"\n    \n  //Default to B59\n  if(site==null)\n    site= @p:lbnl:r:221f652e-4f67467f\n    \n  // Default to B59 TW for Wetbulb readings (and null) and AHU 1 for Drybulb readings\n  if(oatRef==\"Wetbulb\") do\n    oatRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n    // Get Outside Air Wetbulb from oatRef\n    oaTemp: read(equipRef==oatRef and wetBulb)\n  else if(oatRef==\"Drybulb\") do\n    oatRef= read(equip and siteRef->dis==\"59\" and navName==\"AHU-1\")->id\n    // Get Outside Air Drybulb from oatRef\n    oaTemp: read(equipRef==oatRef and temp and air and outside and not wetBulb)\n  end\n\n  // Default to B59 Computer Compute Meter if none is provided\n  if(compFilter==null)\n    compFilter= read(siteRef==site and equipRef->navName==\"Computers\" and compute and meter and virtual and equip)   \n    \n  // Get the WUE trend for this siteRef and hisInterval\n  wue: read(siteRef==site and navName==wueName and point)\n  \n  //Get compute power for given comp filter\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n  \n  // Interpolate, filter the pue\n  loopTrend: hisRead(wue,dates,{limit:null})\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"wue\")\n  if (isEmpty(loopTrend.hisClip)) return null\n  \n  oaWetBulb: hisRead(oaTemp, dates, {limit:null})\n                  .renameCol(\"v0\",\"oaTemp\")\n\n  powerFilter: hisRead(compPower, dates, {limit:null})\n  //Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))\n\n  //Add OA Wetbulb and filter to WUE\n  metric: hisJoin([oaWetBulb, loopTrend])\n            .hisFindInPeriods(powerFilter)\n            .addColMeta(\"oaTemp\",\n              {chartType: \"scatter\",\n               dis: \"OAT \"+oatRef,\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"wue\",\n              {chartType: \"scatter\",\n               dis: wueName,\n               unit: \"L/kWh\", color: \"#3F51B5\",\n               chartGroup: \"all\"})\n            \n  metricScatter: metric.keepCols([\"oaTemp\",\"wue\"])\n                       .addMeta({chartType: \"scatter\", \n                               title: \"NERSC WUE (L/kWh) vs. \" +oaTemp->navName})\n  \n  return metricScatter\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viExhZoneDampers",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given exhaust system, load exhaust damper positions for all TUs and \n  fume hoods served by that system, then display the result on a heat map\n    \n  Arguments: \n  exhRef       ref, ID of the exhaust system\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(exhRef, dates: yesterday(), rollup: 15min, colors: \"green, red\") => do\n  pts: readAll(damper and cmd\n               and ((equipRef->exhaust and equipRef->terminalUnit)\n                    or equipRef->fumeHood)\n               and equipRef->exhaustSystemRef==exhRef)\n         \n  if(isEmpty(pts)) return null\n  \n  try do\n    pos: pts.hisRead(dates, {limit:null})\n    \n    if (rollup>0)\n      pos= pos.hisRollup(avg, rollup)\n    else\n      pos= pos.toolHisAlign(avg, max)\n    \n    pos=pos.hisFlatten((val, ts, his) => do\n               eq: readById(his->equipRef)\n               eqD: if (eq.has(\"fumeHood\")) \" FH \" else \" Exh \"\n               room: if (eq.has(\"equipRef\")) readById(eq->equipRef)\n                    else eq\n               dis: if (readAll(equip and exhaustSystemRef and equipRef==room->id).size >= 2)\n                 room->navName + eqD\n                 + reGroups(\"\"\"(Exhaust,? |Fume Hood,? |Exh,?)?(.*)\"\"\",eq->navName)[2]\n               else room->navName\n               {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n                rm: dis,\n                v0: val}\n               end)\n           .reorderCols([\"ts\",\"rm\",\"v0\"])\n           .addColMeta(\"v0\", {chartMin: 0%,\n                              chartMax: 100%})\n           .addMeta({view: \"chart\", chartType:\"heatMap\", \n                     title: \"Exhaust damper commands, zones served by \"\n                            + readById(exhRef).dis() + \", \"\n                            + pos.meta[\"hisRollupInterval\"],\n                     colors: colors})\n  catch (ex) do\n    pos: null\n  end\n  return pos                     \nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptVirtualMeter"],,,,M,,,,,,"meterFormulaRead",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function loads meter formulas for a given SBLID elec or gas\n  meter from a pre-defined google sheet, parses them and returns a grid\n  \n  Arguments:\n  sblid       Numeric, SBLID of calculated meter\n  meterType   String, \"elec\" or \"gas\"\n*/\n\n(sblid, meterType) => do\n  // Prepare google sheet query;\n  // Spreadsheet needs to be publicly accessible\n  q_base: \"\"\"https://docs.google.com/spreadsheets/d/\"\"\"\n  q_doc: \"\"\"1kYCyKkiCaChbkdOAOwa2VbP_e6A_48jRgq6_i3raJ8E\"\"\"\n  q_type: \"\"\"/gviz/tq?\"\"\"\n  q_tq: \"\"\"tq=select * where A=\"\"\" + sblid\n  q_tqx: \"\"\"&tqx=out:csv&sheet=\"\"\" + meterType\n  query: q_base + q_doc + q_type + q_tq + q_tqx\n  \n  // Execute query\n  raw: ioReadLines(``+query)\n\n  // Headers are in line 1 (index 0)\n  h_str: raw[0]\n  h_list: h_str.split(\",\")\n  h_list_safe: h_list.map(str => toTagName(str))\n  \n  // Change some of the headers for better clarity\n  // in ptVirtualMeter function\n  h_list_safe= h_list_safe.map header => do\n    if (header == \"lNA\") return \"meter0\"\n    if (header == \"lNB\") return \"meter1\"\n    if (header == \"lNC\") return \"meter2\"\n    if (header == \"lND\") return \"meter3\"\n    if (header == \"lNE\") return \"meter4\"\n    if (header == \"lNF\") return \"meter5\"\n    if (header == \"lNG\") return \"meter6\"\n    if (header == \"lNH\") return \"meter7\"\n    if (header == \"lNI\") return \"meter8\"\n    if (header == \"multLNM1\") return \"globalMult\"\n    if (header == \"plusLNC1\") return \"globalAdder\"\n    return header\n  end\n\n  // Iterate on remaining rows, parse and store data in grid\n  raw[1..-1].map line => do\n    // Parse csv row and return list of sub-strings\n    // Parsing accounts for possibility of having comas within fields\n    // by replacing the commas outside of quotes with a new split character\n    v_list: line.replace(\"\\\",\\\"\",\"\\\"|\\\"\").split(\"|\")\n\n    // Start with empty dictionary, process each record\n    // from parsed csv row one by one\n    rec_dict: {}\n    v_list.each((rec, i) => do\n      // Remove leading and trailing \" characters,\n      // necessary based on google sheet csv format\n      rec = rec[1..-2]\n      \n      // Parse dates and numbers. Numbers default to 0.\n      if (h_list_safe[i] == \"startInclusive\")\n        rec = rec.parseDate(\"YYYY-MM-DD\")\n      if (h_list_safe[i] == \"endExclusive\" and rec != \"\")\n        rec = rec.parseDate(\"YYYY-MM-DD\")\n      if (h_list_safe[i] == \"globalMult\") do\n        rec = if(rec != \"\") rec.parseNumber() else 0\n      end\n      if (h_list_safe[i] == \"globalAdder\") do\n        rec = if(rec != \"\") rec.parseNumber() else 0\n      end\n      // Other records are passed through as strings\n      \n      // Use previously parsed header and set dictionary record\n      rec_dict = rec_dict.set(h_list_safe[i],rec)\n    end\n    )\n    // Complete dictionary was created for csv row\n    \n    // Pass this dict to map in order to create final grid from each\n    rec_dict\n  end\n  // map is complete, returns a grid containing all parsed formulas\n  // for given SBLID elec or gas meter.\n\nend\n\n/* Tested storage of grid into a tag, as zinc string, will be useful so we can retrieve\nthe formula without querying google every time. Then we can provide an update function\nto update formulas from google, and maybe run a job daily to update said formulas.\n\ncommit(diff(readById(@p:lbnl:r:222c3e8e-7a3d68b3), {meterFormula: testGoogleSheetRead(68, \"elec\").ioWriteZinc(\"\")}))\nreadById(@p:lbnl:r:222c3e8e-7a3d68b3)->meterFormula.ioReadZinc()\n\n*/\n\n/* Tested use of grid with multiple start options and selecting latest valid option\nby using sort:\ntestGoogleSheetRead(\"68\", \"elec\")\n  .findAll(row => (dateTime(2018-01-01, 00:00) >= row->start))\n  .toGrid().sortr(\"start\").first\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["scrapeConvertStrToNum","convertStrToDateTime"],,,,M,,,,,,"writeAcquisuite",,,"/*\n  Copyright 2020 Anthony Petelo\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function reads all Modbus points and fills in data from logs. The\n points must have the tags modhopperLog and modhopperCol, which,\n respectively, give the log that should be read and the position in which\n the data of interest sits.\n \n ***IMPORTANT: dataCol must be the number you are looking for plus\n               4. For example, if the data of interest is #5 (as\n               shown on the Modbus screenshot), dataCol must be 9.\n \n Arguments: (none)\n*/\n\n() => do\n  /*\n  // Test case: a single point (no loops for easy testing)\n  directory: ioDir(`ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/`)\n  directory= directory[3]\n  fileName: directory->name\n  fileName= \"ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/\"+fileName\n  fileName= parseUri(fileName)\n  \n  pt: read(point and modhopperLog==\"mb-033.log\")\n  col: pt->modhopperCol\n  raw: ioReadLines(fileName)\n  dataGrid: raw.map row => do\n    dataList: row.split(\",\")\n    data: dataList[col]\n    ts: dataList[0]\n    ts= ts.replace(\"'\",\"\")\n    {ts:ts,data:data}\n  end\n  dataGrid= dataGrid.toGrid\n  \n  dataGrid= dataGrid.map row => do\n    date: row->ts.split(\" \")[0]\n    time: row->ts.split(\" \")[1]\n    dateTime: convertStrToDateTime(date,time)\n    dateTime= dateTime.toTimeZone(\"Los_Angeles\")\n    val: scrapeConvertStrToNum(row->data)\n    {ts: dateTime, data: val}\n  end\n  \n  dataGrid= dataGrid.toGrid\n  \n  hisEnd: pt[\"hisEnd\"]\n  if (hisEnd==null) do\n    hisEnd= dateTime(date(2010,1,1),time(0,0,0))\n  end\n  dataGrid= dataGrid.findAll row => row->ts > hisEnd\n  \n  hisWrite(dataGrid,pt)\n  \n  return \"It works!\"\n  */\n  \n  ////////////////////////////////////////////////////////////////////////\n  // Cycling through logs approach                                      //\n  ////////////////////////////////////////////////////////////////////////\n  directory: ioDir(`ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/`)\n  regexDir: \"mb-\\\\d{3}.log\"\n  directory= directory.findAll row => reMatches(regexDir,row->name)\n  if (directory.size==0) do\n    return \"Network Error. No Logs Found.\"\n  end\n  \n  // Cycle through the available logs (the logs in the directory)\n  directory.each log => do\n    // Read the proper pts for each log, and get the position (col) of the\n    // data we are interested in for the point.\n    fileName: log->name\n    fileName= \"ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/\"+fileName\n    fileName= parseUri(fileName)\n    ptList: readAll(point and modhopperLog==log->name)\n    // Cycle through each point on that log.\n    ptList.each pt => do\n      col: pt->modhopperCol\n      raw: ioReadLines(fileName)\n      if (raw.size==0) do\n        return \"No Log File Found for point.\"\n      end\n      // For each row of the raw log, grab the data in the col of interest and\n      // put it in a grid. Also get the date/time, which is always the first\n      // item of the dataList.\n      dataGrid: raw.map row => do\n        dataList: row.split(\",\")\n        data: dataList[col]\n        ts: dataList[0]\n        ts= ts.replace(\"'\",\"\")\n        {ts: ts, data: data}\n      end\n      dataGrid= dataGrid.toGrid\n      \n      // Reformat data from str to val.\n      dataGrid= dataGrid.map row => do\n        date: row->ts.split(\" \")[0]\n        time: row->ts.split(\" \")[1]\n        dateTime: convertStrToDateTime(date,time)\n        dateTime= dateTime.toTimeZone(\"Los_Angeles\")\n        val: scrapeConvertStrToNum(row->data)\n        {ts: dateTime, data: val}\n      end\n      \n      // Convert to grid (if not already grid)\n      dataGrid= dataGrid.toGrid\n      \n      // Filter out redundant data. Since we are always adding data after\n      // hisEnd (no restartDate to recalculate from), simply findAll values\n      // that are after hisEnd.\n      hisEnd: pt[\"hisEnd\"]\n      if (hisEnd==null) do\n        hisEnd= dateTime(date(2010,1,1),time(0,0,0))\n      end\n      dataGrid= dataGrid.findAll row => row->ts > hisEnd\n      \n      // HisWrite data to point.\n      hisWrite(dataGrid,pt)\n    end\n  end\nend\n  \n  \n  \n  ////////////////////////////////////////////////////////////////////////\n  // Cycling through points approach                                    //\n  ////////////////////////////////////////////////////////////////////////\n  /*\n  // Read all relevant points.\n  ptList: readAll(siteRef==@p:lbnl:r:22c019b4-00a77829 and\n                  locationRef==@p:lbnl:r:22c0a4f3-5ef815ec and not virtual\n                  and modhopperLog and modhopperCol)\n  \n  \n  // Cycle through points in ptList.\n  ptList.each pt => do\n    // Read the proper log for each point, and get the position (col) of the\n    // data we are interested in for the point.\n    log: pt->modhopperLog\n    col: pt->modhopperCol\n    raw: ioReadLines(log)\n    // For each row of the raw log, grab the data in the col of interest and\n    // put it in a grid. Also get the date/time, which is always the first\n    // item of the dataList.\n    dataGrid: raw.map row => do\n      dataList: row.split(\",\")\n      data: dataList[col]\n      ts: dataList[0]\n      {ts: ts, data: data}\n    end\n    dataGrid= dataGrid.toGrid\n    \n    // Reformat data from str to val.\n    dataGrid= dataGrid.map row => do\n      dateTime: convertStrToDateTime(row->ts)\n      val: scrapeConvertStrToNum(row->data)\n      // (add units here, or later?)\n      {ts: dateTime, data: val}\n    end\n    \n    // Convert to grid (if not already grid)\n    dataGrid= dataGrid.toGrid\n    \n    // Filter out redundant data. Since we are always adding data after\n    // hisEnd (no restartDate to recalculate from), simply findAll values\n    // that are after hisEnd.\n    hisEnd: pt->hisEnd\n    dataGrid= dataGrid.findAll row => row->ts > hisEnd\n    \n    // Units?\n    \n    // HisWrite data to point.\n    // (insert hisWrite line here)\n    \n  end\n  */\n  \n  \n  \n  \n  //////////////////////////////////////////////////////////////\n  // Old approach                                             //\n  //////////////////////////////////////////////////////////////\n  \n  \n  \n  /*\n  // Initialize important variables.  \n  csv: ptList[0]->modhopperCsv\n  csv= parseUri(csv)\n  raw: ioReadLines(csv, {limit: null})\n  return raw\n  headers: raw[0]\n  data: raw[1..-1]\n  dataList: data.map data => do\n    dataN: data\n    dataN= dataN.split(\",\")\n  end\n  if (dataList[-1].contains(\"Exitcode 0 from zcat\")) do\n    dataList= dataList[0..-2]\n  end\n  sizeMetric: raw[1].split(\",\")\n  counter:0\n  lengthVector: dataList.map m => do // of the form [0..M-1]\n    m=counter\n    counter= counter+1\n    return m\n  end\n  \n  //////////////////////////////////////////////////////////////////////////\n  // This part of the code simply reconstructs the csv so that it can be  //\n  // easily read in Axon.                                                 //\n  //////////////////////////////////////////////////////////////////////////\n  \n  // Remove unnecessary commas.\n  regex: \"\\\"[^\\\",]+,[^\\\",]+\\\"\" // Expressions that have a comma inside quotes, meaning the name of that header has a comma in it. We want to eliminate this comma so that we can split along commas.\n  headerToReplace: null\n\n  sizeMetric.each line => do // Search for instances that match our regex expr, then replace. Iterate for number of data points, but only execute IF that expression matches.\n    if (reFind(regex,headers)!=null) do\n      headerToReplace= reFind(regex, headers)\n      headerToReplace= headerToReplace.replace(\",\",\"\") //Underscore can go here (Chris replaced unnecessary commas w/ underscores, so we could match them by using underscores, but it looks cleaner w/out them)\n      headers= headers.replace(reFind(regex,headers), headerToReplace)\n    end\n  end\n  \n  // Tinker with \"headers\" so that they are valid col names:\n  // No parentheses, dashes, or slashes. They must also start w/ a\n  // letter, not a number (hence, the \"x\" in front of every col name).\n  // Last, some columns are empty, so assign arbitrary numbers to the\n  // end of every header so that empty columns won't give error \"name\n  // already exists.\"\n  headers= headers.replace(\" \",\"\")\n  expr: \"\\\"\"\n  headers= headers.replace(expr,\"\")\n  headers= headers.replace(\"(\",\"\")\n  headers= headers.replace(\")\",\"\")\n  headers= headers.replace(\"-\",\"\")\n  headers= headers.replace(\"/\",\"\")\n  headers= headers.split(\",\")\n  index: 0\n  headers= headers.map header => do\n    index= index+1\n    header= \"x\"+header+\"_\"+toStr(index)\n  end\n\n  \n  // Use above headers, dataList, and lengthVector to reconstruct csv.\n  csvGrid: lengthVector.map( i => do\n    headers\n    dataI: dataList[i]\n    dataDict: {}\n    headers.each ((h,index) => do\n      dataDict= dataDict.set(h,dataI[index])\n    end)\n    return dataDict\n  end)\n  csvGrid= csvGrid.toGrid\n  \n  //////////////////////////////////////////////////////////////////////////\n  // Begin assigning values to points in this section                     //\n  //                                                                      //\n  //////////////////////////////////////////////////////////////////////////\n  \n  // Convert dates and times from string to dateTime\n  regexDate: \"\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}\"\n  regexTime: \"\\\\d{2}:\\\\d{2}:\\\\d{2}\"\n  timeCol: csvGrid.map row => do\n    string: row->xtimeUTC_1\n    date: reGroups(regexDate,string)[0]\n    time: reGroups(regexTime,string)[0]\n    dateTime: convertStrToDateTime(date, time, tz:\"GMT\")\n    {ts: dateTime}\n  end\n  \n  csvGrid= csvGrid.addCol(\"ts\", row => convertStrToDateTime(reGroups(regexDate,row->xtimeUTC_1)[0], reGroups(regexTime,row->xtimeUTC_1)[0], tz:\"GMT\"))\n  */\n  \n  \n\n\n\n\n// STUFF TO KEEP FOR REFERENCE UNTIL THE FUNCTION IS COMPLETE\n\n// Regex stuff to keep until we are sure we don't need it\n  //regex: \"\\\"[^\\\"]+\\\"\"\n  //regex: \"\\\"[^\\\"]+\\\"\"\n  //regex= \"\\\"[^\\\"\\,]+\\,[^\\\"\\,]+\\\"\"\n  //regex= \"\\\\\"[^\\\\\"\\\\,]+\\\\,[^\\\\\"\\\\,]+\\\\\"\"\n  //test: reGroups(\"\"\"time\"\"\", headers) // do I need \\\\ instead of \\ here?\n  //return headers\n  \n// While Loop:\n  /*while (reMatches(regex,headers)) do\n    headerToReplace= reFind(regex, headers)\n    headerToReplace= headerToReplace.replace(\",\",\"_\")\n    headers= headers.replace(reFind(regex,headers), headerToReplace)\n  end*/\n  \n//location: \"ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/mb-\" + csv + \".log\"\n//location= location.parseUri\n//log: ptList[0]->modhopperRef\n//csvList: ioDir(`ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/`)\n//csv: \"034\"\n//location: \"ftp://lucid-b50a-2.lbl.gov/../var/log/modbus/mb-\" + csv + \".log\"\n//location= location.parseUri\n\n//csvName:\"33\"\n//mac:\"001EC60024C7\"\n//location: \"io/acquisuite_logs/\" + mac + \"_\" + csvName + \".csv\"\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["foldHisDiffMin"],,"Accumulator Rolled Over",,M,"Accumulator decreased and decrease met rollover conditions",,,,,"ruMeterAccRollover",,"meter","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates) => do\n  // Get all non-virtual accumulator points\n  accs: readAll(point and accumulator and sensor\n                and not virtual\n                and equipRef==equip->id)\n  if (isEmpty(accs)) return null\n  \n  accs.hisRead(dates, {limit:null})\n      .hisRollup(foldHisDiffMin, 24hr)\n      .hisFindPeriods((val, ts, his) => do\n        rollover: his[\"rollover\"]\n        maxStep: his[\"maxAccStep\"]\n        if (rollover != null and maxStep == null)\n          maxStep= rollover / 10\n        if (rollover == null or maxStep == null)\n          return false\n        else\n          return (val < 0) and\n                 (val >= -rollover or\n                  val <= (-rollover + maxStep))\n      end)\nend\n \n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldDiffMin",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  if (val == foldStart()) return {last:na(), dmin: 0}\n  if (val == foldEnd()) return acc->dmin\n  if (val == na()) return na()\n  \n  if (acc->last == na()) return {last: val, dmin: 0}\n  return {last: val,\n          dmin: min(acc->dmin, val - acc->last)}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viWritables",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  The writable tag is used to allow SkySpark to write to an AO / BO.\n  This can be a dangerous functionality, therefore we monitor what points\n  have the writable tag, so we can make sure it is not applied by mistake.\n  This function simply returns the id of all points with the tag.\n  Return grid with:\n    id:            point id, for all points with writable tag\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  writables: readAll(point and writable)\n             .map(row => {\n                    idPointWritable: row->id\n                  }\n             )\n\n        \n  if (isEmpty(writables))\n    writables = {success: \"No point with tag \\'writable\\'\"}\n                .toGrid\n  \n  return writables\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"tmpMap91ZoneCached",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For all zone-level cached points, associated equipRef in the cache\n  based on connRef of the equips\n*/\n\n(connRefs:null) => do\n  cached: if(connRefs==null)\n            readAll(connPointCache and connRef->siteRef->dis==\"91\")\n          else\n            readAll(connPointCache).findAll(r => connRefs.contains(r->connRef))\n            \n  cached\n  .each cp => do\n    // Determine instance number\n    try do\n      inst: if (cp.has(\"bacnetCurName\")) reGroups(r\".*_(\\d*)\$\", cp->bacnetCurName)[1]\n      else reGroups(r\".*_(\\d*)\$\", cp->bacnetHisName)[1]\n    // Fails for items at controller level, like alarms, which don't have an instance number\n    catch do\n      // Remove existing equipRef and skip to next\n      commit(diff(cp, {-equipRef}))\n      return null\n    end\n    \n    // Find supply equip first\n    eq: read(equip and supply and \n             connRef==cp->connRef and connInstance==inst and \n             siteRef->dis==\"91\", false)\n    if (eq==null) eq= read(equip and connRef==cp->connRef and connInstance==inst and \n                           siteRef->dis==\"91\", false)\n    if (eq==null) do\n      // Remove existing equipRef and skip to next\n      commit(diff(cp, {-equipRef}))\n      return null\n    end\n    \n    // Add tags to cached point\n    commit(diff(cp, {equipRef:eq->id,\n                     controls: eq[\"controls\"]}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptAccumulatorToDelta",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates deltas between accumulator points, and\n assigns the delta 'forward', i.e. delta1 = (acc1 - acc0) at ts1\n Allow for \"multiplierNeeded\", \"rollover\" and \"maxAccStep\" tags\n on the source point.\n multiplierNeeded  Number, value to multiply raw reading by\n rollover          Number, maximum accumulator value\n maxAccStep        Number, maxium acceptable step between two records\n                   of the accumulator value (used to discard erroneous\n                   readings), default equal to 1/10 rollover value\n  \n Virtual point (delta) needs to reference the source point\n (accumulator) as a pointRef.\n  \n Arguments:\n *** Typical arguments for hisFunc\n*/\n\n(rec, dates) => do\n  // Prepare chain of source points\n  // 0 delta <- 1 Ene acc <- 2 Vol acc <- 3 Raw acc\n  // 0 delta <- 1 Ene acc <- 2 Vol acc\n  // 0 delta <- 1 Vol acc\n  // 0 delta <- 1 Any acc\n  if (not(rec.has(\"pointRef\"))) return null\n  \n  combEnergy: readById(rec->equipRef)[\"combustionEnergy\"]\n  combVolume: readById(rec->equipRef)[\"combustionVolume\"]\n  if (combEnergy != null and combVolume != null)\n    combHeat: (combEnergy / combVolume).as(1)\n  else\n    combHeat: 1\n  \n  pt1: readById(rec->pointRef)\n  if (not(pt1.has(\"pointRef\"))) do\n    // Source point is energy accumulator for gas meter\n    // or volume accumulator for water meter, or other\n    ptS: pt1\n    ptMult: 1\n  end else do\n    pt2: readById(pt1->pointRef)\n    if (not(pt2.has(\"pointRef\"))) do\n      // Source is volume accumulator\n      ptS: pt2\n      ptMult: combHeat\n    end else do\n      // Source is raw accumulator\n      pt3: readById(pt2->pointRef)\n      ptS: pt3\n      m: if (not(ptS.has(\"multiplierNeeded\"))) 1\n         else if (isNumber(ptS[\"multiplierNeeded\"])) ptS[\"multiplierNeeded\"]\n         else ptS[\"multiplierNeeded\"].ioReadZinc()\n                  .sortr((a,b) => a->start <=> b->start)\n                  .first->mult\n      ptMult: combHeat * m\n    end\n  end\n  \n  // Cleanup\n  if (ptMult == null) ptMult= 1\n  \n  // Find rollover and maxAccStep if present\n  if (ptS.has(\"rollover\"))\n    rollover: ptS->rollover * ptMult\n  else rollover: null  \n  \n  if (ptS.has(\"maxAccStep\"))\n    maxStep: ptS->maxAccStep\n  else maxStep: rollover / 10\n  \n  // Multiply rollover and maxAccStep as needed\n  rollover= rollover * ptMult\n  maxStep= maxStep * ptMult\n\n  // Check for presence of optional tags\n  if (readById(rec->pointRef).has(\"multiplierNeeded\"))\n    mult: rec->pointRef->multiplierNeeded\n  else mult: 1\n  \n  // Output unit \n  unit: rec->unit\n  \n  // Initialize previous value tracker\n  prevVal: null\n\n  // Read accumulator history and calculate deltas\n  out: rec->pointRef  // Accumulator point\n    .hisRead(dates, {limit: null})\n    .map row => do\n      dict: {ts: row->ts, v0: null}\n      \n      // All rows that are not first row\n      if (prevVal != null and row[\"v0\"] != null) do\n        // Calculate delta\n        deltaVal: row->v0 - prevVal\n        \n        // If delta is positive and less than maxStep, yield result\n        if (deltaVal >= 0)\n          if (maxStep == null)\n            dict= {ts: row->ts, v0: (deltaVal*mult).as(unit)}\n          else if (deltaVal <= maxStep)\n            dict= {ts: row->ts, v0: (deltaVal*mult).as(unit)}\n        \n        // If delta is negative, allow rollover\n        if (deltaVal < 0 and rollover != null) do         \n          // Calculate and test rollover delta\n          deltaRoll: row->v0 + rollover - prevVal\n          if (deltaRoll <= maxStep)\n            dict= {ts: row->ts, v0: (deltaRoll*mult).as(unit)}\n        end\n      end\n      \n      // Update values\n      prevVal = row->v0\n      return dict\n    end\n  \n  return out.findAll(row => row[\"v0\"] != null)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toAhuOutTemp",,,"(ahu, checked:true) => do\n  // first try direct\n  direct: read(outside and temp and (sensor or in) and equipRef == ahu->id, false)\n  if (direct != null) return direct\n\n  // fallback to weather\n  w: toWeather(ahu, checked)\n  if (w == null) return null\n  read(temp and weatherRef == w->id, checked)\nend\n",,
,[],,,,M,,,,,,"tmpMap91RoomE",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create terminal units\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b91/zones_and_exhaust.csv`)\n  \n  siteDis: \"91\"\n  siteId: read(site and dis==siteDis)->id\n  \n  // Cycle through each row of CSV file\n  file.each row => do\n    // Prepare location\n    floorDis: row[\"floor\"]\n    locationDis: \"B91 Floor \" + floorDis    \n    location: read(location and siteRef==siteId and\n                   dis==locationDis, false) \n                   \n    // Create location if it doesn't exist\n    if (location==null) do\n      locDict: {\n        dis: locationDis,\n        location,\n        siteRef: siteId,\n      }\n      \n      locationId: commit(diff(null, locDict, {add}))->id\n    end else locationId: location->id\n    \n    // If the equipment serves multiple rooms, create HVAC zone\n    zones: file.findAll(r => r->evav==row->evav)\n    mult: if (zones.size > 1) true else false\n    \n    if (mult) do\n      // Prepare HVAC zone\n      hvacZoneDis: \"Rm \"+zones.colToList(\"room\").concat(\", \")\n      hvacZone: read(zone and locationRef==locationId and\n                     navName==hvacZoneDis, false)\n      // Create zone if it doesn't exist\n      if (hvacZone==null) do\n        hvacZoneDict: {\n          disMacro: \"\\\$locationRef \\\$navName\",\n          equip,\n          locationRef: locationId,\n          navName: hvacZoneDis,\n          siteRef: siteId,\n          zone,\n        }\n      \n        hvacZoneId: commit(diff(null, hvacZoneDict, {add}))->id\n      end else hvacZoneId: hvacZone->id\n    end\n    \n    // Prepare zone\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    zone: read(zone and locationRef==locationId and\n               navName==roomDis, false)\n    \n    // Create zone if it doesn't exist\n    if (zone==null) do\n      zoneDict: {\n        disMacro: \"\\\$locationRef \\\$navName\",\n        equip,\n        locationRef: locationId,\n        navName: roomDis,\n        equipRef: if(mult) hvacZoneId else null,\n        siteRef: siteId,\n        zone,\n      }\n      \n      zoneId: commit(diff(null, zoneDict, {add}))->id\n    end else zoneId: zone->id\n    \n    // Prepare exhaust equip\n    eqDis: reGroups(\"^91-(.{2,3}-\\\\d\\\\d\\\\d)\",row[\"evav\"])[1]\n    // Add \"E\" to \"VAV\", all exhaust VAVs in this file\n    if (eqDis[0..2]==\"VAV\") eqDis= \"E\"+eqDis\n\n    eq: read(locationRef==locationId and\n             equip and navName==eqDis, false)\n    \n    // Create equip if it doesn't exist\n    if (eq==null) do\n      eqDict: {\n        navName: eqDis,\n        disMacro: \"\\\$equipRef \\\$navName\",\n        exhaust: if(eqDis[1..3]==\"VAV\") marker() else null,\n        terminalUnit: if(eqDis[1..3]==\"VAV\") marker() else null,\n        fumeHood: if(eqDis[0..1]==\"FH\") marker() else null,\n        equip,\n        locationRef: locationId,\n        siteRef: siteId,\n        equipRef: if (mult) hvacZoneId else zoneId,\n        tmp: today(),\n      }\n\n      eqId: commit(diff(null, eqDict, {add}))->id\n    end else eqId: eq->id\n    \n    // Prepare connector\n    connUri: row[\"vavBACnet\"]\n    connDis: if (row.has(\"address\")) eqDis + \" - Device \" + row[\"deviceInstance\"]\n             else \"Router \" + row[\"deviceInstance\"]\n    if (connUri!=null and connUri!=\"\") do\n      connUri= parseUri(connUri)\n      conn: read(conn and uri==connUri, false)\n      \n      // Create conn if it doesn't exist\n      if (conn==null) do\n        connDict: {\n          bacnetConn,\n          conn,\n          dis: locationDis + \" - \" + connDis,\n          siteRef: siteId,\n          uri: connUri,\n          tmp: today(),\n        }\n\n        connId: commit(diff(null, connDict, {add}))->id\n      end else connId: conn->id\n      \n      // Add tags on equip\n      eq= readById(eqId)\n      commit(diff(eq, {connRef: connId,\n                       connInstance: row[\"objectInstance\"],\n                       controls: row[\"controlProgram\"]}))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB06ExpHallZone19TempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readAll((id==@p:lbnl:r:2438f79e-9a92fe2b or\n           id==@p:lbnl:r:234ab34b-d8ec63cd or\n           id==@p:lbnl:r:234ab367-8d3b233b or\n           id==@p:lbnl:r:234ab469-2ea8bf71 or\n           id==@p:lbnl:r:234ab47d-8b0cfbf6 or\n           id==@p:lbnl:r:234ab48e-8e6a8fd9 or\n           id==@p:lbnl:r:234ab4a6-1e5d26c0\n         ) or (\n           equipRef==@p:lbnl:r:234a68ce-4cb71a94 and (\n             valve or temp or (outside and air and damper)\n           )\n         ))\n  .hisRead(span, {limit:limit})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n    \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viFumeHoodSashStacked","anFumeHoodSash"],,,,M,,,,,,"viFumeHoodSashScore",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all fume hoods, calculate\n  their sash height using the function anFumeHoodSash and calculate\n  a 0 - 100 score for the entire period\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastMonth()) => do\n  loc: readById(locRef)\n  \n  grid: {}.toGrid()\n  \n  dates.eachDay day => do\n    bins: viFumeHoodSashStacked(locRef, day)\n    if (isEmpty(bins)) return null\n    \n    // Calculate scores, add date\n    bins= bins.addCol(\"score\", row => do\n    totalTime: row->binClosed + row->bin1 + row->bin2 + row->bin3\n               + row->binR\n    weightedAvg: 1 / totalTime * (\n                     row->binClosed * 1 +\n                     row->bin1 * 0.75 +\n                     row->bin2 * 0.3 +\n                     row->bin3 * 0 +\n                     row->binR * 1)\n    if (row->binR / totalTime > 0.8) return na()\n    return min(100,max(0,\n             (100 * (0.1 + 0.9 * weightedAvg).as(1)).round()\n           ))\n    end)\n    \n    bins= bins.addCol(\"day\", row => return day)\n              .keepCols([\"day\",\"dis\",\"score\"])\n              .reorderCols([\"day\",\"dis\",\"score\"])\n              .addColMeta(\"score\", {chartMin: 0, chartMax: 100})\n    \n    if (isEmpty(grid)) grid= bins\n    else grid= grid.addRows(bins)\n  end\n  \n  return grid.addMeta({view: \"chart\", chartType: \"heatMap\",\n                       colors: \"#ff0000, #ff4d00, #ff9900, #ffff00, #8fe31c, #33cc33\",\n                       title: \"B\"+ loc.dis()+ \" daily fume hood scores, \"\n                              + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n                              + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["findRPRFieldValue"],,,,M,,,,,,"fandocRoomPressureReport",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(roomPressureReportRef) => do\n  rpr: readById(roomPressureReportRef)\n  \n  doc: rpr->siteRef->dis + \" \"+ rpr->zoneRef->navName + \", \" + findRPRFieldValue(rpr, \"date\") + \"\\n-----\\n\"\n  \n  //Location\n  doc=doc+\"Lab Number and/or Location: **Building \"+rpr->siteRef->dis+ \"**\\n\\n Room **: \" + rpr->zoneRef->navName + \"**\\n\\n\"\n  \n  //Date\n  doc=doc+\"Date: **\" + \n      findRPRFieldValue(rpr, \"date\", \"Room Pressure Report date is unknown.\") + \"**\\n\\n\"\n      \n  doc=doc+  \"Below is a final configuration of the laboratory control system. \\n\\n\"\n            + \"---------- \\n\\n\"\n  \n  //Setpoints\n  \n  sp_doc: \"SETPOINTS \\n*****\\n\" +\n          \"*Setpoint: *\" + findRPRFieldValue(rpr, \"setpoint\") + \"\\n\\n\" +\n          \"*Rem Setpoint: *\" + findRPRFieldValue(rpr, \"remSetpoint\") + \"\\n\\n\" +\n          \"*Vent Min Set: *\" + findRPRFieldValue(rpr, \"ventMinSet\") + \"\\n\\n\" +\n          \"*Cooling Flow: *\" + findRPRFieldValue(rpr, \"coolingFlow\") + \"\\n\\n\" +\n          \"*Unoccupy Set: *\" + findRPRFieldValue(rpr, \"unoccupySet\") + \"\\n\\n\" +\n          \"*Max Supply Set: *\" + findRPRFieldValue(rpr, \"maxSupSet\") + \"\\n\\n\" +\n          \"*Min Exhaust Set: *\" + findRPRFieldValue(rpr, \"minExhSet\") + \"\\n\\n\" +\n          \"*Min Offset: *\" + findRPRFieldValue(rpr, \"minOffset\") + \"\\n\\n\" +\n          \"*Max Offset: *\" + findRPRFieldValue(rpr, \"maxOffset\") + \"\\n\\n\" +\n          \"*Temp Setpoint: *\" + findRPRFieldValue(rpr, \"tempSetpoint\") + \"\\n\\n\" +\n          \"*Unoccupied Temp: *\" + findRPRFieldValue(rpr, \"unocTemp\") + \"\\n\\n\" +\n          \"---------- \\n\\n \"\n  \n  //Alarms\n  al_doc: \"ALARMS \\n****\\n\" +\n          \"*Low Alarm: *\" + findRPRFieldValue(rpr, \"lowAlarm\") + \"\\n\\n\" +\n          \"*High Alarm: *\" + findRPRFieldValue(rpr, \"highAlarm\") + \"\\n\\n\" +\n          \"*Rem Low Alarm: *\" + findRPRFieldValue(rpr, \"remLowAlm\") + \"\\n\\n\" +\n          \"*Rem High Alarm: *\" + findRPRFieldValue(rpr, \"remHighAlm \") + \"\\n\\n\" +\n          \"*Min Sup Alarm: *\" + findRPRFieldValue(rpr, \"minSupAlm\") + \"\\n\\n\" +\n          \"*Max Exh Alarm: *\" + findRPRFieldValue(rpr, \"maxExhAlm\") + \"\\n\\n\" +\n          \"*Alarm Reset: *\" + findRPRFieldValue(rpr, \"alarmReset\") + \"\\n\\n\" +\n          \"*Audible Alarm: *\" + findRPRFieldValue(rpr, \"audibleAlm\") + \"\\n\\n\" +\n          \"*Alarm Delay: *\" + findRPRFieldValue(rpr, \"alarmDelay\") + \"\\n\\n\" +\n          \"*Mute Timeout: *\" + findRPRFieldValue(rpr, \"muteTimeout\") + \"\\n\\n\" +\n          \"*Alarm Relay: *\" + findRPRFieldValue(rpr, \"alarmRelay\") + \"\\n\\n\" +\n          \"---------- \\n\\n \"\n  \n  //Control\n  cont_doc: \"CONTROL \\n***\\n\" +\n            \"*Speed: *\" + findRPRFieldValue(rpr, \"speed\") + \" bars \\n\\n\" +\n            \"*Sensitivity: *\" + findRPRFieldValue(rpr, \"sensitivity\") + \" bars \\n\\n\" +\n            \"*Control Signal: *\" + findRPRFieldValue(rpr, \"controlSignal\") + \"\\n\\n\" +\n            \"*Sup Cont Dir: *\" + findRPRFieldValue(rpr, \"supContDir\") + \"\\n\\n\" +\n            \"*Exh Cont Dir: *\" + findRPRFieldValue(rpr, \"exhContDir\") + \"\\n\\n\" +\n            \"*Temp Dir: *\" + findRPRFieldValue(rpr, \"tempDir\") + \"\\n\\n\" +\n            \"*Reheat Sign: *\" + findRPRFieldValue(rpr, \"reheatSig\") + \"\\n\\n\" +\n            \"*Kc: *\" + findRPRFieldValue(rpr, \"kc\") + \"\\n\\n\" +\n            \"*Ti: *\" + findRPRFieldValue(rpr, \"ti\") + \"\\n\\n\" +\n            \"*Kc Offset: *\" + findRPRFieldValue(rpr, \"kcOffset\") + \"\\n\\n\" +\n            \"*Temp DB: *\" + findRPRFieldValue(rpr, \"tempDB\") + \"\\n\\n\" +\n            \"*Temp TR: *\" + findRPRFieldValue(rpr, \"tempTR\") + \"\\n\\n\" +\n            \"*Temp TI: *\" + findRPRFieldValue(rpr, \"tempTI\") + \"\\n\\n\" +\n            \"---------- \\n\\n \"\n  \n  //Interface\n  int_doc: \"INTERFACE \\n***\\n\" +\n           \"*Net Protocol: *\" + findRPRFieldValue(rpr, \"netProtocol\") + \"\\n\\n\" +\n           \"*Net Address: *\" + findRPRFieldValue(rpr, \"netAddress\") + \"\\n\\n\" +\n           \"*Output Range: *\" + findRPRFieldValue(rpr, \"outputRange\") + \"\\n\\n\" +\n           \"*Output Sig: *\" + findRPRFieldValue(rpr, \"outputSig\") + \"\\n\\n\" +\n           \"*Max Flow Out: *\" + findRPRFieldValue(rpr, \"maxFlowOut\") + \"\\n\\n\" +\n           \"---------- \\n\\n \"\n\n  //Configure\n  conf_doc:  \"CONFIGURE \\n***\\n\" +\n             \"*Units: *\" + findRPRFieldValue(rpr, \"unitsConfig\") + \"\\n\\n\" +\n             \"*Exh Config: *\" + findRPRFieldValue(rpr, \"exhConfig\") + \"\\n\\n\" +\n             \"*Access Codes: *\" + findRPRFieldValue(rpr, \"accessCodes\") + \"\\n\\n\" +\n             \"*Mac Address: *\" + findRPRFieldValue(rpr, \"macAddress\") + \"\\n\\n\" +\n             \"---------- \\n\\n \"\n  \n  //System Flow\n  sys_doc: \"SYSTEM FLOW \\n***\\n\" +\n           \"*Total Sup Flow: *\" + findRPRFieldValue(rpr, \"totalSupFlow\") + \" bars \\n\\n\" +\n           \"*Total Exh Flow: *\" + findRPRFieldValue(rpr, \"totalExhFlow\") + \"\\n\\n\" +\n           \"*Offset Value: *\" + findRPRFieldValue(rpr, \"offsetValue\") + \"\\n\\n\" +\n           \"*Sup Setpoint: *\" + findRPRFieldValue(rpr, \"supSetpoint\") + \"\\n\\n\" +\n           \"*Exh Setpoint: *\" + findRPRFieldValue(rpr, \"exhSetpoint\") + \"\\n\\n\" +\n           \"---------- \\n\\n \"  \n  \n  //Input Check\n  inp_doc: \"INPUT CHECK \\n****\\n\" +\n           \"*SUP 1: *\" + findRPRFieldValue(rpr, \"sup1\") + \"\\n\\n\" +\n           \"*SUP 2: *\" + findRPRFieldValue(rpr, \"sup2\") + \"\\n\\n\" +\n           \"*SUP 3: *\" + findRPRFieldValue(rpr, \"sup3\") + \"\\n\\n\" +\n           \"*SUP 4: *\" + findRPRFieldValue(rpr, \"sup4\") + \"\\n\\n\" +\n           \"*EXH 1: *\" + findRPRFieldValue(rpr, \"exh1\") + \"\\n\\n\" +\n           \"*EXH 2: *\" + findRPRFieldValue(rpr, \"exh2\") + \"\\n\\n\" +\n           \"*HOOD 1: *\" + findRPRFieldValue(rpr, \"hood1\") + \"\\n\\n\" +\n           \"*HOOD 2: *\" + findRPRFieldValue(rpr, \"hood2\") + \"\\n\\n\" +\n           \"*HOOD 3: *\" + findRPRFieldValue(rpr, \"hood3\") + \"\\n\\n\" +\n           \"*HOOD 4: *\" + findRPRFieldValue(rpr, \"hood4\") + \"\\n\\n\" +\n           \"*HOOD 5: *\" + findRPRFieldValue(rpr, \"hood5\") + \"\\n\\n\" +\n           \"*HOOD 6: *\" + findRPRFieldValue(rpr, \"hood6\") + \"\\n\\n\" +\n           \"*HOOD 7: *\" + findRPRFieldValue(rpr, \"hood7\") + \"\\n\\n\" +\n           \"---------- \\n\\n \"\n  \n  //Flow Check\n  flo_doc: \"FLOW CHECK \\n****\\n\" +\n           \"*SP1 Flow In: *\" + findRPRFieldValue(rpr, \"sp1FlowIn\") + \"\\n\\n\" +\n           \"*SP2 Flow In: *\" + findRPRFieldValue(rpr, \"sp2FlowIn\") + \"\\n\\n\" +\n           \"*SP3 Flow In: *\" + findRPRFieldValue(rpr, \"sp3FlowIn\") + \"\\n\\n\" +\n           \"*SP4 Flow In: *\" + findRPRFieldValue(rpr, \"sp4FlowIn\") + \"\\n\\n\" +\n           \"*EX1 Flow In: *\" + findRPRFieldValue(rpr, \"ex1FlowIn\") + \"\\n\\n\" +\n           \"*EX2 Flow In: *\" + findRPRFieldValue(rpr, \"ex2FlowIn\") + \"\\n\\n\" +\n           \"*HD1 Flow In: *\" + findRPRFieldValue(rpr, \"hd1FlowIn\") + \"\\n\\n\" +\n           \"*HD2 Flow In: *\" + findRPRFieldValue(rpr, \"hd2FlowIn\") + \"\\n\\n\" +\n           \"*HD3 Flow In: *\" + findRPRFieldValue(rpr, \"hd3FlowIn\") + \"\\n\\n\" +\n           \"*HD4 Flow In: *\" + findRPRFieldValue(rpr, \"hd4FlowIn\") + \"\\n\\n\" +\n           \"*HD5 Flow In: *\" + findRPRFieldValue(rpr, \"hd5FlowIn\") + \"\\n\\n\" +\n           \"*HD6 Flow In: *\" + findRPRFieldValue(rpr, \"hd6FlowIn\") + \"\\n\\n\" +\n           \"*HD7 Flow In: *\" + findRPRFieldValue(rpr, \"hd7FlowIn\") + \"\\n\\n\" +\n           \"---------- \\n\\n \"\n  \n  //Supply Flow\n  sup_doc: \"SUPPLY FLOW \\n****\\n\" +\n           \"*SP1 Dct Area: *\" + findRPRFieldValue(rpr, \"sp1DctArea\") + \"\\n\\n\" +\n           \"*SP2 Dct Area: *\" + findRPRFieldValue(rpr, \"sp2DctArea\") + \"\\n\\n\" +\n           \"*SP3 Dct Area: *\" + findRPRFieldValue(rpr, \"sp3DctArea\") + \"\\n\\n\" +\n           \"*SP4 Dct Area: *\" + findRPRFieldValue(rpr, \"sp4DctArea\") + \"\\n\\n\" +\n           \"*Flow Sta Type: *\" + findRPRFieldValue(rpr, \"flowStaType_supflow\") + \"\\n\\n\" +\n           \"*Top Velocity: *\" + findRPRFieldValue(rpr, \"topVelocity_supflow\") + \"\\n\\n\" +\n           \"*SP Low Setp: *\" + findRPRFieldValue(rpr, \"spLowSetp\") + \"\\n\\n\" +\n           \"*SP High Setp: *\" + findRPRFieldValue(rpr, \"spHighSetp\") + \"\\n\\n\" +\n           \"*SP1 Low Cal: *\" + findRPRFieldValue(rpr, \"sp1LowCal\") + \"\\n\\n\" +\n           \"*SP1 High Cal: *\" + findRPRFieldValue(rpr, \"sp1HighCal\") + \"\\n\\n\" +\n           \"*SP2 Low Cal *\" + findRPRFieldValue(rpr, \"sp2LowCal\") + \"\\n\\n\" +\n           \"*SP2 High Cal *\" + findRPRFieldValue(rpr, \"sp2HighCal\") + \"\\n\\n\" +\n           \"*SP3 Low Cal: *\" + findRPRFieldValue(rpr, \"sp3LowCal\") + \"\\n\\n\" +\n           \"*SP3 High Cal: *\" + findRPRFieldValue(rpr, \"sp3HighCal\") + \"\\n\\n\" +\n           \"*SP4 Low Cal: *\" + findRPRFieldValue(rpr, \"sp4LowCal\") + \"\\n\\n\" +\n           \"*SP4 High Cal: *\" + findRPRFieldValue(rpr, \"sp4HighCal\") + \"\\n\\n\" +\n           \"---------- \\n\\n \"\n           \n  //Exhaust Flow\n   exh_doc: \"EXHAUST FLOW \\n****\\n\" +\n            \"*EX1 Dct Area: *\" + findRPRFieldValue(rpr, \"ex1DctArea\") + \"\\n\\n\" +\n            \"*EX2 Dct Area: *\" + findRPRFieldValue(rpr, \"ex2DctArea\") + \"\\n\\n\" +\n            \"*Flo Sta Type: *\" + findRPRFieldValue(rpr, \"floStaType_exhflow\") + \"\\n\\n\" +\n            \"*Top Velocity: *\" + findRPRFieldValue(rpr, \"topVelocity_exhflow\") + \"\\n\\n\" +\n            \"*EX Low Setp: *\" + findRPRFieldValue(rpr, \"exLowSetp\") + \"\\n\\n\" +\n            \"*EX High Setp *\" + findRPRFieldValue(rpr, \"exHighSetp\") + \"\\n\\n\" +\n            \"*EX1 Low Cal: *\" + findRPRFieldValue(rpr, \"ex1LowCal\") + \"\\n\\n\" +\n            \"*EX1 High Cal: *\" + findRPRFieldValue(rpr, \"ex1HighCal\") + \"\\n\\n\" +\n            \"*EX2 Low Cal: *\" + findRPRFieldValue(rpr, \"ex2LowCal\") + \"\\n\\n\" +\n            \"*EX2 High Cal: *\" + findRPRFieldValue(rpr, \"ex2HighCal\") + \"\\n\\n\" +\n            \"---------- \\n\\n \"\n\n  //Hood Flow\n  hdf_doc: \"HOOD FLOW \\n****\\n\" +\n            \"*HD1 Dct Area: *\" + findRPRFieldValue(rpr, \"hd1DctArea\") + \"\\n\\n\" +\n            \"*HD2 Dct Area: *\" + findRPRFieldValue(rpr, \"hd2DctArea\") + \"\\n\\n\" +\n            \"*HD3 Dct Area: *\" + findRPRFieldValue(rpr, \"hd3DctArea\") + \"\\n\\n\" +\n            \"*HD4 Dct Area: *\" + findRPRFieldValue(rpr, \"hd4DctArea\") + \"\\n\\n\" +\n            \"*HD5 Dct Area: *\" + findRPRFieldValue(rpr, \"hd5DctArea\") + \"\\n\\n\" +\n            \"*HD6 Dct Area: *\" + findRPRFieldValue(rpr, \"hd6DctArea\") + \"\\n\\n\" +\n            \"*HD7 Dct Area: *\" + findRPRFieldValue(rpr, \"hd7DctArea\") + \"\\n\\n\" +\n            \"*Flo Sta Type: *\" + findRPRFieldValue(rpr, \"flowStaType_hoodflow\") + \"\\n\\n\" +\n            \"*Top Velocity: *\" + findRPRFieldValue(rpr, \"topVelocity_hoodflow\") + \"\\n\\n\" +\n            \"---------- \\n\\n \"\n  \n  //Hood Flow\n  hdc_doc: \"HOOD CAL \\n****\\n\" +\n            \"*HD1 Low Cal: *\" + findRPRFieldValue(rpr, \"hd1LowCal\") + \"\\n\\n\" +\n            \"*HD1 High Cal: *\" + findRPRFieldValue(rpr, \"hd1HighCal\") + \"\\n\\n\" +\n            \"*HD2 Low Cal: *\" + findRPRFieldValue(rpr, \"hd2LowCal\") + \"\\n\\n\" +\n            \"*HD2 High Cal: *\" + findRPRFieldValue(rpr, \"hd2HighCal\") + \"\\n\\n\" +\n            \"*HD3 Low Cal: *\" + findRPRFieldValue(rpr, \"hd3LowCal\") + \"\\n\\n\" +\n            \"*HD3 High Cal: *\" + findRPRFieldValue(rpr, \"hd3HighCal\") + \"\\n\\n\" +\n            \"*HD4 Low Cal: *\" + findRPRFieldValue(rpr, \"hd4LowCal\") + \"\\n\\n\" +\n            \"*HD4 High Cal: *\" + findRPRFieldValue(rpr, \"hd4HighCal\") + \"\\n\\n\" +\n            \"*HD5 Low Cal: *\" + findRPRFieldValue(rpr, \"hd5LowCal\") + \"\\n\\n\" +\n            \"*HD5 High Cal: *\" + findRPRFieldValue(rpr, \"hd5HighCal\") + \"\\n\\n\" +\n            \"*HD6 Low Cal: *\" + findRPRFieldValue(rpr, \"hd6LowCal\") + \"\\n\\n\" +\n            \"*HD6 High Cal: *\" + findRPRFieldValue(rpr, \"hd6HighCal\") + \"\\n\\n\" +\n            \"*HD7 Low Cal: *\" + findRPRFieldValue(rpr, \"hd7LowCal\") + \"\\n\\n\" +\n            \"*HD7 High Cal: *\" + findRPRFieldValue(rpr, \"hd7HighCal\") + \"\\n\\n\" +\n            \"---------- \\n\\n \"\n            \n  //Sequence of Operation\n  soo_doc: \"SEQUENCE OF OPERATION \\n****\\n\" +\n            findRPRFieldValue(rpr, \"sequenceOfOperation\") + \"\\n\\n\" +\n            \"---------- \\n\\n \"\n\n  //Other Information\n  oth_doc: \"OTHER INFORMATION \\n****\\n\" +\n            findRPRFieldValue(rpr, \"otherInformation\") + \"\\n\\n\" +\n            \"---------- \\n\\n \"\n            \n  doc = doc + sp_doc + al_doc + cont_doc + int_doc + conf_doc +\n        sys_doc + inp_doc + flo_doc + sup_doc + exh_doc + hdf_doc +\n        hdc_doc + soo_doc + oth_doc\n  return doc\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"zz_old_anDailyGasReg",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// Perform regression vs HDD of daily natural gas usage,\n// return dictionay with:\n//   reg: regression results\n//   graph: chart grid for corresponding data\n\n(meterUsageRef, dates, ddRef, titlePrefix:\"\") => do\n  // Read usage from meter energy point\n  usage: readById(meterUsageRef)\n        .hisRead(dates)\n\n  // Read HDD from LBL weahter station data\n  hdd: read(weatherPoint and main and air and temp and sensor)\n       .degreeDays(dates, ddRef)\n       .keepCols([\"ts\",\"heat\"])\n\n  // Apply day type factoring to usage, for graphing purposes\n  usage_factor: usage.map row => {\n    ts: row->ts,\n    usageWeekday: if(isWeekday(row->ts)) row->v0 else null,\n    usageWeekend: if(isWeekday(row->ts)) null else row->v0\n  }\n  \n  // Join regression data and filter out missing gas data points\n  dataset: hisJoin([hdd.hisRollup(sum, 1day), \n                    usage.hisRollup(sum, 1day)])\n             .findAll(row => row.has(\"v0\"))  // Filter out dates with missing gas data\n   \n  // Apply day type factoring  to HDD, for regression purposes\n  regMatrix: dataset.map row => {\n    ts: row->ts,\n    hddWeekday: if(isWeekday(row->ts)) row->heat else 0,\n    hddWeekend: if(isWeekday(row->ts)) 0 else row->heat,\n    usage: row->v0\n  }\n       \n  // Isolate dependent and independent variables for regression\n  y: regMatrix.keepCols([\"usage\"])\n  x: regMatrix.keepCols([\"hddWeekday\",\"hddWeekend\"])\n\n  // Perform regression\n  reg: matrixFitLinearRegression(y, x)\n  intercept: reg.meta[\"bias\"]\n  slopeWeekday: reg[0][\"b\"]\n  slopeWeekend: reg[1][\"b\"]\n\n  // Calculate fitted values\n  slope: null\n  dataset = dataset.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->heat).as(usage.first[\"v0\"])\n    end)\n  \n  // Calculate statistics\n  measuredTotal: y.foldCol(\"usage\", sum)\n  n: reg.meta[\"rowCount\"]\n  measuredAvg: measuredTotal / n\n  squareError: dataset.addCol(\"se\", row => pow(row->fittedUsage - row->v0,2)).foldCol(\"se\", sum)\n  p: 2\n  mse: squareError / (n-p)\n  rmse: sqrt(mse)\n  cvrmse: rmse / measuredAvg\n  \n  // Build dictionary of results\n  regRes: {\n    intercept: intercept,\n    slopeWeekday: slopeWeekday,\n    slopeWeekend: slopeWeekend,\n    rSquared: reg.meta[\"r2\"],\n    n: n,\n    p: p,\n    measuredAvg: measuredAvg,\n    mse: mse,\n    rmse: rmse,\n    cvrmse: (cvrmse*100).as(1%)\n  }\n\n  // Create graph of data (regression not yet shown)\n  graph: hisJoin([hdd, usage_factor])\n    .keepCols([\"heat\",\"usageWeekday\",\"usageWeekend\"])\n    .sort(\"heat\")\n    .addCol(\"regressionWeekday\", row => if(row.has(\"heat\")) (intercept+regRes[\"slopeWeekday\"]*row->heat).as(usage.first[\"v0\"]) else null)\n    .addCol(\"regressionWeekend\", row => if(row.has(\"heat\")) (intercept+regRes[\"slopeWeekend\"]*row->heat).as(usage.first[\"v0\"]) else null)\n    .addColMeta(\"usageWeekday\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#1D80F1\"})\n    .addColMeta(\"usageWeekend\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#07203C\"})\n    .addColMeta(\"regressionWeekday\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#C7DFFB\"})\n    .addColMeta(\"regressionWeekend\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#C1C7CE\"})\n    .reorderCols([\"heat\",\"regressionWeekend\",\"regressionWeekday\",\"usageWeekend\",\"usageWeekday\"])\n    .addMeta({title:titlePrefix+\"Daily gas usage vs HDD grouped by day type\"})\n    \n  // Return dict of regression results and graph\n  return {reg:regRes, graph:graph, dataset:dataset}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"humiditySpTooLow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ahu, dates, minTime: 30min, setPoint: 60%) => do\n\n  //collect dehumid sp and value for selected dates\n  dehumSp: read(dehumidifier and sp and equipRef == ahu->id, false)\n  if (dehumSp == null) return null\n  else\n  \n  dehumSp = dehumSp.hisRead(dates).hisFindPeriods(v=> v<setPoint)\n  \n  //Final spark is when heating is on, cooling is on, and dehumidifying is not needed\n  sparkFinal: dehumSp.findAll(r => r->v0 >= minTime)\n\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptAccumulatorMultiply",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n////////////////////////////////////////////////////////////////////\n// This function calculates history for a virtual volume accumulator\n//    point using a raw accumualtor point history and a multiplier\n//    defined under tag multiplierNeeded of the base accumulator\n//    Volume must be in ft³, because unit is force-set\n// kW Engineering // RGV // Last Update: 2018-09-20\n\n(rec, dates, opts, yield) => do\n  orig: read(accumulator and sensor and not virtual and equipRef==rec->equipRef)\n  \n  if (not(orig.has(\"multiplierNeeded\"))) return null\n  if (isNumber(orig->multiplierNeeded))\n      multTable: {mult: orig->multiplierNeeded,\n                  start: dateTime(2000-01-01, 00:00),\n                  end: null}.toGrid()\n  else multTable: orig->multiplierNeeded.ioReadZinc()\n                                        .sort((a,b) => a->start <=> b->start)\n\n  orig.hisRead(dates, {limit: null})\n      .each(sample => do\n          multTable.each(row => do\n              if (sample->ts >= row->start\n                  and (row[\"end\"] == null\n                       or sample->ts < row[\"end\"]))\n                  yield(sample->ts,\n                        (sample->v0 * row->mult).as(rec->unit)\n                       )\n          end)\n      end)\n      //yield(row->ts, (row->v0*multiplier).as(rec->unit)))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,M
,[],,"Compared Deviation from Trimmed Mean",,M,,,,,,"hisDeviationCompare_v4",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// This his a hisSrc function, which displays:\n//   - history for selected point over selected period of time\n//   - low and high limits for the history based on trimmed mean and tolerance\n//   - percentage of point values that are out of tolerance\n//   - same thing for the history of the point \"\$duration\" earlier, for comparison\n// duration: time shift for comparison\n// number:   tolerance for deviation around trimmed mean\n//\n// Hardcoded: percentile thresholds for trimmed mean\n// Warning: percentage of out of tolerance counts points, and will be inaccurate if\n//          interval time varies.\n// Known issue: when loaded in Historian and changing datespan, the colors and groups\n//   will default to blue and (1). Work-around: reset to AUTO manually.\n\n(point, currentSpan, oldSpan, deviation) => do\n  // Allowed deviation from trimmed mean, remove unit since this will be used in additions\n  //   and subtractions. If a \"delta\" appeared in resulting unit, secondary axis would be used\n  tolerance: deviation.as(1)\n\n  // Low percentile threshold for trimmed mean, suggest keeping under 30%\n  // High threshold will be 1 minus low percentile threshold (symmetrical)\n  // Hardcoded due to limitation of inputs of hisSrc func (expr macro)\n  percentile:20\n\n  // Read data from current historian display, get meta info needed for proper display\n  r_current: point.hisRead(currentSpan)\n  his_meta: r_current.meta\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_c_lo: round(r_current.size*percentile/100,0)\n  i_c_hi: round(r_current.size*(1.0 - percentile/100),0)\n  current_ref: r_current.sort(\"v0\")[i_c_lo..i_c_hi].foldCol(\"v0\",avg)\n  r_current = r_current.addCol(\"v0_limit_lo\", row => (current_ref - tolerance))\n  r_current = r_current.addCol(\"v0_limit_hi\", row => (current_ref + tolerance))\n  cur_out_num: r_current.findAll(row => (row->v0 < (current_ref - tolerance)) or (row->v0 > (current_ref + tolerance))).foldCol(\"v0\",count)\n  cur_out_pct: round(cur_out_num / r_current.size * 100, 0)\n\n  // Read data from earlier, shift timestamps to current historian display, make grid\n  spanOffset: (currentSpan.start - oldSpan.start).to(1wk)\n  r: point.hisRead(oldSpan)\n  list_ts: colToList(r,\"ts\")\n  list_v1: colToList(r,\"v0\")\n  list_ts0: list_ts.map s => s + spanOffset\n  r_past: list_ts0.toGrid.map( (row,index) => {ts:row->val, v1:list_v1[index]} )\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_p_lo: round(r_past.size*percentile/100,0)\n  i_p_hi: round(r_past.size*(1.0 - percentile/100),0)\n  past_ref: r_past.sort(\"v1\")[i_p_lo..i_p_hi].foldCol(\"v1\",avg)\n  r_past = r_past.addCol(\"v1_limit_lo\", row => (past_ref - tolerance))\n  r_past = r_past.addCol(\"v1_limit_hi\", row => (past_ref + tolerance))\n  past_out_num: r_past.findAll(row => (row->v1 < (past_ref - tolerance)) or (row->v1 > (past_ref + tolerance))).foldCol(\"v1\",count)\n  past_out_pct: round(past_out_num / r_past.size * 100, 0)\n  \n  // Merge current and past grids and set meta information for proper display\n  r_past_meta: r_past.addMeta(his_meta)\n  r_joined: hisJoin([r_current, r_past_meta])\n  \n  point_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"dis\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  r_out: r_joined.addColMeta(\"v0\", {dis: point_dis+\", out of tolerance \"+cur_out_pct+\"%\", color: \"#0000cd\", chartGroup:\"1\"})\n                 .addColMeta(\"v0_limit_lo\", {dis: \"low limit\", color: \"#4dcde1\", chartGroup:\"1\"})\n                 .addColMeta(\"v0_limit_hi\", {dis: \"high limit\", color: \"#4dcde1\", chartGroup:\"1\"})\n                 .addColMeta(\"v1\", {dis: round(spanOffset)+\" earlier: \"+point_dis+\", out of tolerance \"+past_out_pct+\"%\", color: \"#228b22\", chartGroup:\"2\"})\n                 .addColMeta(\"v1_limit_lo\", {dis: \"low limit\", color: \"#98fb98\", chartGroup:\"2\"})\n                 .addColMeta(\"v1_limit_hi\", {dis: \"high limit\", color: \"#98fb98\", chartGroup:\"2\"})\n                 .addMeta({dis: \"LAGGED \"+spanOffset+\" \"+point_dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneTempDeadbands"],,,,M,,,,,,"viAhuZoneTempDeadbands",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, calculate the temperature deadbands for all\n  TUs served by that AHU (using anAhuZoneTempDeadbands) then\n  display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDb        number, cap deadband width at this number\n  rollup       duration, interval for rollup of trends\n*/\n\n(ahuRef, dates: yesterday(), maxDb: 8°F, rollup: 60min, zoneIdList:null) => do\n  dbs: anAhuZoneTempDeadbands(ahuRef, dates, maxDb, rollup, zoneIdList)\n  \n  try do\n    dbs= dbs\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n                rm: his->dis,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {unit:\"°F\",\n                           chartMin: 0°F,\n                           chartMax: maxDb})\n        .addMeta({view: \"chart\", chartType:\"heatMap\",\n                  title: \"Width of temperature deadbands, zones served by \"\n                         +readById(ahuRef).dis(),\n                  colors: \"#ff9900,#ddba33,#98fb98,#4ca44c,#004d00\"})\n  catch (ex) do\n    dbs= null\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpImportSprintVelocity",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  ioReadCsv(`io/tmp/sprintVelocitySnaps.csv`)\n  .each row => do\n    dict: {\n      sprintVelocitySnap,\n      sprintRef: read(sprint==parseNumber(row->sprint))->id,\n      date: parseDate(row[\"end\"],\"M/D/YYYY\"),\n      disMacro: \"Sprint \\\$sprintRef (\\\$date)\",\n      wuClosed: if (row.has(\"wuClosed\")) parseNumber(row->wuClosed),\n      wuResolved: if (row.has(\"wuResolved\")) parseNumber(row->wuResolved),\n      wuAbandoned: if (row.has(\"wuAbandoned\")) parseNumber(row->wuAbandoned),\n      wuPending: if (row.has(\"wuPending\")) parseNumber(row->wuPending),\n      wuInProgress: if (row.has(\"wuInProgress\")) parseNumber(row->wuInProgress),\n      wuToDo: if (row.has(\"wuToDo\")) parseNumber(row->wuToDo),\n    }\n    \n    commit(diff(null, dict, {add}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["meterMonthlyRead"],,,,M,,,,,,"meterMonthlyRead",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load Combined Energy spreadsheet from google (Combined Data tab),\n  parse the information and create corresponding monthly records.\n  \n  Arguments:\n  N/A\n*/\n\n() => do\n  // Prepare google sheet query;\n  // Spreadsheet needs to be publicly accessible\n  q_base: \"\"\"https://docs.google.com/spreadsheets/d/\"\"\"\n  q_doc: \"\"\"1-xQtM-258YRhoOHawQUFUn0pnJ_asxnmz7qaYl8tgJc\"\"\"\n  q_type: \"\"\"/gviz/tq?\"\"\"\n  q_tq: \"\"\"tq=select *\"\"\"\n  q_tqx: \"\"\"&tqx=out:csv&sheet=\"\"\" + \"\"\"Combined Data\"\"\"\n  query: q_base + q_doc + q_type + q_tq + q_tqx\n  \n  // Execute query\n  raw: ioReadCsv(``+query)\n\n  // Each row has a unique pair (sblid, timestamp)\n  skippedRow: 0\n  raw.each r => do\n    try do\n      sblid: r->sblid\n      date: r->timestamp.parseDate(\"M/D/YYYY\")\n    end catch do\n      skippedRow= skippedRow+1\n      return null\n    end\n    \n    // There can be elec and/or gas readings for each pair\n    [\"electricityUse\",\"naturalGasUse\"].each type => if (r.has(type)) do\n      meter: if (type==\"electricityUse\")\n                 read(meter and sblid==sblid and elec, false)\n               else\n                 read(meter and sblid==sblid and gas, false)\n      unit: if (type==\"electricityUse\") \"kWh\" else \"therm\"\n      consumption: r[type].parseNumber().as(unit)\n      \n      // If the meter exists in SkySpark, create or update record \n      if (meter != null) do\n        exRec: read(monthlyRead and not estimated and meterRef==meter->id and readDate==date, false)\n        dict: {\n          monthlyRead,\n          meterRef: meter->id,\n          readDate: date,\n          consumption: consumption\n        }\n        commit(diff(exRec, dict, if (exRec==null) {add} else null))\n      end  \n    end\n  end\n  \n  if (skippedRow > 0)\n    logWarn({name:\"meterMonthlyRead\"}, \"Had to skip \"+skippedRow+\" rows\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualMax",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  max value of all points which have a virtualRef equal\n  to the id of the virtual point\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap(x => if (x==null) na() else x)\n         .hisFoldCols(max)\n         .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAVEquip",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For all connectors with tags b33 and vavZn, create equip\n*/\n\n() => do\n  readAll(conn and bacnetConn and vavZn and siteRef->dis==\"Building 33\" and locationRef->dis!=\"B33 Floor 1\")\n  .each connector => do\n    commit(diff(\n      null,\n      {navName: connector->vavZn,\n       disMacro: \"\\\$locationRef \\\$navName\",\n       vav,\n       equip,\n       locationRef: connector->locationRef->id,\n       siteRef: connector->siteRef->id,\n       tmpTest20180426\n      },\n      {add}\n    ))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","ptMetricsCoolingLoopPpue"],,,,M,,,,,,"viPPUECoolScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the pPUE points for the computer cooling loop\n  and construct a scatter chart with respect to outside\n  air wetbulb temperature for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(dates: today, rollup: 15min, sysRef:null, wbRef:null) => do\n  // Default to B59 Data Center Computers if no sysRef is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id\n\n  // Default to B59 TW if no wbRef is provided\n  if(wbRef==null)\n    wbRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n  // Get the cooling loop pPUE under this computer\n  loopPPUE: toolRecursiveSearch(sysRef,\n                   \"hisFunc==\\\"ptMetricsCoolingLoopPpue\\\"\")\n\n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  // Interpolate, filter the cooling loop ppue\n  loopTrend: hisRead(loopPPUE,dates,{limit:null})\n                 .hisRollup(avg, rollup)\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"loopppue\")\n  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .hisRollup(avg, rollup)\n                  .renameCol(\"v0\",\"oaWB\")\n\n  //Add OA Wetbulb to the collection of pPUEs\n  \n  \n  metric: hisJoin([oaWetBulb, loopTrend])\n            .addColMeta(\"oaWB\",\n              {chartType: \"scatter\",\n               dis: \"OAT WB\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"loopppue\",\n              {chartType: \"scatter\",\n               dis: \"Cooling Loop pTUE\",\n               unit: \"_\", color: \"#3F51B5\",\n               chartGroup: \"all\"})\n            \n  metricScatter: metric.keepCols([\"oaWB\",\"loopppue\"])\n                       .addMeta({chartType: \"scatter\", \n                               title: \"Cooling Loop pTUE vs. Outside Air Wetbulb Temperature\"})\n  \n  return metricScatter\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap91SupConn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with terminal unit #, AHU relationship and connector info\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b91/supply_connectors.csv`)\n  \n  siteDis: \"91\"\n  siteId: read(site and dis==siteDis)->id\n  \n  // Cycle through each row of CSV file\n  file.each row => do\n    // Prepare location\n    floorDis: row[\"floor\"]\n    locationDis: \"B91 Floor \" + floorDis    \n    location: read(location and siteRef==siteId and\n                   dis==locationDis, false) \n                   \n    // Create location if it doesn't exist\n    if (location==null) do\n      locDict: {\n        dis: locationDis,\n        location,\n        siteRef: siteId,\n      }\n      \n      locationId: commit(diff(null, locDict, {add}))->id\n    end else locationId: location->id\n            \n    // Prepare supply equip\n    eqDis: reGroups(\"^91-(.{3}-\\\\d\\\\d\\\\d)\",row[\"vav\"])[1]\n    // Add \"S\" to \"VAV\", all supply VAVs in this file\n    if (eqDis[0..2]==\"VAV\") eqDis= \"S\"+eqDis\n\n    // Locate AHU\n    if (row.has(\"ahu\")) do\n      ahuNum: reGroups(\"^91-AHU-\\\\d\\\\d(\\\\d)\",row[\"ahu\"])[1]\n      ahu: read(ahu and siteRef==siteId and equip and navName==\"AHU-\"+ahuNum)\n      ahuId: ahu->id\n    end else ahuId: null\n\n    eq: read(locationRef==locationId and\n             equip and navName==eqDis, false)\n    \n    // Create equip if it doesn't exist\n    if (eq==null) do\n      eqDict: {\n        navName: eqDis,\n        disMacro: \"\\\$equipRef \\\$navName\",\n        supply: if(eqDis[1..3]==\"VAV\") marker() else null,\n        terminalUnit: if(eqDis[1..3]==\"VAV\") marker() else null,\n        fcu: if(eqDis[0..2]==\"FCU\") marker() else null,\n        equip,\n        locationRef: locationId,\n        siteRef: siteId,\n        equipRef: null,\n        tmp: today(),\n      }\n\n      eqId: commit(diff(null, eqDict, {add}))->id\n    end else eqId: eq->id\n    \n    // Prepare connector\n    connUri: row[\"vavBACnet\"]\n    connDis: if (row.has(\"address\")) eqDis + \" - Device \" + row[\"deviceInstance\"]\n             else \"Router \" + row[\"deviceInstance\"]\n    if (connUri!=null and connUri!=\"\") do\n      connUri= parseUri(connUri)\n      conn: read(conn and uri==connUri, false)\n      \n      // Create conn if it doesn't exist\n      if (conn==null) do\n        connDict: {\n          bacnetConn,\n          conn,\n          dis: locationDis + \" - \" + connDis,\n          siteRef: siteId,\n          uri: connUri,\n          tmp: today(),\n        }\n\n        connId: commit(diff(null, connDict, {add}))->id\n      end else connId: conn->id\n      \n      // Add tags on equip\n      eq= readById(eqId)\n      commit(diff(eq, {connRef: connId,\n                       connInstance: row[\"objectInstance\"],\n                       ahuRef:ahuId,\n                       controls: row[\"controlProgram\"]}))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmp67MarkLabZones",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  // Remove existing lab tags for update\n  readAll(zone and lab and siteRef->dis==\"67\")\n  .each zn => commit(diff(zn, {-lab}))\n  \n  list: ioReadCsv(`io/integration_b67/b67_lab_zones.csv`)\n  .each row => do\n    zn_navName: \"Rm \"+row->rm\n    zn: read(zone and siteRef->dis==\"67\" and navName==zn_navName)\n    commit(diff(zn, {lab}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viMeterQuality",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, and a given span (optional), return a\n  timeline of data validity.\n  \n  Arguments: \n  meterRef        Target id\n  span            Datespan (optional)\n*/\n\n(meterRef, span:null) => do\n  qualityRecs: readAll(dataQuality and meterRef==meterRef)\n  if (isEmpty(qualityRecs)) return null\n  \n  qualityRecs= qualityRecs\n  .sort((a,b) => a->startDate <=> b->startDate)\n  \n  if(span==null)\n    span= qualityRecs.first->startDate..today()\n  span= span.toDateSpan()\n\n  // Chart data quality status over time\n  validDaysList: []\n  qualityRecs.each((qualityRec,i) => do\n    if (qualityRec->dataQuality==\"Insufficient\") return null\n    \n    thisStart: qualityRec->startDate\n    thisEnd: try qualityRecs[i+1]->startDate - 1day\n             catch span.end\n               \n    if (span.start >= thisEnd) return null\n    if (span.end < thisStart) return null\n    \n    qSpanStart: if (span.start > thisStart) span.start\n                else thisStart\n    qSpanEnd: thisEnd\n    qSpan: (qSpanStart..qSpanEnd).toDateSpan()\n\n    qSpan.eachDay day =>\n      validDaysList= validDaysList.add(day)\n  end)\n  \n  if (isEmpty(validDaysList)) return null\n  \n  chart: {}.toGrid()\n  span.eachDay day => do\n    val: if (validDaysList.contains(day)) true else false\n    datetime: dateTime(day, time(0,0,0))\n    chart= chart.addRow({ts:datetime, v0:val})\n  end\n \n  chart= chart.addMeta({view:\"chart\"})\n                .addColMeta(\"v0\",\n                {dis: readById(meterRef).dis + \" - Validated Data\"})\n  return chart\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptAccumulatorToDelta"],,,,M,,,,,,"calculateAccToDelta",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Wrapper around ptAccumulatorToDelta with results written to \n  point history.\n  \n  Arguments:\n  restartDate (optional)   Date to rewrite history from. Must be\n                           a date, not a dateTime.\n  newOnly (optional)       If true, calculate only for points that\n                           have no history (not hisEnd)\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2018-11-07 //\n*/\n\n(restartDate:null, newOnly:false) => do\n\n  today: now().date\n  // We expect all virtual delta points with a pointRef\n  //  and no hisFunc can go through this function\n  filter: \"virtual and delta and sensor and point\" +\n          \" and his and pointRef and not hisFunc\"\n  if (newOnly) filter = filter + \" and not hisEnd\"\n  query: parseFilter(filter)\n             \n  ptList: readAll(query)\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  ptList.each pt => do\n    hisEnd: pt[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    argument). Assign dates based on the 4 possibilities\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input: clear history from restartDate\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Calculate.\n    resultGrid: ptAccumulatorToDelta(pt, dates)\n    \n    // Filter out redundant data (already in history)\n    filteredGrid: resultGrid.findAll(row => row->ts > hisEnd)\n    \n    // Write calculated data to history.\n    hisWrite(filteredGrid, pt)\n    return {written: filteredGrid.size, status: \"OK\"}\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viMeterMonthly"],,,,M,,,,,,"viUpdateMonthlyReadsReport",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(meterType:\"gas\", viewRef:@p:lbnl:r:25ab6c5c-695c557e) => do\n  filterStr: meterType + \" and sblid and equip and meter\"\n  meterGrid: readAll(parseFilter(filterStr))\n             .addCol(\"siteDis\", r => try parseNumber(r->siteRef->dis).format(\"000\")\n                                     catch r->siteRef->dis)\n             .sort((a,b) => a->siteDis <=> b->siteDis)\n  \n  src: \"\"\"view: {inherit:\"page\"}\n          outputType: {var enum:\"Daily Averages Only,All Trends\" kind:\"Str\" input defVal:\"Daily Averages Only\"}\n          ignores: {var enum:\"Hide Ignored Readings,Show Ignored Readings\" kind:\"Str\" input defVal:\"Show Ignored Readings\"}\"\"\"\n  \n  meterGrid.each((m,i) => do\n    src= src + \"\\nsubview\" + i+1 + \": Trio:\"\n    src= src + \"\\n  view: {inherit:\\\"chart\\\"}\"\n    src= src + \"\\n  meterRef: {var kind:\\\"Ref<meter>\\\" defVal:@\"+m->id.toStr+\"}\\n\"\n    src= src +\"\"\"  outputType: {var input binding:\"../outputType\"}\n                   ignores: {var input binding:\"../ignores\"}\n                   data: {expr:\"viMeterMonthly({{meterRef}},65°F,55°F,{{outputType}}==\\\\\\\"Daily Averages Only\\\\\\\",{{ignores}}==\\\\\\\"Show Ignored Readings\\\\\\\").removeCols([\\\\\\\"countDays\\\\\\\"])\"}\"\"\"\n  end)\n  commit(diff(readById(viewRef), {src:src}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"viDeficienciesSummary",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  From a table of deficiencies, prepare high-level summaries, either grouping all\n  deficiencies assigned to the same person, or grouping all deficiencies with\n  the same state. Calculate corresponding total sizes, and grand total size.\n  \n  Arguments: \n  grid          Grid of deficiencies\n  summary       Str, either \"assignedTo\" or \"state\"\n*/\n\n(grid, summary:\"assignedTo\") => do\n  if (grid==null) return null\n  \n  // Initialize with empty grid\n  gridOut: {}.toGrid()\n  \n  // Group by assignedTo\n  if (summary==\"assignedTo\" and grid.has(\"assignedTo\")) do\n    grid.colToList(\"assignedTo\").unique.each p => do\n      // Cycle through each assignedTo person\n      sub: grid.findAll(r => r[\"assignedTo\"]==p)\n      sSize: if (isEmpty(sub)) null else sub.findAll(r => isNumber(r[\"size\"]))\n                                            .foldCol(\"size\", sum)\n      // Add summary row only if size is greater than zero\n      if (sSize != null and sSize > 0)\n        gridOut= gridOut.addRow({assignedTo: if (p==null) \"Unassigned\"\n                                             // Add space to show at top\n                                             else \" \"+p,\n                                 size: sSize,\n                                 count: if (isEmpty(sub)) null else sub.size})\n    end\n    \n  // Add total\n  totSize: try grid.findAll(r => isNumber(r[\"size\"])).foldCol(\"size\", sum)\n           catch null\n  gridOut= gridOut\n           .sort((a,b) => a[\"assignedTo\"] <=> b[\"assignedTo\"])\n           .addRow({assignedTo: \"TOTAL\",\n                    size: totSize,\n                    count: grid.size})\n           .toolFormatGrid([\"assignedTo\",\"size\",\"count\"])\n  end\n  \n  // Group by state\n  if (summary==\"state\" and grid.has(\"state\")) do\n    [\"New\",\"In Progress\",\"To Do\",\"Pending\",\"Backlog\",\n     \"Resolved\",\"Closed\",\"In Consideration\",\"Abandoned\"].each s => do\n      // Cycle through each state in selected order\n      sub: grid.findAll(r => r[\"state\"]==s)\n      sSize: try sub.findAll(r => isNumber(r[\"size\"])).foldCol(\"size\", sum)\n             catch null\n      // Add summary row only if size is greater than zero\n      if (sSize != null and sSize>0)\n        gridOut= gridOut.addRow({state: s,\n                                 size: sSize,\n                                 count:sub.size})\n    end\n    \n    // Add total\n    totSize: try grid.findAll(r => isNumber(r[\"size\"])).foldCol(\"size\", sum)\n             catch null\n    gridOut= gridOut.addRow({state: \"TOTAL\",\n                             size: totSize,\n                             count: grid.size})\n                    .toolFormatGrid([\"state\",\"size\",\"count\"])\n  end\n  \n  if (isEmpty(gridOut)) return null\n  else return gridOut\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateTask"],,,,M,,,,,,"recEditTask",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(taskDict) => do\n  // Normalize action input\n  taskDict= actionNormInput(taskDict, \"dict\")\n  \n  if(taskDict.has(\"modRef\"))\n    taskDict= taskDict\n    .set(\"siteRef\", if (readById(taskDict[\"modRef\"]).has(\"site\"))\n                      taskDict[\"modRef\"] \n                    else readById(taskDict[\"modRef\"])->siteRef)\n\n  // Validate record\n  taskDict= recValidateTask(taskDict)\n\n  recEdit(taskDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Zone Cooling with ZAT < CLG SP",,M,"Zone cooling PID output is greater than zero, despite zone air temp being lower than the cooling setpoint for a given amount of time (default 1h)",,,,,"ruZoneCoolingSpIssue",,"equip and ((terminalUnit and supply) or zone)","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n\n  This function returns periods when a terminal unit's cooling PID\n  loop is > 0% but the ZAT has been under the ZAT cooling setpoint\n  for a given amount of time\n  \n  Arguments:\n  equip           equip record of equip to test airflow on\n  span            dateSpan, span of dates to run analysis on\n  tolerance       number, reduces ZAT cooling setpoint as additional\n                  tolerance to account for integral term\n  minOutput       number, minimum output above which we consider the\n                  cooling PID loop is active\n  minTime         duration, filter out periods shorter than minTime\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n*/\n\n(equip, dates, tolerance: 0.1, minOutput: 1%,\n minTime: 2h, mergePeriod: 0min) => do\n  coolSP: read(point and zone and air and temp\n               and effective and cooling and sp\n               and equipRef==equip->id, false)\n               \n  coolPID: read(point and cool and pid and cmd\n                and equipRef==equip->id, false)\n           \n  zat: read(point and zone and air and temp\n            and sensor\n            and equipRef==equip->id, false)\n            \n  // If any of these three points is missing, stop testing\n  if (coolSP==null or coolPID==null or zat==null) return null\n  \n  // Read history, combine\n  flagPeriods: [zat, coolSP, coolPID].hisRead(dates, {limit: null})\n      .hisInterpolate()\n      .addCol(\"flag\", row => do\n        if (row[\"v0\"]==null or row[\"v1\"]==null or row[\"v2\"]==null)\n          return null\n        else if ((row[\"v0\"] < (row[\"v1\"] - tolerance))\n                 and row[\"v2\"] > minOutput)\n          return 1\n        else return 0\n      end)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindAll(val => val != null)\n      .hisFindPeriods(val => val == 1)\n      \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip->navName + \" tries to cool despite ZAT < CLG SP\"\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06ZoneEquip",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create zones\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b6/b6_zone_equip.csv`)\n  siteId: read(site and dis==\"06\")->id\n  \n  file.each row => do\n    floor: \"B6 Floor \" + row->floor\n    floorId: read(location and siteRef->dis==\"06\" and\n                  dis==floor)->id\n    room: \"Rm \" + row->equip\n    exist: readAll(siteRef==siteId and \n                   locationRef==floorId and\n                   equip and\n                   navName==room)\n                   \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: room,\n         disMacro: \"\\\$locationRef \\\$navName\",\n         zone,\n         equip,\n         locationRef: floorId,\n         siteRef: siteId,\n         sadieTemp\n        },\n        {add}\n      ))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpIntgB67evav",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  grid: ioReadCsv(`io/integration_b67/b67_evav_exh.csv`)\n  .addCol(\"roomId\", row => read(zone and siteRef->dis==\"67\" and navName==\"Rm \"+row->room)->id)\n  .addCol(\"exhaustSystemRef\", row => readAll(siteRef->dis==\"67\" and exhaustSystem)\n                                     .find(exh => exh->navName.contains(reGroups(r\"67-BL-\\d(\\d\\d)\", row->exhaust)[1]))->id)\n  .addCol(\"vavDis\", row => \"Exh \"+reGroups(r\"^67(-|_)(.+)\", row->evav)[2])\n  .addCol(\"exhMissing\", row => read(exhaust and terminalUnit and equipRef==row->roomId,false)==null)\n  \n  grid.each(row => do\n    // Locate EVAV or create if missing\n    evav: read(exhaust and terminalUnit and equipRef==row->roomId,false)\n    if (evav==null) do\n      evavDict: {equip,\n                 exhaust,\n                 terminalUnit,\n                 siteRef: row->roomId->siteRef,\n                 locationRef: row->roomId->locationRef,\n                 equipRef: row->roomId,\n                 disMacro: \"\\\$equipRef \\\$navName\",\n                 controller: row->controller,\n                 exhaustSystemRef: row->exhaustSystemRef,\n                 navName: row->vavDis,\n                 tmp:today()}\n      evav= commit(diff(null, evavDict, {add}))\n    end\n    \n    // Rename terminal unit, add controller, add exhaustSystermRef\n    changesDict: {navName: row->vavDis,\n                  controller: row->controller,\n                  exhaustSystemRef: row->exhaustSystemRef}\n    commit(diff(evav, changesDict))\n  end)\n  \n  // Add equipRef tags to connPointCache records\n  readAll(exhaust and terminalUnit and equip and siteRef->dis==\"67\")\n  .each(exh => if (exh.has(\"controller\")) do\n      cacheRecs: readAll(connPointCache and connRef->siteRef->dis==\"67\")\n      .findAll(row => if(row.has(\"bacnetCurName\"))\n                        row[\"bacnetCurName\"].contains(exh->controller)\n                      else if(row.has(\"bacnetHisName\"))\n                        row[\"bacnetHisName\"].contains(exh->controller)\n                      else false)\n      \n      if (isEmpty(cacheRecs)) return null\n      else cacheRecs\n           .each(rec => commit(diff(rec, {equipRef:exh->id})))\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anFumeHoodSash"],,,,M,,,,,,"viFumeHoodSashStacked",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site or location, retrieve all fume hoods and calculate\n  their sash height using the function anFumeHoodSash\n  \n  Arguments: \n  locRef             Reference for site or location to search under\n  dates              Span, dates to run analysis on\n  focus              Str, enum:\"All,Occupied,Unoccupied\"\n  scheduleRef        Ref for schedule to use along with focus\n*/\n\n(locRef: @p:lbnl:r:22c912f0-91f6badd, dates: pastWeek(),\n focus:\"All\", scheduleRef:null, chartMax:\"Auto\") => do\n  // Retrieve location / site record, then retrieve all fume hoods\n  loc: readById(locRef)\n  if (loc.has(\"site\"))\n    fhs: readAll(fumeHood and equip and siteRef==locRef)\n  else\n    fhs: readAll(fumeHood and equip and locationRef==locRef)\n    \n  // Exit if no fume hoods were found\n  if(isEmpty(fhs)) return null\n  \n  bins: fhs.map fh => do\n    fhSashHeight: anFumeHoodSash(fh->id, dates, 0.1)\n    if (fhSashHeight==null or isEmpty(fhSashHeight)) return null\n    \n    // Filter by focus / schedule\n    if (focus != \"All\" and scheduleRef != null) do\n      schedule: readById(scheduleRef)\n      \n      if (schedule->navName == \"Occupancy Sensors\")\n        // Placeholder, retrieve occ sensor info and filter\n        filterPeriods: fhSashHeight.hisFindPeriods(v => true)\n      else do\n        if (focus==\"Occupied\")\n          filterFunc: v => v\n        else\n          filterFunc: v => not(v)\n      \n        filterPeriods: scheduleHis(schedule, dates)\n                       .hisFindPeriods(filterFunc)\n      end\n    end else filterPeriods: fhSashHeight.hisFindPeriods(v => true)\n    \n    // Bin 0\n    closed: fhSashHeight.hisFindPeriods(val =>\n        if(val==null or val==na()) return false else val >= 0in and val < 4in)\n    if (isEmpty(closed)) binClosed: 0h\n    else binClosed: hisPeriodIntersection([closed, filterPeriods])\n                    .foldCol(\"v0\",sum)\n    \n    // Bin 1\n    bin1: fhSashHeight.hisFindPeriods(val =>\n        if(val==null or val==na()) return false else val >= 4in and val < 8in)\n    if (isEmpty(bin1)) bin1= 0h\n    else bin1= hisPeriodIntersection([bin1, filterPeriods])\n               .foldCol(\"v0\",sum)\n    \n    // Bin 2\n    bin2: fhSashHeight.hisFindPeriods(val =>\n        if(val==null or val==na()) return false else val >= 8in and val < 12in)\n    if (isEmpty(bin2)) bin2= 0h\n    else bin2= hisPeriodIntersection([bin2, filterPeriods])\n               .foldCol(\"v0\",sum)\n    \n    // Bin 3\n    bin3: fhSashHeight.hisFindPeriods(val =>\n        if(val==null or val==na()) return false else val >= 12in)\n    if (isEmpty(bin3)) bin3= 0h\n    else bin3= hisPeriodIntersection([bin3, filterPeriods])\n               .foldCol(\"v0\",sum)\n    \n    // Bin issues\n    binR: fhSashHeight.hisFindPeriods(val =>\n        if(val==null or val==na()) return true else val < 0in)\n    if (isEmpty(binR)) binR= 0h\n    else binR= hisPeriodIntersection([binR, filterPeriods])\n               .foldCol(\"v0\",sum)\n    \n    // Return results\n    return {dis: fh->equipRef->navName+\" \"+fh->navName,\n            binClosed: if (binClosed >= 0) binClosed else 0h,\n            bin1: if (bin1 >= 0) bin1 else 0h,\n            bin2: if (bin2 >= 0) bin2 else 0h,\n            bin3: if (bin3 >= 0) bin3 else 0h,\n            binR: if (binR >= 0) binR else 0h}\n  end\n  \n  // Exit if empty\n  if (isEmpty(bins)) return null\n  \n  // Set chartMax\n  if (chartMax==\"Auto\") chartMax= null\n  else chartMax= (dates.end() - dates.start() + 1).to(\"hr\")\n  \n  // Sort rooms, add col meta\n  bins= bins.addColMeta(\"binClosed\", {color: \"#00cc33\",\n                                      dis: \"Closed\",\n                                      chartMax: chartMax})\n            .addColMeta(\"bin1\", {color: \"#cccc00\",\n                                      dis: \"04 to 08 in\",\n                                      chartMax: chartMax})\n            .addColMeta(\"bin2\", {color: \"#ff9933\",\n                                      dis: \"08 to 12 in\",\n                                      chartMax: chartMax})\n            .addColMeta(\"bin3\", {color: \"#ff0000\",\n                                      dis: \"12+ in\",\n                                      chartMax: chartMax})\n            .addColMeta(\"binR\", {color: \"#080808\",\n                                      dis: \"Data issue\",\n                                      chartMax: chartMax})\n            .sort((a,b) => a->dis <=> b->dis)\n\n  title: loc.dis() + \" sash heights, time in each category, \"\n         + (dates.toDateSpan()).start.format(\"WWW YYYY-MM-DD\") + \" to \" \n         + (dates.toDateSpan()).end.format(\"WWW YYYY-MM-DD\")\n  if (loc.has(\"site\")) title= \"B\" + title\n  if (focus != \"All\")\n    title= title + \", \" + focus.decapitalize + \" hours only\"\n\n\n  return bins.addMeta({view: \"chart\", chartType:\"stackedBar\",\n                       title: title,\n                       chartNoScroll})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolImportFunc",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load `io/tmp/func.zinc` grid. Commit new function records that\n  do not have a duplicate on the project (based on name).\n  \n  Arguments: \n  N/A\n*/\n\n(file:`io/tmp/func.zinc`) => do\n  // Load records\n  fs: try ioReadZinc(file)\n      catch return {error:\"File not found: \"+file}\n                   .toGrid\n\n  // Commit new function record if no duplicate found\n  fs. each f => do\n    exFunc: read(func and name==f->name, false)\n    if (exFunc==null)\n      commit(diff(null, f, {add}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viCWTWPowerBySystem",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the total system power for CW Pumps, TW Pumps,\n  Tower Fans for a given time period\n  \n  find OA Wetbulb for the same time period\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(bldgRef:null, dates: today, rollup: 5min) => do\n  // Default to B59 if no ref is provided\n  if(bldgRef==null)\n    bldgRef= read(site and dis==\"59\")\n    \n  bldgRefId: bldgRef->id\n    \n  // Get the reference for the TW and CW Plants\n  cwPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and treatedWaterPlant\n                    and navName == \"Plant\")\n  \n  \n  twPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and condenserWaterPlant\n                    and navName == \"Plant\")\n  \n  //wetbulb temperature (defaulting to the same location as the default)\n  wbTemp: read(equipRef==twPlantEquip->id and outside and point and sensor and wetBulb)\n          .hisRead(dates, {limit:null})\n          .toolHisAlign(avg, min, true, rollup)\n          .renameCol(\"v0\",\"oaWetBulb\")\n  \n  // Get the power points for the TW pumps, CT Fans, and CW Pumps\n  twPumpPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n  ctFanPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->fan\n                    and power\n                    and sensor)\n  \n  cwPumpPowers: readAll(locationRef==cwPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n   // Sum the power histories for each system, TW Pumps, CT Fans, and CW Pumps\n   totTWPumpPower: hisRead(twPumpPowers, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"twPump\")\n   \n   totCTFanPower: hisRead(ctFanPowers, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"ctFan\")\n\n   totCWPumpPower: hisRead(cwPumpPowers, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"cwPump\")\n                   \n   totSysPower: hisJoin([totTWPumpPower, totCTFanPower, totCWPumpPower])\n                .toolHisAlign(avg, min, true, rollup)\n                .hisFoldCols(sum)\n                .renameCol(\"v0\",\"totSys\")\n                \n        \n  //Join the histories into a common map\n        combined: hisJoin([totTWPumpPower, totCTFanPower, totCWPumpPower, totSysPower,wbTemp])\n                    .addColMeta(\"twPump\",\n                      {dis: \"Tower Water Pump Power (kW)\",\n                      unit: \"kW\", color: \"#4B0082\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"ctFan\",\n                      {dis: \"CT Fan Power (kW)\",\n                      unit: \"kW\", color: \"#FF8C00\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"cwPump\",\n                      {dis: \"Cooling Water Pump Power (kW)\",\n                      unit: \"kW\", color: \"#008000\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"totSys\",\n                      {dis: \"Total System Power (kW)\",\n                      unit: \"kW\", color: \"#000000\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"oaWetBulb\",\n                      {dis: \"Outside Air Wetbulb Temperature (°F)\",\n                      unit: \"°F\", color: \"#2796BF\",\n                      chartGroup: \"all\"})\n  return combined\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["fandocDataQualityLinks","fandocDataQuality","fandocMeterFormulas"],,,,M,,,,,,"fandocDataQuality",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Prepare and return fandoc string containing data quality\n  information for a given meter\n  \n  Arguments:\n  meterRef        Ref to a specific meter\n  span            Span, restrict description of records that\n                  overlap with given span (optional)\n*/\n\n(meterRef, span:null) => do\n  // Load meter record from id\n  meter: readById(meterRef)\n  \n  // Begin preparing fandoc string\n  // Title\n  doc: dis(meter)+\" Data Quality\\n-----\\n\"\n  \n  // Retrieve data quality records related to the given meter\n  qualityRecs: readAll(dataQuality and meterRef==meterRef)\n  if (isEmpty(qualityRecs)) do\n    meterFormulasDoc: fandocMeterFormulas(meterRef, span)\n    if (meterFormulasDoc==null or meterFormulasDoc==\"\")\n      return doc+ \"There are no data quality records or formulas \"\n                + \"associated with this meter.\"\n    else\n      return doc+ \"This is a virtual meter without any directly \"\n                + \"associated data quality records. Please check \"\n                + \"the meter links below for data quality details.\"\n                + \"\\n\\n---\\n\"\n                + meterFormulasDoc\n  end\n  \n  // Sort by start date\n  qualityRecs= qualityRecs\n  .sort((a,b) => a->startDate <=> b->startDate)\n  \n  // If span is not provided, show full range from first\n  // available record until today\n  if(span==null)\n    span= qualityRecs.first->startDate..today()\n  span= span.toDateSpan()\n  \n  // Continue building doc string\n  // Current status based on latest record\n  doc= doc+\"Current status: **\"\n          +qualityRecs[-1]->dataQuality\n          +\"**\"\n          \n  // Compile information about all records that overlap 'span'\n  qualityRecs.each((qualityRec, n) => do\n    // Determine period start and period end for current record\n    thisStart: qualityRec->startDate\n    thisEnd: try qualityRecs[n+1]->startDate - 1day\n             catch span.end\n\n    // If there is no overlap, skip record\n    if (span.start >= thisEnd) return null\n    if (span.end < thisStart) return null\n\n    // Add record information to fandoc string\n    doc= doc+\"\\n\\n---\\n\"\n    doc= doc+ \"*From \"\n            + thisStart.format(\"YYYY-MM-DD (WWW)\")\n            + \" to \"\n            + thisEnd.format(\"YYYY-MM-DD (WWW)\")\n            + \", data quality was marked as: \"\n            + \"**\"+qualityRec->dataQuality +\"** *\"\n    \n    // Add note if there is a note\n    if (qualityRec[\"qualityNote\"] != null)\n      doc= doc+\"\\n\\n\"\n              +qualityRec[\"qualityNote\"].split(\"\\n\").concat(\" - \")\n    \n    // Add hyperlinks\n    doc= doc+fandocDataQualityLinks(qualityRec)\n  end)\n  \n  return doc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["meterFormulaLinks","viMeterFormula"],,,,M,,,,,,"fandocMeterFormulas",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Prepare and return fandoc string describing a meter's\n  formulas\n  \n  Arguments:\n  meterRef      Ref to meter\n  span          Datespan to retrieve info for (optional)\n*/\n\n(meterRef, span:null) => do\n  // Begin preparing fandoc string\n  doc: \"\"\n  \n  // Retrieve meter formulas\n  formulas: viMeterFormula(meterRef)\n  if (formulas==null)\n    return null\n  \n  // Check if span is provided\n  if (span==null)\n    try span= (formulas.first->startInclusive..today())\n    catch return null\n  span= span.toDateSpan()\n  \n  // Cycle through formulas\n  formulas.each formula => do\n    // Find start and end dates associated with formula\n    fStart: try formula->startInclusive\n            catch return null\n    fEnd: if(formula[\"endExclusive\"]==null\n             or formula[\"endExclusive\"]==\"\") today()\n          else formula[\"endExclusive\"] - 1day\n          \n    // If there is no overlap with 'span', skip formula\n    if (span.start >= fEnd) return null\n    if (span.end < fStart) return null\n    \n    if(doc != \"\") doc= doc+\"\\n\\n---\\n\"\n    \n    // Add formula information to fandoc string\n    doc= doc+ \"*From \"\n            + fStart.format(\"YYYY-MM-DD (WWW)\")\n            + \" to \"\n            + fEnd.format(\"YYYY-MM-DD (WWW)\")\n            + \", the meter links used in this virtual \"\n            + \"meter's formula are:*\\n\\n\"\n    \n    doc= doc+\"**\"+formula.meterFormulaLinks.concat(\"**, **\")+\"**\"\n  end\n  \n  return doc\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anAhuZoneHeatingNeeds",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze terminal unit trends for all terminal units related to\n  given AHU and return one historical trend of zones that need more\n  heating, as calculated by comparing zone air temp with the effective\n  zone heating setpoint, minus a given tolerance.\n  \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  tolerance    number, decreases ZAT heating setpoint\n  rollup       duration, interval for rollup of ZAT\n  total        bool, if true return the total, if false return\n               the individual terminal unit trends\n*/\n\n(ahuRef, dates: yesterday(), tolerance: 1°F, rollup: 15min,\n total: true) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve a grid of all supply terminal units associated with AHU\n  tus: readAll(supply and terminalUnit and ahuRef==ahuRef)\n  \n  // Return null if no associated terminal units are found\n  if (isEmpty(tus)) return null\n  \n  // Cycle through zones and create history of cooling needs\n  needs: {}.toGrid()\n  tus.each(tu => do\n    // Find ZAT and ZAT cooling setpoint\n    heatSp: read(point and zone and air and temp\n                 and effective and heating and sp\n                 and equipRef==tu->id, false)\n                 \n    zat: read(point and zone and air and temp\n              and sensor\n              and equipRef==tu->id, false)\n              \n    // If any point is missing, skip terminal unit\n    if (heatSp==null or zat==null) return null\n    \n    // Col name based on zone name\n    if (tu.has(\"equipRef\"))\n      colName: tu->equipRef->navName.toTagName()\n    else\n      colName: tu->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    flags: [zat, heatSp].hisRead(dates, {limit: null})\n        .hisRollup(avg, rollup)\n        .hisInterpolate()\n        .addCol(colName, row => do\n          if (row[\"v0\"]==null or row[\"v1\"]==null or\n              row[\"v0\"]==na() or row[\"v1\"]==na())\n            return na()\n          else if (row[\"v0\"] < (row[\"v1\"] - tolerance).as(1))\n            return 1\n          else return 0\n        end)\n        .keepCols([\"ts\",colName])\n        .hisFindAll(val => val != null)\n        .addColMeta(colName, {dis: tu.dis()+\" Need Heating\"})\n        \n    // Add to needCooling summary array\n    if (isEmpty(flags)) return null\n    if (isEmpty(needs)) needs=flags\n    else needs= hisJoin([flags,needs])\n  end)\n  \n  if (isEmpty(needs)) return null\n  if (not(total)) return needs\n  \n  // Sum up all terminal units into one trend\n  tot: needs.cols.size()-1\n  disName: \"Count, terminal units need heating (ZAT < HTG SP - \"\n           + tolerance.as(\"°F\") + \"), out of max \" + tot\n  count: needs\n      .hisFoldCols(sum)\n      .findAll(row => row[\"v0\"] != na() and row[\"v0\"] != null)\n      .addColMeta(\"v0\", {dis: disName, color:\"#2348ff\",\n                         chartMin: 0})\n      \n  return count\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"convertStrToDateTime",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function takes a string of date, time, and (optionally) time zone\n and converts it into a dateTime format. It uses the parseDate and\n parseTime functions, but all formats of dates and times are hard-coded\n into this function (so you don't have to think about the format of your\n dates/times when composing other functions. The dates and times are put\n roughly in order of most expected to least expected. Should this\n function not work (ie it doesn't recognize that format of date or time),\n simply follow the layout shown below and add that format.\n\n Arguments:\n dateString               String to convert to date\n \n timeString               String to convert to time. If null, default to\n                          midnight\n \n tz                       String name of time zone. Default is GMT (UTC)\n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-11-29 //\n*/\n\n(dateString:null,timeString:null,tz:\"GMT\") => do\n  \n  ///////////////////////////////////////////////////////////////////\n  // First match date to its correct format. All dates are in the  //\n  // Same if-statement, but broken up by general format.           //\n  ///////////////////////////////////////////////////////////////////\n  \n  // If null\n  if (dateString==null) do\n    date: \"No date entered\"\n  \n  // These 4 formats are year(4)/month/day\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\/\\\\d{1}\\\\/\\\\d{1}\"\"\" ,dateString)) do // Ex: 2018/1/1\n    date: parseDate(dateString,\"YYYY/M/D\")\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\/\\\\d{1}\\\\/\\\\d{2}\"\"\" ,dateString)) do // Ex: 2018/1/31\n    date: parseDate(dateString,\"YYYY/M/DD\")\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\/\\\\d{2}\\\\/\\\\d{1}\"\"\" ,dateString)) do // Ex: 2018/12/1\n    date: parseDate(dateString,\"YYYY/MM/D\")\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\/\\\\d{2}\\\\/\\\\d{2}\"\"\" ,dateString)) do // Ex: 2018/01/01\n    date: parseDate(dateString,\"YYYY/MM/DD\")\n  \n  // These 4 formats are month/day/year(4)\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\/\\\\d{1}\\\\/\\\\d{4}\"\"\" ,dateString)) do // Ex: 1/1/2018\n    date: parseDate(dateString,\"M/D/YYYY\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\/\\\\d{2}\\\\/\\\\d{4}\"\"\" ,dateString)) do // Ex: 1/31/2018\n    date: parseDate(dateString,\"M/DD/YYYY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\/\\\\d{1}\\\\/\\\\d{4}\"\"\" ,dateString)) do // Ex: 12/1/2018\n    date: parseDate(dateString,\"MM/D/YYYY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\/\\\\d{2}\\\\/\\\\d{4}\"\"\" ,dateString)) do // Ex: 01/01/2018\n    date: parseDate(dateString,\"MM/DD/YYYY\")\n  \n  // These 4 formats are month/day/year(2)\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\/\\\\d{1}\\\\/\\\\d{2}\"\"\" ,dateString)) do // Ex: 1/1/18\n    date: parseDate(dateString,\"M/D/YY\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\/\\\\d{2}\\\\/\\\\d{2}\"\"\" ,dateString)) do // Ex: 1/31/18\n    date: parseDate(dateString,\"M/DD/YY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\/\\\\d{1}\\\\/\\\\d{2}\"\"\" ,dateString)) do // Ex: 12/1/18\n    date: parseDate(dateString,\"MM/D/YY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\/\\\\d{2}\\\\/\\\\d{2}\"\"\" ,dateString)) do // Ex: 01/01/18\n    date: parseDate(dateString,\"MM/DD/YY\")\n  \n  // These 4 formats are year(4)-month-day\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\-\\\\d{1}\\\\-\\\\d{1}\"\"\" ,dateString)) do // Ex: 2018-1-1\n    date: parseDate(dateString,\"YYYY-M-D\")\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\-\\\\d{1}\\\\-\\\\d{2}\"\"\" ,dateString)) do // Ex: 2018-1-31\n    date: parseDate(dateString,\"YYYY-M-DD\")\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\-\\\\d{2}\\\\-\\\\d{1}\"\"\" ,dateString)) do // Ex: 2018-12-1\n    date: parseDate(dateString,\"YYYY-MM-D\")\n  end else if (reMatches(\"\"\"\\\\d{4}\\\\-\\\\d{2}\\\\-\\\\d{2}\"\"\" ,dateString)) do // Ex: 2018-01-01\n    date: parseDate(dateString,\"YYYY-MM-DD\")\n  \n  // These 4 formats are month-day-year(4)\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\-\\\\d{1}\\\\-\\\\d{4}\"\"\" ,dateString)) do // Ex: 1-1-2018\n    date: parseDate(dateString,\"M-D-YYYY\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\-\\\\d{2}\\\\-\\\\d{4}\"\"\" ,dateString)) do // Ex: 1-31-2018\n    date: parseDate(dateString,\"M-DD-YYYY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\-\\\\d{1}\\\\-\\\\d{4}\"\"\" ,dateString)) do // Ex: 12-1-2018\n    date: parseDate(dateString,\"MM-D-YYYY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\-\\\\d{2}\\\\-\\\\d{4}\"\"\" ,dateString)) do // Ex: 01-01-2018\n    date: parseDate(dateString,\"MM-DD-YYYY\")\n  \n  // These 4 formats are month-day-year(2)\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\-\\\\d{1}\\\\-\\\\d{2}\"\"\" ,dateString)) do // Ex: 1-1-18\n    date: parseDate(dateString,\"M-D-YY\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\-\\\\d{2}\\\\-\\\\d{2}\"\"\" ,dateString)) do // Ex: 1-31-18\n    date: parseDate(dateString,\"M-DD-YY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\-\\\\d{1}\\\\-\\\\d{2}\"\"\" ,dateString)) do // Ex: 12-1-18\n    date: parseDate(dateString,\"MM-D-YY\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\-\\\\d{2}\\\\-\\\\d{2}\"\"\" ,dateString)) do // Ex: 01-01-18\n    date: parseDate(dateString,\"MM-DD-YY\")\n  \n  // If it does not match an above format\n  end else do\n    date: \"Not a recognized date\"\n  end\n  \n  ///////////////////////////////////////////////////////////////////\n  // Match time to its correct format.                             //\n  //                                                               //\n  ///////////////////////////////////////////////////////////////////\n  if (timeString==null) do\n    time: time(0,0,0)\n  \n  // 24-Hour\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\:\\\\d{2}\\\\:\\\\d{2}\"\"\",timeString)) do // Ex: 06:00:00\n    time: parseTime(timeString,\"hh:mm:ss\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\:\\\\d{2}\\\\:\\\\d{2}\"\"\",timeString)) do // Ex: 6:00:00\n    time: parseTime(timeString,\"h:mm:ss\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\:\\\\d{2}\"\"\",timeString)) do // Ex: 06:00\n    time: parseTime(timeString,\"hh:mm\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\:\\\\d{2}\"\"\",timeString)) do // Ex: 6:00\n    time: parseTime(timeString,\"h:mm\")\n  \n  // 12-Hour\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\:\\\\d{2}\\\\:\\\\d{2}\\\\w{2}\"\"\",timeString)) do // Ex: 06:00:00pm\n    time: parseTime(timeString,\"kk:mm:ssaa\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\:\\\\d{2}\\\\:\\\\d{2}\\\\w{2}\"\"\",timeString)) do // Ex: 6:00:00pm\n    time: parseTime(timeString,\"k:mm:ssaa\")\n  end else if (reMatches(\"\"\"\\\\d{1}\\\\:\\\\d{2}\\\\w{2}\"\"\",timeString)) do // Ex: 6:00pm\n    time: parseTime(timeString,\"k:mmaa\")\n  end else if (reMatches(\"\"\"\\\\d{2}\\\\:\\\\d{2}\\\\w{2}\"\"\",timeString)) do // Ex: 12:00pm\n    time: parseTime(timeString,\"kk:mmaa\")\n  \n  // If it does not match an above format\n  end else do\n    time: \"Not a recognized time\"\n  end\n  \n  if (debugType(date)==\"sys::Date\" and debugType(time)==\"sys::Time\") do\n    dateTime: dateTime(date,time,tz)\n  end else do\n    dateTime: {date:date,time:time,tz:tz, error: \"dateTime not recognized\"}\n  end\n  \n  return dateTime\n  \nend\n\n/* All possible formats:\n06:00:00\n6:00:00\n6:00\n\n14:00:00\n\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridShowGaps","toolRecursiveSearch"],,,,M,,,,,,"viPUEScatter_v2",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the PUE points for b59 and construct a scatter \n  chart with respect to outside air wetbulb temperature \n  for display on a graph\n    \n  Arguments: \n  equipRef       Ref to an equip\n  compRef        Ref to compute meter power for filter\n  span           period to display\n  min            min compute power for filter\n  max            max compute power for filter\n  hisInterval    PUE interval used for calculation (specific to points)\n  tempRef        Ref to outdoor air temp for scatter chart\n  limit          limit on span for data view\n*/\n\n(equipRef:null, compRef:null, span:today()-3day..today()-1day, \n min:0kW, max:5000kW, hisInterval:15min, tempRef:null, \n limit: null) => do\n\n  gridE: try toolRecursiveSearch(equipRef,\n               \"(pue and sensor and his)\")\n         catch {}.toGrid()\n  \n  // Add hisInterval tag to PUE for proper calculation\n  if (not(isEmpty(gridE)))\n    gridE= gridE.map(row =>\n      if(row.has(\"pue\")) row.set(\"hisInterval\",hisInterval)\n      else row)\n\n  try grid: gridE.hisRead(span, {limit:limit})\n                 .hisRollup(avg, hisInterval)\n                 .toolHisGridShowGaps(hisInterval*1.01)\n  catch return null\n  \n  //Default to B59 Compute Power for compRef if none is provided\n  if(compRef==null)\n    compRef= @p:lbnl:r:2444485c-4d9af430\n\n  // Default to B59 TW oat wetbulb if no tempRef is provided\n  if(tempRef==null)\n    tempRef= @p:lbnl:r:239b14d5-3168b0a7\n\n  // Default to B59 Computer Compute Meter if none is provided\n  if(compFilter==null)\n    compFilter= read(siteRef==site and equipRef->navName==\"Computers\" and compute and meter and virtual and equip)\n    \n    \n  // Get the PUE trend for this siteRef and hisInterval\n  pue: read(siteRef==site and navName==pueNavName and hisInterval==hisInterval and pue and point)\n  \n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  //Get compute power for given comp filter\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n  \n  \n  // Interpolate, filter the pue\n  loopTrend: hisRead(pue,dates,{limit:null})\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"pue\")\n  if (isEmpty(loopTrend.hisClip)) return null\n  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .renameCol(\"v0\",\"oaWB\")\n\n  powerFilter: hisRead(compPower, dates, {limit:null})\n  //Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))\n\n  //Add OA Wetbulb and filter to PUE\n  metric: hisJoin([oaWetBulb, loopTrend])\n            .hisFindInPeriods(powerFilter)\n            .addColMeta(\"oaWB\",\n              {chartType: \"scatter\",\n               dis: \"OAT WB\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"pue\",\n              {chartType: \"scatter\",\n               dis: pueNavName,\n               unit: \"_\", color: \"#3F51B5\",\n               chartGroup: \"all\"})\n            \n  metricScatter: metric.keepCols([\"oaWB\",\"pue\"])\n                       .addMeta({chartType: \"scatter\", \n                               title: \"NERSC PUE vs. Outside Air Wetbulb Temperature\"})\n  \n  return metricScatter\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptMetricsCoolingSystemITUE","toolRecursiveSearch"],,,,M,,,,,,"viITUEScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the ITUE points for Cori, Edison, and Computers\n  and construct a scatter chart with respect to outside\n  air wetbulb temperature for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(dates: today, rollup: 15min, sysRef:null, wbRef:null) => do\n  // Default to B59 Data Center Computers if no sysRef is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id\n\n  // Default to B59 TW if no wbRef is provided\n  if(wbRef==null)\n    wbRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n  // Get all ITUEs under this computer\n  itues: toolRecursiveSearch(sysRef,\n                   \"hisFunc==\\\"ptMetricsCoolingSystemITUE\\\"\")\n\n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  // Interpolate, filter and calculate total input and output power\n  itueTrends: hisRead(itues,dates,{limit:null})\n                 .hisRollup(avg, rollup)\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"computers\")\n                 .renameCol(\"v1\", \"cori\")\n                 .renameCol(\"v2\", \"edison\")\n \n  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .hisRollup(avg, rollup)\n                  .renameCol(\"v0\",\"oaWB\")\n\n  //Add OA Wetbulb to the collection of itues\n  \n  \n  metric: hisJoin([oaWetBulb, itueTrends])\n            .addColMeta(\"oaWB\",\n              {chartType: \"scatter\",\n               dis: \"Combined Computer ITUE\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"computers\",\n              {chartType: \"scatter\",\n               dis: \"Combined Computer ITUE\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"cori\",\n              {chartType: \"scatter\",\n               dis: \"Cori ITUE\",\n               unit: \"_\", color: \"#DC143C\"})\n            .addColMeta(\"edison\",\n              {chartType: \"scatter\",\n               dis: \"Edison ITUE\",\n               unit: \"_\", color: \"#FF7F50\"})\n  \n  metricScatter: metric.keepCols([\"oaWB\",\"computers\",\"cori\",\"edison\"])\n                       .addMeta({chartType: \"scatter\", \n                               title: \"Computer ITUE vs. Outside Air Wetbulb Temperature\"})\n  \n  return metricScatter\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends","toolRecursiveSearch"],,,,M,,,,,,"tmpViZoneWarmup",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(siteDis, roomNumber, dates) => do\n  zoneRec:\n    readAll(siteRef->dis==siteDis and zone and equip and navName)\n    .find(zone => reMatches(\".*(Rm|Room) \"+roomNumber+\".*\",zone->navName), false)\n  \n  if (zoneRec==null) return null\n  \n  pts:\n    toolRecursiveSearch(zoneRec->id,\n        \"(zone and air and temp) \" +\n        \"or valve or (heat and not request) or flow\")\n  \n  pts.hisRead(dates, {limit:null})\n     .toolFormatTrends(\"By specified tag groups\",\n                       [\"zone and air and temp\"],\n                       null, null, 2)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","toolSplitTrends","ptMetricsCoolingLoopPpue"],,,,M,,,,,,"viPPUEPrePostScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Given a specific date, give the pre and post data for\n  the Cooling Loop Partial PUE. Present the data\n  as a scatter chart of pPUE vs OA WB Temp data at B59 (in °F). \n*/\n\n(dateRange: toDateSpan(2019-02-01..today()), dateOfChange:2019-03-07, min: null, max: null, xAxis: null, sysRef:null) => do\n    \n  // Default to B59 Data Center Computers if no sysRef is provided\n  if(sysRef==null)\n    sysRef = read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id\n\n  // if xAxis value is null, default to CW supply temperature \n  if(xAxis==null)\n  xAxis = readById(@p:lbnl:r:23909a8b-3478b7d0)\n  \n  if(xAxis==\"CW Supply Temperature\")\n  xAxis = readById(@p:lbnl:r:23909a8b-3478b7d0)\n  \n  if(xAxis==\"Outside Air Wetbulb Temperature\")\n  xAxis = readById(@p:lbnl:r:239b14d5-3168b0a7)\n  \n  // Get compute power for given computers filter\n  compFilter: read(equipRef==sysRef and compute and meter and virtual and equip)\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n  \n  // Define post range and convert to date from dateTime\n  rangeEnd: dateRange.end().date()\n  \n  postRange: toDateSpan(dateOfChange..rangeEnd)\n\n  // Get the Cooling Loop pPUE point and hisRead\n  loopPPUE: toolRecursiveSearch(sysRef,\n                   \"hisFunc==\\\"ptMetricsCoolingLoopPpue\\\"\")\n             .hisRead(dateRange, {limit:null})\n             .renameCol(\"v0\",\"loopPPUE\")\n\n\n  // Get xAxis\n  xAxisTrend: xAxis.hisRead(dateRange, {limit:null})\n             .renameCol(\"v0\",\"xAxis\")\n\n  // use toolSplitTrends to highlight the post range\n   loopPPUE =   toolSplitTrends(loopPPUE, postRange, \"orange\")\n   selectedCols:   loopPPUE.colNames().findAll(v => v != \"ts\")\n                   .insert(0, \"xAxis\")\n\n  powerFilter: hisRead(compPower, dateRange, {limit:null})\n  // Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))\n\n  // join cooling water and cooling loop ptue pre trend to prep for the scatter chart\n  // add title and meta to graph\n   graph: hisJoin([xAxisTrend, loopPPUE])\n                 .hisFindInPeriods(powerFilter)\n                 .keepCols(selectedCols)\n                 \n   if(isEmpty(graph) or graph.missing(\"xAxis\")) return null\n   else graph= graph\n               .addMeta({chartType: \"scatter\",\n                        title: \"Cooling Loop pTUE (Pre and Post) vs \" +xAxis->navName})\n               .addColMeta(\"xAxis\", {chartMin: 50°F, chartMax: 75°F})\n               .addColMeta(\"loopPPUE0\", {dis: \"Loop pTUE post \" +dateOfChange,\n                            color: \"#DE3E30\"})  \n               .addColMeta(\"loopPPUE\", {dis: \"Loop pTUE before \" + dateOfChange,\n                            color: \"#7ED7DE\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ruMeterZeroConsumption",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function detects periods of time during which a meter's consumption\n  readings were zero\n  \n  Arguments:\n  equip           equip record of meter to test consumption for\n  span            dateSpan, span of dates to run analysis on\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n  minTime         duration, filter out periods shorter than minTime\n*/\n\n(equip, dates, mergePeriod: 0min, minTime: 24hr) => do\n  // Get consumption delta\n  pt: read(point and delta and sensor and (energy or voume) and not hidden\n           and equipRef==equip->id, false)\n  if (pt==null) return null\n  \n  // Increase dates span so rule runs on > 24h thresholds\n  dates= dates.toDateSpan\n  span: dates.start-minTime..dates.end+minTime\n  hisGrid: pt.hisRead(span, {limit:null})\n    \n  // Find periods airflow setpoint is not met\n  flagPeriods: hisGrid.hisFindPeriods(v => v == 0)\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->v0 >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: pt.dis() + \" is zero\"\n  return flagPeriods.addColMeta(\"v0\", {dis: dis, chartType:\"runtime\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDamperFullOpen",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of damper cmd data from\n terminal units for which the damper is more than x% open\n more than y% of the time during the given time period; \n grid is optimized for use as a chart.\n \n Arguments:\n siteRef        site to analyze\n span           dateSpan, span of dates for which to return data\n thresholdOpen  number, between 0 and 1 (0% and 100%)\n thresholdTime  number, between 0 and 1 (0% and 100%)\n*/\n\n(siteRef: @p:lbnl:r:225ffa71-7758e5e3, span:pastWeek(), thresholdOpen: 0.99, thresholdTime:0.9) => do\n  // Check inputs, prepare filters\n  if (thresholdOpen > 1) thresholdOpen= 1\n  if (thresholdOpen <0) thresholdOpen= 0\n  thresholdOpen= thresholdOpen.as(1) // Remove unit if any\n  if (thresholdTime > 1) thresholdTime= 1\n  if (thresholdTime <0) thresholdTime= 0\n  thresholdTime= thresholdTime.as(1) // Remove unit if any  \n  \n  span= span.toDateSpan\n  timeThreshold: (span.end - span.start + 1day) * thresholdTime\n\n  allDampers: readAll(damper and cmd and siteRef==siteRef\n                      and (equipRef->terminalUnit or equipRef->zone)\n                     )\n\n  data: allDampers\n          .findAll(row => hisRead(row->id, span, {limit: null})\n                            .hisFindPeriods(p => p > (thresholdOpen*100).as(\"%\"))\n                            .foldCol(\"v0\", sum) > timeThreshold)\n          .sort((a,b) => readById(a->id).dis() <=> readById(b->id).dis())\n          .hisRead(span)\n\n  // Chart group by floor\n  data.colNames()[1..-1].each colName => do\n    data = data.addColMeta(colName,\n      {chartGroup: readById(data.col(colName).meta->locationRef->id)\n                   .dis()\n      })\n  end\n  \n  if (isEmpty(data)) data= {success: \"None of the \"\n                            + allDampers.foldCol(\"id\", count)\n                            + \" tested dampers met the given conditions\"\n                           }.toGrid\n  \n  data= data.addMeta({title: \"B\" + siteRef->dis + \" dampers that are commanded more than \"\n                             + thresholdOpen*100 + \"% open, more than \"\n                             + thresholdTime*100 + \"% of the time (\"\n                             + allDampers.foldCol(\"id\", count) + \" dampers tested at site)\"\n                     })\n  \n  return(data)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptRateToDelta",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates integers between rate points, and\n assigns them 'forward', i.e. delta1 = rate1 * (ts1 - ts0) at ts1\n  \n Virtual point (delta) needs to reference the source point\n (rate) as a pointRef.\n  \n Arguments:\n *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  unit: rec->unit\n  \n  // time unit based on rate\n  rateUnit: readById(rec->pointRef)->unit\n  sUnit: null\n  tUnit: null\n  if (rateUnit == \"gal/min\") do\n    sUnit= \"gal/min\"\n    tUnit= \"min\"\n  end else if (rateUnit == \"BTU/h\" or rateUnit == \"kBTU/h\") do\n    sUnit= \"BTU/h\"\n    tUnit= \"hr\"\n  end\n  if (tUnit == null) return null\n  \n  // Initialize previous timestamp tracker\n  t0: null\n\n  // Read history, calculate deltas, integrate\n  rec->pointRef  // Accumulator point\n    .hisRead(dates, {limit: null})\n    .each row => do\n      // All rows that are not first row\n      if (t0 != null and row[\"v0\"] != null) do\n        // Calculate delta\n        deltaTs: (row->ts - t0).to(tUnit)\n        deltaVal: (row->v0.to(sUnit) * deltaTs).to(unit)\n        yield(row->ts, deltaVal)\n      end\n      \n      // Update values\n      t0 = row->ts\n    end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viPotentialVirtual",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function finds points without a connector, which are likely\n  virtual points but are missing the virtual tag\n  Return grid with:\n    idPotentialVirtual:  point id\n    his:                 mark tag \n    hisFunc:             text tag\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  hits: readAll(point and not virtual and not connRef and not weatherPoint)\n        .map(row =>\n             {idPotentialVirtual: row->id,\n              his: row[\"his\"],\n              hisFunc: row[\"hisFunc\"]\n             }\n            )\n\n\n  if (isEmpty(hits))\n    hits = {success: \"No point appears to be missing \\'virtual\\' tag\"}\n           .toGrid\n  \n  return hits\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,[],,,,M,,,,,,"tmpMap06ExpZat",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/* \n Use previously created list of trends of interest and associated\n points stored in `io/integration_b6/b6_exp_hall_zat.csv`\n to add these points to existing equips.\n*/\n\n(finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b6/b6_exp_hall_zat.csv`)\n  \n  siteId: @p:lbnl:r:211cc8a4-6dc3ebdd\n  locationId: @p:lbnl:r:234a71f3-9123bb76\n  \n  bacnetPtList: [null, null, null, null, null, null]\n  bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\"]\n  \n  alcPtList= alcPtList.addCol(\"newPt\", row => do\n    // Find existing room\n    equipId: read(equip and zone and locationRef==locationId and navName==row->room)->id\n    \n    // Find connector\n    connectorId: readAll(bacnetConn and siteRef->dis==\"06\")\n                .find(co => co->dis.contains(\"Device \"+row->device) or \n                            co->dis.contains(\"Router \"+row->device)\n                     )->id\n               \n    // Get info from bacnetPtList by matching bacnetCur\n    bacnetLearn(connectorId)\n    curType: row->bacnetCur[0..1]\n    bacnetGrid: bacnetLearn(connectorId,bacnetObjMap.index(curType))\n    if (bacnetGrid == null) bacnetGrid= [].toGrid()\n    ptRowMatch: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n    if (ptRowMatch == null)\n      ptRowMatch= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n    \n    // Prepare new point dict\n    ptDict: {point,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: connectorId,\n             connRef: connectorId,\n             cur,\n             bacnetCur: row->bacnetCur,\n             bacnetHis: row[\"bacnetHis\"], //optional\n             bacnetCurName: row->bacnetCurName,\n             bacnetHisName: row[\"bacnetHisName\"],\n             bacnetDesc: ptRowMatch[\"bacnetDesc\"], //optional\n             kind: ptRowMatch[\"kind\"], //optional\n             unit: ptRowMatch[\"unit\"], //optional\n             enum: ptRowMatch[\"enum\"], //optional\n             equipRef: equipId,\n             his,\n             notes: row[\"point\"], //optional\n             locationRef: locationId,\n             siteRef: siteId,\n             tz: \"Los_Angeles\",\n             tmp: today(),\n             navName: \"Zone Temperature \"+row->zatNum,\n             air,\n             temp,\n             sensor}\n               \n    // Set collection interval / cov if no bacnetHis\n    if (row[\"bacnetHis\"] == null)\n      if (ptRowMatch[\"kind\"] == \"Bool\") do\n        ptDict= ptDict.set(\"hisCollectCov\", marker())\n        ptDict= ptDict.set(\"hisCollectInterval\", 12h)\n      end else do\n        ptDict= ptDict.set(\"hisCollectInterval\", 15min)\n      end\n\n    // Commit if finalize == true\n    if (finalize) do\n      commit(diff(null, ptDict, {add}))\n    end\n\n    return ptDict\n  end) // alcPtList.addRow(\"newPt\", row\n  \n  return alcPtList\nend\n \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["syncNerscElasticSecondary","syncNerscElastic"],,,,M,,,,,,"syncNerscElastic",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function queries the inner elastic search\n  sync function with the proper parameters that\n  are based on the history start and end dates.\n  \n  Arguments:\n  point        NERSC Elastic point\n  start_time   dateTime object specifying start of ranged query\n  end_time     dateTime object specifying end of ranged query\n  \n  // LBNL // JBR // Last Update: 2019-03-06 //\n*/\n\n(point, start_time, end_time) => do\n  \n  if(end_time - start_time > 6hr) do // want to do backfill on points\n  \n    if(point[\"tempBackFill\"] == null) do\n      syncNerscElasticSecondary(point, start_time, end_time, now(), true)\n    // end no tempBackFill\n    else if(point[\"tempBackFill\"] < start_time) do\n      syncNerscElasticSecondary(point, start_time, end_time, now(), true)\n    // end reset tempBackFill\n    else\n      syncNerscElasticSecondary(point, start_time, end_time, point[\"tempBackFill\"], false)\n  // end if > 6hr\n  else if( end_time - start_time <= 6hr ) do //do sync for last 6 hours\n    syncNerscElasticSecondary(point, start_time, end_time, now(), false)\n  // end if <= 6hr\n  end // end if-else\n  \nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB37LCWTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236cf112-7089a42a,\n             @p:lbnl:r:236a1b0a-da7d2f82,\n             @p:lbnl:r:236a1b0a-81386dee,\n             @p:lbnl:r:236a1b0a-215d001e,\n             @p:lbnl:r:236a1b0a-7ad51422,\n             @p:lbnl:r:236a1b0a-9c21e541,\n             @p:lbnl:r:236a1b0a-43514a9a,\n             @p:lbnl:r:236a1b0a-bda7c27d,\n             @p:lbnl:r:236a1b0a-f8f8811d,\n             @p:lbnl:r:236a1b0a-2b6a902e,\n             @p:lbnl:r:236a1b0a-551a2400,\n             @p:lbnl:r:236a1b0a-aa543963,\n             @p:lbnl:r:236a1b0a-ae30f482])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"backfillJaceToActualPointSimple",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function copies data from the JACE Backfill point to its\n corresponding permanent point in SkySpark.\n\n Arguments:\n backfillPt  The temporary JACE backfill point, which is found\n             under Links (meters) -> JACE -> Backfills. Should\n             be a pointRef.\n             \n actualPt    The permanent SkySpark point that we will be\n             adding the backfill into. Should be a pointRef\n \n multiplier  (Optional) The multiplier between the backfill and\n             the permanent SkySpark point. Default is 1.\n             Ex1: If the backfill value is 123,000 pulses and\n             the actual point is 123,000,000 BTU then the\n             multiplier is 1000\n             Ex2: If the backfill value is 4200 pulses and the\n             actual point is 2100 gal/min then the multiplier\n             is 0.5\n             (EDIT) The backfills now have a \"multiplier\" tag,\n             so this is no longer an input.\n \n // Sustainable Berkeley Lab // AMP // Last Update: 2020-03-04 //\n*/\n\n\n(backfillPt, actualPt) => do\n  // Check that unit and tz match.\n  if (backfillPt->unit != actualPt->unit or backfillPt->tz != actualPt->tz) return \"Unit or TZ does not match!\"\n  \n  // Get hisStart so we know what point to backfill up to.\n  try do\n    boundaryDate: actualPt->hisStart\n    end catch do\n      return \"Could not trap hisStart from actualPt\"\n    end\n  \n  // Load the history from the backfill from the beginning of the\n  // backfill (as far back as 2013-01-01) to the boundaryDate.\n  his: readById(backfillPt).hisRead(2013-01-01..boundaryDate,{limit:null}).hisClip\n  \n  // Get the multiplier between the two.\n  try do\n    multiplier: backfillPt->multiplier\n    end catch do\n      return \"Could not trap multiplier from backfillPt\"\n    end\n  \n  // Map the history from the backfill (in the variable \"his\") to\n  // the actual point.\n  his.map(r => {ts:r->ts, v0:r->v0*multiplier}).hisWrite(actualPt)\n  \n  ///////////////////////////////////////////////////\n  // The line that the above code is based off of: //\n  ///////////////////////////////////////////////////\n  //readById(backfillPt).hisRead(2013-01-01..boundaryDate,{limit:null}).map(r => {ts:r->ts, v0:r->v0}).hisWrite(readById(@actualPt))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"calculateVirtualMeter",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates history for a virtual meter point based on\n the meter formulas stored in the meterFormula tag in zinc format\n at the meter / equip level\n  \n Limitation: meter formula can only change at midnight local time\n Limitation: global adders LNC1 not properly managed for power vs energy\n  \n Arguments:\n restartDate (optional)   Date to rewrite history from. Must be\n                          a date, not a dateTime.\n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-06-20 //\n*/\n\n(restartDate:null, newOnly:true, interval:15min) => do\n  // Store today's date and points.\n  today: now().date\n  \n  filter: \"virtual and sensor and point \"\n        + \"and (power or (energy and delta)) \"\n        + \"and not hisFunc and not hidden \"\n        + \"and equipRef->meter and equipRef->virtual \"\n        + \"and equipRef->meterFormula\"\n  if (newOnly) filter= filter+ \" and not hisEnd\"\n  query: parseFilter(filter)\n  \n  ptList: readAll(query)\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  // Cycle through each point:\n  ptList.each ptInList => do\n    hisEnd: ptInList[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    aregument). Assign dates, clear history, and/or assign\n    hisEnd based on which of the 4 cases is presented\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input\n        hisClear(ptInList, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd.date..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Calculate.\n    // Determine point type (power or energy delta) and set filter tags and rollup function\n    if (ptInList.has(\"power\")) do\n      ptTags: \"power and equipRef->link\"\n      rollupFunc: avg\n    end\n    if (ptInList.has(\"energy\")) do\n      ptTags: \"energy and delta and equipRef->link\"\n      rollupFunc: sum\n    end\n    \n    // Load formulas from associated meter, sort so oldest formula comes first\n    formulas: ptInList->equipRef->meterFormula.ioReadZinc()\n                                         .toGrid()\n                                         .sort(\"startInclusive\")\n                                       \n    // Cycle through each formula, starting with the oldest and yield\n    // calculated values for requested dates on which a formula is valid\n    formulas.each formula => do\n    //formula: formulas[1]\n      // Latest formula will not have an end date,\n      // therefore if end date is missing, set end date to tomorrow\n      endExclusive: if (formula->endExclusive == \"\") today+1day\n                    else formula->endExclusive\n      \n      // Check if any of the requested dates fall within the formula's\n      // validity period; if not, skip to next formula\n      if (dates.start < endExclusive and dates.end >= formula->startInclusive) do\n\n        // Determine start and end dates of period for which history\n        // will be calculated using the current formula\n        startPeriod: [dates.start, formula->startInclusive].sort().last\n        endPeriod: [dates.end, endExclusive - 1day].sort().first\n        \n        // Create table of meters and multipliers from formula\n        meterOps: [0,1,2,3,4,5,6,7,8].toGrid.map((row, i) => do\n\n          // Check each meterX column, and parse it if not empty\n          if (formula[\"meter\"+i] != \"\") do\n\n            // Parse using regex\n            parsed: reGroups(\"\"\"(-?)(\\\\d{1,3}.\\\\d{1,2})\"\"\", formula[\"meter\"+i])\n            meterMult: if(parsed[1] == \"-\") -1 else 1\n            meterLink: parsed[2]\n\n            // Find point with the required tags that belongs to meter\n            // with the requested link tag\n            pointRec: parseFilter(ptTags)\n                      .readAll()\n                      .find ptInList => ptInList->equipRef->link == meterLink\n\n            // Store record to linked meter point, and corresponding multiplier\n            {meter: i, pointRec: pointRec, meterMult: meterMult}\n          end\n        end\n        )\n        // meterOps grid is complete, contains point records and multipliers\n        //return meterOps\n        // Get global adder and multiplier from formula, cast unit for adder\n        globalMult: formula->globalMult\n        globalAdder: formula->globalAdder.as(ptInList->unit)\n\n        // Create list of point records that are not null; we will need the\n        // histories from these points to calculate our virtual history\n        points: meterOps.colToList(\"pointRec\").findAll item => item != null\n        \n        // Load history for all required points, align timestamps and clip\n        histGrid: points.hisRead(startPeriod..endPeriod, {limit: null})\n                        .hisRollup(rollupFunc, interval)\n                        .hisClip()\n\n        // For each loaded timestamp, perform calculation of virtual history\n        // point and yield result\n        resultGrid: histGrid.map row => do\n\n          // Apply required multiplier to each point, and sum them all up\n          val: meterOps.colToList(\"meterMult\")\n                       .map((mult, i) => if(row[\"v\"+i] != null)\n                                           mult * row[\"v\"+i]\n                                         else\n                                           na()\n                           )\n                       .fold(sum)\n\n          // Apply global multiplier and adder\n          val = val*globalMult + globalAdder\n\n          // Test if any values were missing, and set value to null\n          // for this timestamp is missing any values (note that\n          // given that we interpolate, this only happens when missing\n          // trends at beginning or end of period)\n          \n\n          // Yield resulting history point\n          {ts: row->ts, v0: val}\n        end\n        \n        // Filter out redundant data and NA (already in history)\n        filteredGrid: resultGrid.findAll(row => row->ts > hisEnd\n                                                and row->v0 != na())\n        // Write calculated data to history.\n        hisWrite(filteredGrid, ptInList)\n        return {written: filteredGrid.size, status: \"OK\"}\n      end\n    end\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"weatherChartAirHum",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ptRefs, span, interval: null, nlimit: 50000) => do\n  ptsHis: ptRefs.hisRead(span, {limit: nlimit})\n  \n  if (interval == null) do \n    ptsHisRolled: ptsHis\n    rollupInfo: ptRefs.map ptRef => \" \"\n  end else do\n    ptsHisRolled: ptsHis.hisRollupAuto(interval)\n    rollupInfo: ptRefs.map ptRef => \" \"+readLink(ptRef)->hisRollupFunc+\" over \"+interval\n  end\n  \n  ptsHisRolled.addMeta({title: ptRefs[0]->weatherRef->dis+\": Air Humidity\"})\n    .addColMeta(\"v0\",{chartGroup: \"1\", \n                      color:\"black\", \n                      dis:readLink(ptRefs[0])->navName+rollupInfo[0]+\" (\"+readLink(ptRefs[0])->unit+\")\", \n                      chartType: \"line\"})\n    .addColMeta(\"v1\",{chartGroup: \"1\", \n                      color:\"darkturquoise\", \n                      dis:readLink(ptRefs[1])->navName+rollupInfo[1]+\" (\"+readLink(ptRefs[1])->unit+\")\", \n                      chartType: \"line\"})\n    .addColMeta(\"v2\",{chartGroup: \"1\", \n                      color:\"blue\", \n                      dis:readLink(ptRefs[2])->navName+rollupInfo[2]+\" (\"+readLink(ptRefs[2])->unit+\")\", \n                      chartType: \"line\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","bacnetObjConvert"],,,,M,,,,,,"bacnetAutocomplete",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site, location or equip, review all existing points under that\n  site / location / equip, and tak the following actions for each point:\n  - If bacnetConnRef or connRef are missing, skip point\n  - If bacnetCur is valid:\n  --- Load corresponding BACnet info from connector\n  ------ If bacnetCurName is missing or bacnetCurNameOverride is true, fill out\n         point's bacnetCurName tag using BACnet OBJECT_NAME\n  ------ If unit is missing or unitOverride is true, fill out\n         point's unit tag using BACnet UNITS and io/config/bacnet_units.csv\n  ------ If bacnetDesc is missing or bacnetDescOverride is true, fill out\n         point's bacnetDesc using BACnet DESCRIPTION\n  -If bacnetHis is missing or bacnetHisOverride is true, search trend log\n   objects on same connector for a match in LOG_DEVICE_OBJECT_PROPERTY\n   ->value->objId and fill out point's bacnetHis accordingly\n  -If bacnetHis is valid:\n  --- Load corresponding BACnet info from connector\n  ------ If bacnetHisName is missing or bacnetHisNameOverride is true, fill out\n         point's bacnetHisName tag using BACnet OBJECT_NAME\n  \n  Only commit changes is finalize is true, otherwise just return table showing\n  existing and proposed values.\n  \n  connNumber allows to limit the process to one given connector.\n  \n  Could add additional actions, e.g. fill out tags based on navName, etc.\n  \n  Arguments: \n  startRef        Ref or site / location / equip whose points to autocomplete\n  connNumber      Number, if not null limits the process to #th connector\n  finalize        Bool, if true, commit changes\n  unitOverride\n  bacnetCurNameOverride\n  bacnetDescOverride\n  bacnetHisOverride\n  bacnetHisNameOverride\n*/\n\n(startRef: null, connNumber:null, finalize:false, unitOverride:false,\n bacnetCurNameOverride:true, bacnetDescOverride:true, bacnetHisOverride:true,\n bacnetHisNameOverride:true\n) => do\n  // Load dependencies\n  try bacnetUnits: ioReadCsv(`io/config/bacnet_units.csv`)\n  catch\n    return {error: \"io/config/bacnet_units.csv could not be loaded\"}.toGrid()\n\n  try curNameTohisName: ioReadCsv(`io/config/curName_hisName.csv`)\n                        .colToList(\"regex\")\n  catch\n    return {error: \"io/config/curName_hisName.csv could not be loaded\"}.toGrid()\n\n  // Load points list\n  try\n    start: readById(startRef)\n  catch\n    return {error: \"startRef not valid\"}.toGrid()\n    \n  if (start.has(\"site\"))\n    points: readAll(point and not virtual and siteRef==startRef)\n  else if (start.has(\"location\"))\n    points: readAll(point and not virtual and locationRef==startRef)\n  else if (start.has(\"equip\"))\n    points: toolRecursiveSearch(startRef, \"point and not virtual\")\n  else return {error: \"startRef not valid\"}.toGrid()\n  \n  if (isEmpty(points)) return {error: \"No points found\"}.toGrid()\n  \n  // Search and record all trend objects from listed connectors\n  connectors: points.colToList(\"bacnetConnRef\").unique()\n                    .sort((a,b) => a->id <=> b->id)\n  // Use only given connector number if provided (to limit runtime)\n  if (connNumber != null) connectors= try connectors[connNumber-1..connNumber-1]\n                                      catch connectors\n  bacnetTrends: connectors\n      .map(co =>\n          {bacnetConnRef:co,\n           // For each trend log, map LOG_DEVICE_OBJECT_PROPERTY\n           objects: bacnetLearn(co, 20)\n                    .map(tl => do\n                        detailedObj: try bacnetReadObject(co, tl[\"bacnetHis\"])\n                                     catch {}.toGrid()\n                        curProp: detailedObj.find(row =>\n                            row[\"propertyName\"]==\"LOG_DEVICE_OBJECT_PROPERTY\")\n                        if (curProp==null) return tl\n                        if (curProp[\"value\"]==null) return tl\n                        return tl.set(\"bacnetCur\",curProp[\"value\"][\"objId\"]\n                                                  .bacnetObjConvert())\n                    end)\n          }) \n  \n  // Cycle through points and create summary table with pre / post info\n  points= points\n    .keepCols([\"id\",\"bacnetConnRef\",\"bacnetCur\",\"bacnetCurName\",\n                   \"bacnetHis\",\"bacnetHisName\",\"bacnetDesc\",\"connRef\",\n                   \"unit\"])\n    .map(pt => do\n    // Initialize change dictionary\n    changes: {}\n    \n    // If bacnetConnRef or connRef are missing, skip point\n    if (pt[\"bacnetConnRef\"]==null or pt[\"connRef\"]==null)\n      return pt\n    \n    // If bacnetCur is valid, research related BACnet info\n    bacnetCurObject: try bacnetReadObject(pt[\"bacnetConnRef\"], pt[\"bacnetCur\"])\n                     catch {}.toGrid()\n    if (not(isEmpty(bacnetCurObject))) do\n      // bacnetCurName is missing or bacnetCurNameOverride is true\n      if (bacnetCurNameOverride or pt[\"bacnetCurName\"]==null\n                                or pt[\"bacnetCurName\"]==\"\") do\n        // Retrieve BACnet OBJECT_NAME\n        objName: bacnetCurObject.find(row => row[\"propertyName\"]==\"OBJECT_NAME\")\n        if (objName != null) do\n          objName= objName[\"value\"]\n          pt= pt.set(\"bacnetCurName_New\",\n                     if (objName==pt[\"bacnetCurName\"]) \"No Change\"\n                     else objName)\n          changes= changes.set(\"bacnetCurName\", objName)\n        end\n      end\n      \n      // bacnetDesc is missing or bacnetDescOverride is true\n      if (bacnetDescOverride or pt[\"bacnetDesc\"]==null\n                                or pt[\"bacnetDesc\"]==\"\") do\n        // Retrieve BACnet DESCRIPTION\n        objDesc: bacnetCurObject.find(row => row[\"propertyName\"]==\"DESCRIPTION\")\n        if (objDesc != null) do\n          objDesc= objDesc[\"value\"]\n          pt= pt.set(\"bacnetDesc_New\",\n                     if (objDesc==pt[\"bacnetDesc\"]) \"No Change\"\n                     else objDesc)\n          changes= changes.set(\"bacnetDesc\", objDesc)\n        end\n      end\n      \n      // unit is missing or unitOverride is true\n      if (readById(pt->id)[\"kind\"]==\"Number\"\n          and (unitOverride or pt[\"unit\"]==null or pt[\"unit\"]==\"\")) do\n        // Retrieve BACnet UNITS\n        objUnit: bacnetCurObject.find(row => row[\"propertyName\"]==\"UNITS\")\n        if (objUnit != null) do\n          objUnit= objUnit[\"value\"].toStr()\n          // Match with record of BACnet units\n          unit: bacnetUnits.find(row => row[\"val\"]==objUnit)\n          if (unit!=null) unit= unit[\"unit\"]\n          pt= pt.set(\"unit_New\",\n                     if (unit==pt[\"unit\"]) \"No Change\"\n                     else unit)\n          changes= changes.set(\"unit\", unit)\n        end\n      end\n    end // If bacnetCur is valid\n      \n    // bacnetHis is missing or bacnetHisOverride is true,\n    // bacnetCur or bacnetCurName can be used for matching\n    if ((pt[\"bacnetCur\"]!=null or pt[\"bacnetCurName\"]!=null)\n        and (bacnetHisOverride or pt[\"bacnetHis\"]==null\n             or pt[\"bacnetHis\"]==\"\")) do\n      // Attempt to match a trend object to available bacnetCur\n      // Load table of trends associated with point's connector\n      trends: bacnetTrends\n              .find(row => row[\"bacnetConnRef\"]==pt[\"bacnetConnRef\"])\n      if (trends==null) trends= {}.toGrid else trends= trends[\"objects\"]\n      \n      // Attempt match on bacnetCur or bacnetCurName\n      trendMatches: trends.findAll(row => do\n        if ((row[\"bacnetCur\"] != null) and (row[\"bacnetCur\"]==pt[\"bacnetCur\"]))\n          return true\n        regexMatch: false\n        // bacnetCurName matches use a config file where regular expressions\n        // are defined to run on \"bacnetCurName:bacnetHisName\"\n        curNameTohisName.each(regex =>\n            if (regex.reMatches(pt[\"bacnetCurName\"]+\":\"+row[\"dis\"]))\n              regexMatch= true\n        )\n        return regexMatch\n      end)\n      \n      // Pick first matched trend object\n      if (not(isEmpty(trendMatches))) trend: trendMatches.first[\"bacnetHis\"]\n      else trend: null\n      pt= pt.set(\"bacnetHis_New\",\n                 if (trend==pt[\"bacnetHis\"]) \"No Change\"\n                 else trend)\n      changes= changes.set(\"bacnetHis\", trend)\n      \n      // Display list of additional matches\n      if (size(trendMatches) > 1)\n        pt= pt.set(\"bacnetHis_Others\",\n                   trendMatches.colToList(\"bacnetHis\")[1..-1].concat(\", \"))\n      \n    end // bacnetHis from bacnetCur or bacnetCurName\n    \n    // If bacnetHis is valid, research related BACnet info\n    bacnetHis: if (changes[\"bacnetHis\"] != null) changes[\"bacnetHis\"]\n               else pt[\"bacnetHis\"]\n    bacnetHisObject: try bacnetReadObject(pt[\"bacnetConnRef\"], bacnetHis)\n                     catch {}.toGrid()\n    if (not(isEmpty(bacnetHisObject))) do\n      // bacnetHisName is missing or bacnetHisNameOverride is true\n      if (bacnetHisNameOverride or pt[\"bacnetHisName\"]==null\n                                or pt[\"bacnetHisName\"]==\"\") do\n        // Retrieve BACnet OBJECT_NAME\n        hisObjName: bacnetHisObject.find(row => row[\"propertyName\"]==\"OBJECT_NAME\")\n        if (hisObjName != null) do\n          hisObjName= hisObjName[\"value\"]\n          pt= pt.set(\"bacnetHisName_New\",\n                     if (hisObjName==pt[\"bacnetHisName\"]) \"No Change\"\n                     else hisObjName)\n          changes= changes.set(\"bacnetHisName\", hisObjName)\n        end\n      end\n    end\n    \n    changes= diff(readById(pt->id), changes)\n    pt= pt.set(\"changes\", changes)\n    return pt\n  end)\n  \n  if (finalize)\n    points.each pt => if (pt[\"changes\"] != null) commit(pt->changes)\n  \n  return points.reorderCols(points.colNames.sort((a,b) => a <=> b)\n                                           .moveTo(\"id\", 0)\n                                           .moveTo(\"changes\", -1))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viAhuEconScatter",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find AHU data points related to the given AHU economizer.\n  Load and display historical data for all these points across\n  the given date span as a scatter plot.\n  \n  Arguments: \n  ahuRef       ref, id of the AHU\n  dates        dateSpan, dates of data to display\n*/\n\n(ahuRef, dates: yesterday(), oatRef:null, filterPtRef:null, rollup:10min, test:false) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n   \n  // Retrieve AHU OAT or weather station OAT\n  if (oatRef==null)\n    oat: read(point and outside and air and temp and sensor\n              and equipRef==ahuRef, false)\n  else oat: readById(oatRef)\n  if(oat==null) oat= read(weatherPoint and main and air and temp)\n  // Format\n  oat= oat.set(\"color\", \"limeGreen\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU RAT\n  rat: read(point and \"return\" and air and temp and sensor\n            and equipRef==ahuRef, false)\n  if(rat==null) rat={}\n  // Format\n  rat= rat.set(\"color\", \"orange\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU SAT\n  sat: read(point and discharge and air and temp and sensor\n            and equipRef==ahuRef, false)\n  if(sat==null) sat={}\n  // Format\n  sat= sat.set(\"color\", \"royalBlue\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU MAT\n  mat: read(point and (mixed or recovery) and air and temp and sensor\n            and equipRef==ahuRef, false)\n  if(mat==null) mat={}\n  // Format\n  mat= mat.set(\"color\", \"purple\")\n          .set(\"chartType\", \"scatter\")\n          .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU SAT SP\n  satsp: read(point and discharge and air and temp and sp\n              and equipRef==ahuRef, false)\n  if(satsp==null) satsp={}\n  // Format\n  satsp= satsp.set(\"color\", \"lightGrey\")\n              .set(\"chartType\", \"scatter\")\n              .set(\"chartGroup\", \"temp\")\n  \n  // Retrieve AHU CHW valve command\n  chwv: read(point and cool and valve and cmd\n             and equipRef==ahuRef, false)\n  if(chwv==null) chwv={}\n  // Format\n  chwv= chwv.set(\"color\", \"cyan\")\n            .set(\"chartType\", \"scatter\")\n            .set(\"chartGroup\", \"pos\")\n  \n  // Retrieve AHU HHW valve command\n  hhwv: read(point and heat and valve and cmd\n             and equipRef==ahuRef, false)\n  if(hhwv==null) hhwv={}\n  // Format\n  hhwv= hhwv.set(\"color\", \"red\")\n            .set(\"chartType\", \"scatter\")\n            .set(\"chartGroup\", \"pos\")\n            \n  // Retrieve AHU economizer damper command\n  econ: read(point and outside and air and damper and cmd\n             and equipRef==ahuRef, false)\n  if(econ==null) econ={}\n  // Format\n  econ= econ.set(\"color\", \"black\")\n            .set(\"chartType\", \"scatter\")\n            .set(\"chartGroup\", \"pos\")\n            \n  // Filter point\n  if (filterPtRef==null)\n      filterPt: read(point and run and sensor\n                     and equipRef==ahuRef, false)\n  else filterPt: readById(filterPt)\n  \n  if (filterPt==null) filterPt={}\n  \n  if (test) return [oat, filterPt, oat, mat, rat, sat, satsp, chwv, hhwv, econ]\n  \n  // Assemble points, read history, prepare scatter\n  his: [oat, filterPt, oat, mat, rat, sat, satsp, chwv, hhwv, econ]\n       .hisRead(dates, {limit:null})\n       .hisInterpolate()\n       .findAll(row => if (row[\"v1\"] != null and not(isEmpty(filterPt)))\n                         row[\"v1\"] else true)\n       .removeCols([\"v1\"])\n       \n  if (rollup>0)\n    his= his.hisRollup(avg, rollup)\n  \n  his=his.removeCols([\"ts\"])\n       \n  // Return\n  return his\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74Conn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with location, uri, device, and vav number,\n  and create corresponding bacnet connectors\n*/\n\n() => do\n  ioReadCsv(`io/integration_b74/vav_equip.csv`)\n  .each row => do\n    siteDis: \"74\"\n    floorDis: row[\"floor\"]\n    locationDis: \"B74 Floor \" + floorDis\n    vavNum: reGroups(\"74-VAV-(\\\\d\\\\d\\\\d)\",row[\"vav\"])[1]\n    deviceID: row[\"deviceID\"]\n    uriText: row[\"bacnetAddress\"]\n    uri: parseUri(uriText)\n    \n    disText: siteDis + \" Floor \" + floorDis \n             + \" - ZN - VAV-\" + vavNum\n             + \" - Device \" + deviceID\n    \n    exist: readAll(conn and bacnetConn and uri==uri)\n    \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {dis: disText,\n         uri: uri,\n         conn,\n         bacnetConn,\n         siteRef: read(site and dis==siteDis)->id,\n         tmp\n        },\n        {add}\n      ))\n    end\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["deficiencyHasResponses","toolFormatGrid"],,,,M,,,,,,"viDeficienciesList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a table of deficiencies formatted for display.\n  \n  Arguments: \n  siteRef             Ref<site>, siteRef filter\n  deficiencyGroupRef  Ref<deficiencyGroup>, group filter\n  state               Str, state filter, can be \"Any\", \"Active\", \"Not Closed\"\n                      or any specific deficiency state string\n  sprintRefs          Ref<sprint>[], sprintRef filter\n  assignedTo          Str, assignedTo filter, can be \"\"\n  filter              Str, filter on deficiency dis and group dis, case insensitive\n*/\n\n(siteRef, deficiencyGroupRef:null, state:\"Any\", sprintRefs:null, assignedTo:\"\", filter:\"\") => do\n  // Determine current and previous sprints\n  sortedSpr: readAll(sprint)\n             .sortr((a,b) => a->sprint <=> b->sprint)\n  currentSpr: sortedSpr[0]\n  previousSpr: sortedSpr[1]\n  // Process sprintRefs\n  if (sprintRefs != null)\n    sprintRefs= sprintRefs\n    .map(sId => if (readById(sId)->sprint==-1) previousSpr->id\n                else if (readById(sId)->sprint==0) currentSpr->id\n                else sId)\n\n// Build title\n  title: \"\"\n  if (deficiencyGroupRef!=null)\n    title= title+readById(deficiencyGroupRef).dis()+\" deficiencies \"\n  else title= title+\"Deficiencies \"\n  title= title+\"(\" + state + \")\"\n  if (assignedTo!=\"\" and assignedTo!=\"Any\")\n    title= title + \", for \" + assignedTo\n  if (sprintRefs!=null) do\n    sprintNums: sprintRefs.map(v => readById(v)->sprint.toStr)\n    if (sprintNums.size > 1) title= title + \", Sprints \"\n    else title= title + \", Sprint \"\n    title= title+ sprintNums.concat(\", \")\n  end\n  if (siteRef!=null) do\n    prefix: if (parseNumber(readById(siteRef).dis,false)!=null) \"B\" else \"\"\n    title= title + \", \" + prefix + readById(siteRef).dis\n  end\n\n  // Initialize grid\n  grid: if(siteRef==null)\n          readAll(deficiency)\n        else\n          readAll(deficiency and siteRef==siteRef)\n  \n  // Escape if no deficiencies are found, to avoid grid manipulation errors\n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n  \n  // Apply deficiency group filter\n  grid= grid.findAll(row => if(deficiencyGroupRef==null) true\n                            else row[\"deficiencyGroupRef\"]==deficiencyGroupRef)\n  \n  // Apply deficiency state filter\n  grid= grid.findAll(row => if(state==\"Any\") true\n                            else if(state==\"Active\")\n                              [\"To Do\",\"In Progress\"].contains(row->state)\n                            else if(state==\"Not Closed\")\n                              not([\"Closed\",\"Abandoned\"].contains(row->state))\n                            else row->state==state)\n  \n  // Apply deficiency sprint filter\n  grid= grid.findAll(row => if(sprintRefs==null) true\n                            else sprintRefs.contains(row[\"sprintRef\"]))\n  \n  // Apply deficiency assignment filter\n  grid= grid.findAll(row =>\n      if (assignedTo==\"\") return true\n      else if (row[\"assignedTo\"]==null) false\n           // regex with ?i flag is NOT case sensitive\n           else reMatches(\"(?i).*\"+assignedTo+\".*\", row[\"assignedTo\"]))\n  \n  // Apply deficiency display name + group display name filter\n  grid= grid.findAll(row => do\n    groupDis: if(row[\"deficiencyGroupRef\"]!=null)\n                readById(row[\"deficiencyGroupRef\"]).dis()\n              else \"\"\n    // regex with ?i flag is NOT case sensitive\n    return reMatches(\"(?i).*\"+filter+\".*\", row.dis() + groupDis)\n  end)\n                \n  if(isEmpty(grid)) return {dis:\"None\"}.toGrid()\n                                       .addColMeta(\"dis\", {dis: title})\n  \n  // Add responses column\n  grid= grid.addCol(\"hasResponses\", row => do\n    if(deficiencyHasResponses(row->id, userCur()->dis)) return marker()\n    else return null\n  end)\n  \n  // Add deficiencyRef (hidden) for note creation action\n  grid= grid.addCol(\"deficiencyRef\", row => row->id)\n  \n  // Convert mod to Los_Angeles tz\n  grid= grid.map(row => row.map((v,n) => if (n==\"mod\") v.toTimeZone(\"Los_Angeles\") else v))\n  \n  // Add title as id column display name\n  grid= grid.addColMeta(\"id\", {dis:title})\n  \n  // Add link column\n  grid= grid.addCol(\"link\", row => uiLink({view: \"deficiencyView\",\n                                           state:{deficiencyRef:row->id}}))\n  \n  disCols: [\"id\",\"state\",\"sprintRef\",\"size\",\"assignedTo\",\n            \"energyValue\",\"operationalValue\",\"priority\",\n            \"startDate\",\"endDate\",\"hasResponses\",\n            \"deficiencyGroupRef\",\"link\"]\n  if (userCur()->username==\"raphaelVitti\")\n    disCols= disCols.addAll([\"createdBy\",\"createdOn\",\"lastModifiedBy\",\"mod\"])\n  \n  return grid.toolFormatGrid(disCols)\n             .sort((a,b) => a.dis() <=> b.dis())\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB06ExpHallZone18TempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readAll((id==@p:lbnl:r:2438f755-510d16ad or\n           id==@p:lbnl:r:234ab398-bc4979b0 or\n           id==@p:lbnl:r:234ab3a7-8b8e8eb7 or\n           id==@p:lbnl:r:234ab421-9dc97efd or\n           id==@p:lbnl:r:234ab42b-8a2ab796 or\n           id==@p:lbnl:r:234ab43d-b586139d or\n           id==@p:lbnl:r:234ab451-24431589\n         ) or (\n           equipRef==@p:lbnl:r:234a66bc-9666b982 and (\n             valve or temp or (outside and air and damper)\n           )\n         ))\n  .hisRead(span, {limit:limit})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap67VAVSupplyDmprCmd",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  siteId: read(site and dis==\"Building 67\")->id\n\n  readAll(conn and bacnetConn and siteRef==siteId)\n  .each co => do\n    // Read all the bacnet points that match the following conditions\n    objList: bacnetLearn(co->id,`ANALOG_INPUT`)\n            .findAll(row => (row.has(\"dis\") and (row->dis.endsWith(\".SUPDPR-CMD\") or\n                     row->dis.endsWith(\".DMPRPOS\") or\n                     row->dis.endsWith(\".SUPDPRCMD\"))))\n                     \n    // For each point, determine the controller name. If a vav is found in skyspark\n    // associated with that controller, then integrate the point.\n    objList.each obj => do\n      controllerStr: reGroups(r\"\\.([^.]*)\\.\", obj->dis)[1]\n      zoneGroups: reGroups(r\"\\.ZA([12])T\", obj->dis)\n      if (zoneGroups == null) do\n        vav: read(siteRef==siteId and equip and vav and \n                  controller==controllerStr, false)\n      else do\n        zoneStr: zoneGroups[1]\n        vav: read(siteRef==siteId and equip and vav and \n                  untController==controllerStr and\n                  untZone==zoneStr, false)\n      end\n\n      if (vav != null) do\n        vavId: vav->id\n        \n        // Check if Zone Temperature point already exists for this vav\n        pt: read(equipRef==vavId and supply and damper and cmd, false)\n        if (pt == null) do    // Create new point\n          commit(diff(\n            null,\n            {navName: \"Supply Damper Command\",\n             supply,\n             damper,\n             cmd,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: co->id,\n             bacnetCur: obj->bacnetCur,\n             bacnetName: obj->dis,\n             connRef: co->id,\n             equipRef: vavId,\n             his,\n             hisCollectInterval: 15min,\n             kind: obj->kind,\n             point,\n             locationRef: vav->locationRef->id,\n             siteRef: siteId,\n             tmpTest201805112,\n             tz: \"Los_Angeles\",\n             unit: obj->unit,\n            },\n            {add}\n          ))\n        end\n        \n        // Add bacnetHis if available\n        if (obj.has(\"bacnetHis\")) do\n          pt= read(equipRef==vavId and supply and damper and cmd, true)\n          commit(diff(\n            pt,\n            {bacnetHis: obj->bacnetHis, -hisCollectInterval}\n          ))\n          // Synchronize with trend if history has never been collected,\n          // If history exists, then the recurring sync job will take care of it.\n          if (not(pt.has(hisEnd))) bacnetSyncHis(pt, pastMonth)\n        end\n      end\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"userChartTest",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  defaultAhuRef: @p:lbnl:r:21276393-04d06b7b\n  displayAhuRef: userCur()[\"preferredAhuRef\"]\n  if (displayAhuRef == null) displayAhuRef = defaultAhuRef\n  hisGrid: readAll(zone and air and temp and equipRef==displayAhuRef)\n    .hisRead(today)\n  \n  disMin: hisGrid.hisFoldCols(min).foldCol(\"v0\", min) - 1\n  disMax: hisGrid.hisFoldCols(max).foldCol(\"v0\", max) + 1\n  \n  \n  hisGrid.addColMeta(\"v0\",{chartMin: disMin,chartMax: disMax})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"anReadMeterMonthly",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, load monthlyRead records or calculate sums, calculate\n  number of days per period and average daily consumption.\n  \n  Arguments: \n  meterRef          Target id\n  hddBase           Temperature used as base / reference for HDD calculations\n  cddBase           Temperature used as base / reference for CDD calculations\n  disregardIgnore   Bool, if true show Skipped and Nonroutine readings. Replaced\n                    readings are alwys removed regardless.\n*/\n(meterRef, hddBase:65°F, cddBase:55°F, disregardIgnore:false) => do\n  // Variables\n  prevDate: null\n  \n  meter: if (isRef(meterRef)) readById(meterRef) else meterRef\n  meterId: meter->id\n  weatherId: meter->siteRef->weatherRef\n  \n  // Process SUM meters\n  if (meter.has(\"sblids\")) do\n    tagU: if (meter.has(\"gas\")) \"gas\" else \"elec\"\n    tUnit: if (meter.has(\"gas\")) \"therm\" else \"kWh\"\n    grid: {}.toGrid()\n    g: readAll(monthlyRead)\n       .findAll(mR => do\n         mRMeter: readById(mR->meterRef)\n         return (mRMeter.has(tagU) and mRMeter.has(\"sblid\") and meter->sblids.split(\",\").contains(mRMeter->sblid))\n         end)\n    g.colToList(\"readDate\").unique()\n    .each(rD => do\n      subG: g.findAll(r => r->readDate==rD)\n      if (subG.all(r => (r[\"ignore\"] == null or disregardIgnore) and r[\"consumption\"]!=null))\n        grid= grid.addRow({readDate: rD, consumption:subG.foldCol(\"consumption\", sum)})\n      else\n        grid= grid.addRow({readDate: rD, consumption:0.as(tUnit), ignore:\"Incomplete\"})\n    end)\n    \n    grid= grid.sort((a,b) => a->readDate <=> b->readDate)\n  \n  // Regular meters\n  end else do  \n    // Load records associated with meter\n    grid: readAll(monthlyRead and meterRef==meterId)\n    .sort((a,b) => a->readDate <=> b->readDate)\n  \n    // Replaced readings are always removed\n    grid= grid.findAll(\n      r => r.missing(\"ignore\") or not(reMatches(r\"(?i)Replaced.*\", r[\"ignore\"])))\n\n    // Remove ignore:Skipped readings here so number of days is calculated based \n    // on previous valid reading\n    if (not(disregardIgnore))\n      grid= grid.findAll(\n        r => r.missing(\"ignore\") or not(reMatches(r\"(?i)Skipped.*\", r[\"ignore\"])))\n  end\n \n  // Exit if empty grid\n  if (grid.size < 1)\n    return {dis:\"No valid monthly readings available for \"+meter.dis, err}.toGrid()\n\n  grid= grid\n  // Add consumption == cons for backwards compatibility\n  .addCol(\"cons\", r => r->consumption)\n  // Add number of days per reading period\n  .addCol(\"countDays\", r => do\n    days: if (prevDate != null) r->readDate - prevDate\n          else null\n    prevDate= r->readDate\n    return days\n  end)\n  \n  // Add HDD / CDD\n  [\"heat\",\"cool\"].each dd => do\n    prevDate= null\n    grid= grid.addCol(dd, r => do\n      v: if (prevDate != null)\n           readById(weatherId)\n           .degreeDays(prevDate..r->readDate-1day, {heat:hddBase,cool:cddBase})\n           .foldCol(dd, sum)\n         else null\n      prevDate= r->readDate\n      return v / r[\"countDays\"]\n    end)\n  end\n  \n  // Add consumption per day to grid\n  grid= grid\n  .addCol(\"consumptionPerDay\", r => if (r.has(\"ignore\") and not(disregardIgnore)) null\n                                    else r[\"consumption\"] / r[\"countDays\"])\n  \n  // Remove rows without a day count (typically only the first row)\n  .findAll(r => r.has(\"countDays\"))\n  // Reorder columns\n  .toolFormatGrid([\"readDate\",\"countDays\",\"consumptionPerDay\",\"cons\",\"ignore\"]) \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["facZoneHtgReqIgnoresNow"],,,,M,,,,,,"facAhuHtgReqIgnoresNow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, scan all zones for heating requests to ignore and\n  return one calculated value of total number of heating requests\n  to ignore now.\n  See:\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  ahuRef       Id of an ahu equip\n  reqTime      Time, duration a zone request is valid\n  disqualTime  Time, duration a spark disqualifies the zone requests\n  fixedIgnores Added fixed number of requests to ignore to avoid having a system\n               driven by just a few zones\n*/\n(ahuRef, reqTime: 30min, disqualTime: 24h, fixedIgnores:4) => do\n  // Normalization\n  ahuId: if (isRef(ahuRef)) ahuRef else ahuRef->id\n  ahu: readById(ahuId)\n  \n  // Locate all zones served by the AHU\n  tus: readAll(terminalUnit and equip and ahuRef==ahuId)\n  zones: tus.colToList(\"equipRef\")\n            .unique\n            .findAll(v => readById(v).has(\"zone\"))\n  \n  // Combine ignored requests from all zones\n  ignores: zones.map(z => facZoneHtgReqIgnoresNow(z, reqTime, disqualTime))\n                .findAll(v => v != null)\n  \n  // Return sum\n  return (ignores.fold(sum) + fixedIgnores)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldHisDiffMax",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, ts, acc) => do\n  if (val == foldStart()) return {vlast:na(), dmax: 0}\n  if (val == foldEnd()) return acc->dmax\n  if (val == na()) return na()\n  \n  if (acc->vlast == na()) return {vlast: val, dmax: 0}\n  return {vlast: val,\n          dmax: max(acc->dmax, (val - acc->vlast))}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Elec Power (kW)",,M,"Site electrical 15-minute average demand min, max, average over time period.",,,"site",,"kpiElecPower",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(power and sensor and equipRef->elec and \n           equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisRollup(avg, 15min)\n  \n  if (his.isEmpty or\n      his.meta[\"hisEnd\"] < pt[\"hisStart\"] or\n      his.missing(\"v0\")) return null\n\n  kpi: {min: his.foldCol(\"v0\", min),\n        max: his.foldCol(\"v0\", max),\n        avg: his.foldCol(\"v0\", avg)}\n\n  if (kpi.any v => na() == v ) null else kpi.map v => v.as(1)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolRecsTags",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given grid of records, filter out tags that match the\n  ignoreTags list and return the remaining tags\n  \n  Arguments: \n  points            Grid of records or list or Refs of the points\n*/\n\n(recs, ignoreTags:null) => do\n  // Load dependencies if necessary\n  if (ignoreTags==null)\n    try ignoreTags= ioReadCsv(`io/config/ignoreTags.csv`)\n                    .colToList(\"ignoreTagsRegex\")\n    catch\n      return {error: \"io/config/ignoreTags.csv could not be loaded\"}.toGrid()\n\n  if (not(isList(ignoreTags)))\n    return {error: \"ignoreTags should be a list of regex\"}.toGrid()\n\n  // Cycle through each point\n  recsTags: recs.map rec => do\n    // If list of Refs was provided, load record\n    if (isRef(rec))\n      try pt= readById(rec)\n      catch return {id: rec}\n    \n    if (not(isDict(rec)))\n      return null\n    \n    // Return only tags that do not match ignoreTags regex's\n    allTags: rec.findAll(v => v != null).names()\n    filteredTags: allTags.findAll(tag => do\n          regexMatch: false\n          ignoreTags.each regex =>\n              if (regex.reMatches(tag)) regexMatch= true\n          return not(regexMatch)\n        end)\n    \n    dict: {id: rec->id}\n    filteredTags.each tag => dict= dict.set(tag, marker())\n    return dict\n  end\n  \n  return recsTags\n         .reorderCols(recsTags.colNames.sort((a,b) => a <=> b)\n                              .moveTo(\"id\", 0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ruSensorOoRange",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n\n This function returns a grid of periods an equip has a sensor that returns\n out-of-range readings or uses an unexpected unit.\n Currently the following sensors are being tested:\n - air and temp - allowed range -20°F - 120°F\n - water and temp - allowed range 20°F - 200°F\n \n Arguments:\n equip           equip record of equip to test\n span            dateSpan, span of dates to run analysis on\n minTime         duration, filter out periods shorter than minTime\n mergePeriod     duration, merge flagged periods separated by less than\n                 mergePeriod\n*/\n\n(equip:readById(@p:lbnl:r:2324cceb-e30a4c1a), span:pastWeek(),\n minTime: 30min, mergePeriod: 15min) => do\n  // Allowed ranges and units\n  rangeAirTemp: [-20°F, 120°F]\n  rangeWaterTemp: [20°F, 200°F]\n  unitsTemp: [\"°F\", \"°C\", \"K\"]\n  \n  // Test air temp sensors\n  fAirTemp: readAll(air and temp and sensor and not virtual\n                    and equipRef==equip->id)\n            .hisRead(span)\n            \n  if (not(isEmpty(fAirTemp))) do\n    fAirTemp= fAirTemp\n        .hisInterpolate()\n        .hisClip()\n        .hisMap(v => if (v == null or v == na()) false\n                     else if (not(unitsTemp.contains(unit(v)))) true\n                     else if (v.to(\"°F\") < rangeAirTemp[0]\n                              or v.to(\"°F\") > rangeAirTemp[1]) true\n                     else false)\n        .map(row => {ts: row->ts,\n                     v0: any(row.remove(\"ts\"), v => v)})\n        .hisFindPeriods(v => v)\n  end\n  \n  if (isEmpty(fAirTemp)) fAirTemp= null\n\n  // Test water temp sensors\n  fWaterTemp: readAll(water and temp and sensor and not virtual\n                      and equipRef==equip->id)\n              .hisRead(span)\n              \n  if (not(isEmpty(fWaterTemp))) do\n    fWaterTemp= fWaterTemp\n        .hisInterpolate()\n        .hisClip()\n        .hisMap(v => if (v == null or v == na()) false\n                     else if (not(unitsTemp.contains(unit(v)))) true\n                     else if (v.to(\"°F\") < rangeWaterTemp[0]\n                              or v.to(\"°F\") > rangeWaterTemp[1]) true\n                     else false)\n        .map(row => {ts: row->ts,\n                     v0: any(row.remove(\"ts\"), v => v)})\n        .hisFindPeriods(v => v)\n  end\n  \n  if (isEmpty(fWaterTemp)) fWaterTemp= null\n\n  // Join grids\n  flagPeriods: hisPeriodUnion([fAirTemp, fWaterTemp])\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->v0 >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip.dis() + \" has one or more sensors out of range\"\n  return flagPeriods.addColMeta(\"v0\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viSystemPowerAndWetBulb",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return trends of total CT Fan Power, CW Pump Power, TW Pump Power and\n  OA WB Temp (in °F) data at B59\n*/\n\n(dateRange: toDateSpan(2019-06-01..2019-09-01),\n minCompPower: null, maxCompPower: null,\n rollup:15min, suffix:\"\") => do\n  // Default to B59 for siteRef\n  bldgRef: read(site and dis==\"59\")\n  bldgRefId: bldgRef->id\n   \n  // Look up B59 Data Center compute power, used later for filtering\n  totalCompRef: read(locationRef->dis==\"B59 Data Center\"\n                     and superComputer and navName==\"Computers\")->id\n  totalCompMeterRef: read(meter and compute and equipRef==totalCompRef)->id\n  totalCompPower: read(power and sensor and point and equipRef==totalCompMeterRef)\n\n  // Get the reference for the TW and CW Plants\n  trwPlantEquip: read(siteRef==bldgRefId\n                      and equip\n                      and treatedWaterPlant\n                      and navName == \"Plant\")\n  \n  twPlantEquip: read(siteRef==bldgRefId\n                     and equip\n                     and condenserWaterPlant\n                     and navName == \"Plant\")\n                    \n  //wetbulb temperature (defaulting to the same location as the default)\n  wbTemp: read(equipRef==twPlantEquip->id and outside and point and sensor and wetBulb)\n          .hisRead(dateRange, {limit:null})\n          .toolHisAlign(avg, min, true, rollup)\n          .renameCol(\"v0\",\"oaWetBulb\")\n\n  // Get the power points for the TW pumps, CT Fans, and CW Pumps\n  twPumpPowers: readAll(locationRef==twPlantEquip->locationRef\n                        and equipRef->pump\n                        and power\n                        and sensor)\n  \n  ctFanPowers: readAll(locationRef==twPlantEquip->locationRef\n                       and equipRef->fan\n                       and power\n                       and sensor)\n  \n  trwPumpPowers: readAll(locationRef==trwPlantEquip->locationRef\n                         and equipRef->pump\n                         and power\n                         and sensor)\n  \n  // Sum the power histories for each system, TW Pumps, CT Fans, and CW Pumps\n  totTWPumpPower: hisRead(twPumpPowers, dateRange, {limit:null})\n                  .toolHisAlign(avg, min, true, rollup)\n                  .hisFoldCols(sum)\n                  .renameCol(\"v0\",\"twPump\"+suffix)\n   \n  totCTFanPower: hisRead(ctFanPowers, dateRange, {limit:null})\n                 .toolHisAlign(avg, min, true, rollup)\n                 .hisFoldCols(sum)\n                 .renameCol(\"v0\",\"ctFan\"+suffix)\n\n  totTRWPumpPower: hisRead(trwPumpPowers, dateRange, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"trwPump\"+suffix)\n  \n  // join trends\n  allTrends: hisJoin([wbTemp, totTWPumpPower, totCTFanPower, totTRWPumpPower])\n             // Process through toolHisAlign again to ensure missing values are treated properly\n             .toolHisAlign(avg, min, true, rollup)  // rollupF, intervalF, removeMiss, minInterval\n   \n  // determine valid period based on compute power filter\n  filterPeriod: hisRead(totalCompPower, dateRange, {limit:null})\n                .hisFindPeriods(v => (minCompPower==null or v >= minCompPower)\n                                     and (maxCompPower==null or v <= maxCompPower))    \n   \n  // Apply filter to grid\n  grid: allTrends.hisFindInPeriods(filterPeriod)\n  return(grid)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptMetricsCoolingSystemITUE","toolRecursiveSearch"],,,,M,,,,,,"viITUEvis",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the ITUE points for a given computer(s)\n  and construct a chart for display on a graph\n    \n  Arguments: \n  dates            Span of dates we want to calculate the metric on\n  rollup           timespan for rolling up data         \n  computeNav       NavName for computer you wish to display\n  locRef           B59 by default, location of computers\n*/\n\n(dates: today, rollup: 15min, computeNav: null, locRef:null) => do\n  \n  // Default to B59 Data Center if no locRef is provided\n  if(locRef==null)\n    locRef = read(location and siteRef->dis==\"59\" and dis==\"B59 Data Center\")->id\n    \n    computeRef : read(locationRef==locRef and navName==\"Computers\")->id\n  \n  if(computeNav==null)\n    computeNav = \"Cori\"\n\n    computer : read(locationRef==locRef and navName==computeNav)->id\n  // Get compute and fans meters\n    computeMeter : toolRecursiveSearch(computer, \"meter and compute\")[0]->id\n    fansMeter : toolRecursiveSearch(computer, \"meter and fan\")[0]->id\n    \n  // Get all ITUEs under this system\n  itues: toolRecursiveSearch(computeRef,\n                   \"hisFunc==\\\"ptMetricsCoolingSystemITUE\\\"\")\n                   \n  // Read trends and rollup\n  itueTrends: hisRead(itues,dates,{limit:null})\n                 .hisRollup(avg, rollup)\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"computers\")\n                 .renameCol(\"v1\", \"cori\")\n                 .renameCol(\"v2\", \"edison\")\n  \n  // Get power readings for the fans and compute under specified computer\n  computePower : read(equipRef==computeMeter and power)\n                      .hisRead(dates,{limit:null})\n                      .hisRollup(avg, rollup)\n                      .findAll(row => row.all(v => v != null))\n                      .renameCol(\"v0\", \"compPower\")\n  fansPower : read(equipRef==fansMeter and power)\n                      .hisRead(dates,{limit:null})\n                      .hisRollup(avg, rollup)\n                      .findAll(row => row.all(v => v != null))\n                      .renameCol(\"v0\", \"fansPower\")\n                      \n  // Get ITUE for specified computer\n  itueSpec : read(equipRef==computer and navName==\"CRAY Cooling System ITUE\")\n                      .hisRead(dates,{limit:null})\n                      .hisRollup(avg, rollup)\n                      .findAll(row => row.all(v => v != null))\n                      .renameCol(\"v0\", \"itue\")\n\n  //Add compute and fans power readings to ITUE trends\n  metric: hisJoin([itueTrends, computePower, fansPower, itueSpec])  \n            .addColMeta(\"itue\",\n              {dis: computeNav + \" ITUE\",\n              unit: \"_\", color: \"#27AE60\",\n               chartGroup: \"a\"})\n            .addColMeta(\"compPower\",\n              {dis: computeNav + \" Compute Power\",\n              unit: \"kW\", color: \"#5DADE2\",\n               chartGroup: \"a\"})     \n            .addColMeta(\"fansPower\",\n              {dis: computeNav + \" Fans Power\",\n              unit: \"kW\", color: \"#F1C40F\",\n               chartGroup: \"a\"}) \n            .addColMeta(\"computers\",\n              {dis: \"Combined Computer ITUE\",\n               unit: \"kW\", color: \"#4B0082\",\n               chartGroup: \"itues\"})\n            .addColMeta(\"cori\",\n              {dis: \"Cori ITUE\",\n               unit: \"_\", color: \"#DC143C\",\n               chartGroup: \"itues\"})\n            .addColMeta(\"edison\",\n              {dis: \"Edison ITUE\",\n               unit: \"_\", color: \"#303F9F\",\n               chartGroup: \"itues\"})\n  return metric\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolHisGridGapsPeriods",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given history grid, detect data gaps longer than the\n  given threshold and return one summary boolean history.\n  \n  Any null or na() value in any one column will result in\n  a detected gap regardless of timestamps.\n  \n  Arguments:\n  hisGrid         History grid to analyze\n  maxGap          Number (time), longest allowed gap between readings\n*/\n\n(hisGrid, maxGap:1min) => do\n  rowPrev: null\n  \n  gaps: hisGrid.map(row => do\n    if (rowPrev == null)\n      dict: null\n    else do\n      gap: if ((row->ts - rowPrev->ts) > maxGap) true\n           else if (rowPrev.any(v => v==null or v==na())\n                    or row.any(v => v==null or v==na())) true\n           else false\n    \n      dict: {ts:rowPrev->ts, gap:gap}\n    end\n    \n    rowPrev= row     \n    return dict\n  end)\n\n  return gaps.addColMeta(\"gap\", {dis:\"Data Gaps > \"+maxGap})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateMonthlyReg",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  if (rec.missing(\"baseSpan\"))\n    throw \"A baseline period is required\"\n  \n  if (rec.missing(\"cddBase\") and rec.missing(\"hddBase\"))\n    throw \"At least one of cddBase or hddBase is required\"\n    \n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["setRPRFieldValue"],,,,M,,,,,,"transferRoomPressureReport",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  LBL // JS // Last modified: 2019-09-05\n*/\n\n(googleSheetURL, zoneId, equipId:null) => do\n  /* takes in the whole url to the spreadsheet,\n  parses through it using regex to find the docID,\n  extracts data from all the sheet, calls ioReadLines\n  6 times because there are 6 sheets (setpoints, alarms, system flow, etc),\n  matches with the right siteID, creates the rpr object,\n  returns a print statement that says no site for that rpr exists if there is none */\n  \n  // Check inputs and return feedback\n  if (zoneId!=null and googleSheetURL==\"\")\n    return [{message:\"Selected: \"+readById(zoneId).dis()},\n            {message:\"Please enter a Pressure Report URL\"}].toGrid()\n  \n  // Checks if link is a google sheet link, and sets sheet_id to be the Google Sheet's unique ID name\n  if (not contains(googleSheetURL, \"https://docs.google.com/spreadsheets/\")) \n    return \"Please enter a Google SpreadSheet link.\"\n  sheet_id: reFind(r\"\\/[a-z]\\/(.*?)(\\/|\$)\", googleSheetURL)\n\n  // Match the Room Pressure Report with a site and zone, creates a RPR object\n  \n  \n  rprinfolink: \"https://docs.google.com/spreadsheets\" + sheet_id + \"gviz/tq?tqx=out:csv&sheet=Report details&range=B3:B5\"\n  rprInfo: split(ioReadStr(``+ rprinfolink), \"\\\"\")\n  date: rprInfo[1]\n  /*\n  \n  building: rprInfo[3].padl(2, \"0\") \n  room: rprInfo[5]\n  siteId: read(site and dis==building)->id\n  roomId: read(siteRef==siteId and zone and dis==\"Rm \"+room)->id\n  if (not (readById(zoneId)->dis == \"Rm \"+room)) do\n    return \"Zone entered on SkySpark is not the same as the room entered in the spreadsheet!\" + readById(zoneId)->dis + \" \" + room\n    end\n  \n  */\n  \n  room: readById(zoneId)->navName\n  siteId: readById(zoneId)->siteRef\n  building: readById(siteId)->dis\n  //equipment: readById(equipId)->navName\n  \n  // Checks if a room pressure report with the same date, room number and building exists, and if there is, it will be overwritten.\n  if (read(roomPressureReport and siteRef==siteId and date==date and zoneRef==zoneId //and equipRef==equipId\n           , false) != null) do\n    old_rpr_id: read(roomPressureReport and siteRef==siteId and zoneRef==zoneId //and equipRef==equipId\n                     and date==date)->id\n    diff(readById(old_rpr_id), {trash}).commit() \n    end         \n  \n  diff(null, {roomPressureReport,\n              roomPressureReportRef,\n              siteRef: siteId, \n              date: date, \n              dis: room + \", \" + building + \", \" + date,\n              zoneRef: zoneId,\n              //equipRef: equipId\n              }, \n                                 {add}).commit()\n  rprId: read(roomPressureReport and siteRef==siteId and date==date and zoneRef==zoneId //and equipRef==equipId\n             )->id\n  \n  // Sheet names in Strings, needed to find the URL for that page\n  report_details: \"Report_details\"\n  first_page: \"SP, AL, CON, INT, CONF\"\n  second_page: \"SYS SUP FLOW, CHECKS\"\n  third_page: \"EXH, HOOD FLOW, CAL\"\n  fourth_page: \"Notes\"\n  \n  // Ranges for different fields\n  details_range: \"A2:B8\"\n  \n  setpoints_range: \"A1:B13\"\n  alarms_range: \"D1:E13\"\n  control_range: \"G1:H15\"\n  interface_range: \"A15:B21\"\n  configure_range: \"D15:E20\"\n  \n  sysflow_range: \"A1:B6\"\n  inpcheck_range: \"D1:E14\"\n  supflow_range: \"G1:H17\"\n  flowcheck_range: \"A8:B21\"\n  \n  exhflow_range: \"A1:B11\"\n  hoodflow_range: \"D1:E10\"\n  hoodcal_range: \"G1:H15\"\n  \n  note1_range: \"A1:J7\"\n  note2_range: \"A9:J15\"\n  \n  //Parse through the data in the spreadsheet using ioReadLines, and extracting the data for certain fields in the ranges and sheet names specified above\n  \n  docslink: \"https://docs.google.com/spreadsheets\"\n  csvout: \"gviz/tq?tqx=out:csv\"\n  page_name: \"&sheet=\"\n  range: \"&range=\"\n  \n  firstPgRanges: [setpoints_range, alarms_range, control_range, interface_range, configure_range]\n  secondPgRanges: [sysflow_range, inpcheck_range, supflow_range, flowcheck_range]\n  thirdPgRanges: [exhflow_range, hoodflow_range, hoodcal_range]\n  fourthPgRanges: [note1_range, note2_range]\n\n  /* Below, we combine all these variables to create querIES (google spreadsheet link for\n  each of these different fields) so we can call setRPRFieldValue on them to set the rpr object tags */\n  \n  //Report details\n  query1: docslink + sheet_id + csvout+ page_name + report_details + range + details_range\n  setRPRFieldValue(rprId, ioReadCsv(``+query1,{noHeader}))\n  \n  //SP, AL, CON, INT, CONF\n  firstPgRanges.each item => do\n    query2: docslink + sheet_id + csvout + page_name + first_page + range + item\n    setRPRFieldValue(rprId, ioReadCsv(``+query2,{noHeader}))\n  end\n \n  //SYS SUP FLOW, CHECKS\n  secondPgRanges.each item => do\n    query3: docslink + sheet_id + csvout + page_name + second_page + range + item\n    setRPRFieldValue(rprId, ioReadCsv(``+query3,{noHeader}))\n  end\n  \n  //EXH, HOOD FLOW & CAL\n  thirdPgRanges.each item => do\n    query4: docslink + sheet_id + csvout + page_name + third_page + range + item\n    setRPRFieldValue(rprId, ioReadCsv(``+query4,{noHeader}))\n  end\n  \n  //Notes\n  fourthPgRanges.each item => do\n    query5: docslink + sheet_id + csvout + page_name + fourth_page + range + item\n    setRPRFieldValue(rprId, ioReadCsv(``+query5,{noHeader}))\n  end\n  \n  return \"Import successful!\"\n  \n  \n  //ioReadLines(`https://docs.google.com/spreadsheets/d/1puo-F7kFmn4qJIqfuo3uol8OLjCwz5nMF8Egkyl37PA/gviz/tq?tqx=out:csv&sheet=SP, AL, CON, INT, CONF&range=E16:E20`)\n  \n  \n  //https://docs.google.com/spreadsheets/d/1puo-F7kFmn4qJIqfuo3uol8OLjCwz5nMF8Egkyl37PA/edit#gid=0\n  \n  //ioReadLines(`https://docs.google.com/spreadsheets/d/1puo-F7kFmn4qJIqfuo3uol8OLjCwz5nMF8Egkyl37PA/gviz/tq?tqx=out:csv&sheet=SP, AL, CON, INT, CONF&range=A1:B13`)\n  \n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viB59ComputePowerFilter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  builds a simple chart for B59 with compute power and the min and max \n  compute power filter along with \n    \n  Arguments: \n  dates            Span of dates we want to calculate the metric on\n  min              minimum compute power filter\n  max              maximum compute power filter\n*/\n\n\n(dates: today, min: null, max: null, bonusTemp: null) => do\n  \n  //assign OA wet bulb as bonus trend if nothing is selected\n  if(bonusTemp == null)\n  bonusTemp = readById(@p:lbnl:r:239b14d5-3168b0a7)\n  \n  if(bonusTemp==\"CW Supply Temperature\")\n  bonusTemp = readById(@p:lbnl:r:23909a8b-3478b7d0)\n  \n  if(bonusTemp==\"Outside Air Wetbulb Temperature\")\n  bonusTemp = readById(@p:lbnl:r:239b14d5-3168b0a7)\n  \n    //hisRead bonus temp\n    bonusTrend: bonusTemp.hisRead(dates,{limit:null})\n        .renameCol(\"v0\",\"bonus\")\n\n  //look up compute power\n  compute: readById(@p:lbnl:r:2444485c-4d9af430)\n\n    \n    //hisRead compute power  \n    powerTrend:  compute.hisRead(dates,{limit:null})\n        .addColMeta(\"v0\",{unit:\"kW\",\n                    chartGroup: \"all\",\n                    color: \"#BF2796\"})\n    //ignore compute loads less than 10kW (preventing two left y-axes)\n        .hisFindAll(v => v > 10kW)\n        .addCol(\"minFilter\", v => v= min)\n          .addColMeta(\"minFilter\",{unit:\"kW\",\n                    chartGroup: \"all\",\n                    dis: \"Min Compute Power (kW)\",\n                    color: \"#96BF27\"})\n        .addCol(\"maxFilter\", v => v= max.as(\"kW\"))\n          .addColMeta(\"maxFilter\",{unit:\"kW\",\n                    chartGroup: \"all\",\n                    dis: \"Max Compute Power (kW)\",\n                    color: \"#4B6014\"})\n        \n      //combine wb and power trends\n      trends: hisJoin([bonusTrend,powerTrend])\n          .addColMeta(\"bonus\",{unit: \"°F\",\n                     chartGroup: \"all\",\n                     dis: bonusTemp->navName+ \" (°F)\",\n                     color: \"#2796BF\"})\n          .findAll(row => row.all(v => v != null))\n  \n  return trends\n\n end\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"zz_old_anDailyGasAdjusted",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// Perform regression vs HDD of daily natural gas usage,\n// return dictionay with:\n//   reg: regression results\n//   graph: chart grid for corresponding data\n\n(meterUsageRef, datesBase, datesPost, ddRef, titlePrefix:\"\") => do\n  usage: readById(meterUsageRef)\n        .hisRead(datesPost)\n\n  // Apply day type factoring to usage, for graphing purposes\n  usage_factor: usage.map row => {\n    ts: row->ts,\n    usageWeekday: if(isWeekday(row->ts)) row->v0 else null,\n    usageWeekend: if(isWeekday(row->ts)) null else row->v0\n  }\n  \n  // Read HDD from LBL weahter station data\n  hdd: read(weatherPoint and main and air and temp and sensor)\n       .degreeDays(datesPost, ddRef)\n       .hisClip()\n       .keepCols([\"ts\",\"heat\"])\n   \n  // Apply day type factoring  to HDD, for regression purposes\n  hdd_factor: hdd.map row => {\n    ts: row->ts,\n    hddWeekday: if(isWeekday(row->ts)) row->heat else 0,\n    hddWeekend: if(isWeekday(row->ts)) 0 else row->heat\n  }\n       \n  // Join regression data and filter out missing gas data points\n  joined: hisJoin([hdd_factor.hisRollup(sum, 1day),\n                   usage.hisRollup(sum, 1day)])\n          .findAll row => row.has(\"v0\")   // Filter out dates with missing gas data\n  \n  // Isolate dependent and independent variables for regression\n  y: joined.keepCols([\"v0\"])\n  x: joined.keepCols([\"hddWeekday\",\"hddWeekend\"])\n\n  // Perform regression\n  reg: matrixFitLinearRegression(y, x)\n  \n  // Build dictionary of results\n  regRes: {\n    intercept: reg.meta[\"bias\"],\n    slopeWeekday: reg[0][\"b\"],\n    slopeWeekend: reg[1][\"b\"],\n    rSquared: reg.meta[\"r2\"],\n    n: reg.meta[\"rowCount\"]\n  }\n  \n  // Get base period regression results\n  baseRegRes: anDailyGasReg(meterUsageRef, datesBase, ddRef)->reg\n  \n  // Create grid of adjusted baseline and avoided energy use\n  slope: null\n  adjustedBase: null\n  energyUse: hisJoin([hdd.hisRollup(sum, 1day), usage.hisRollup(sum, 1day)])\n              .findAll(row => row.has(\"v0\"))\n              .map row => do\n                slope = if(isWeekday(row->ts)) baseRegRes[\"slopeWeekday\"] else baseRegRes[\"slopeWeekend\"]\n                adjustedBase = (baseRegRes[\"intercept\"] + slope*row->heat).as(1therm)\n                dict: {\n                  ts: row->ts,\n                  adjustedBase: adjustedBase,\n                  measured: row->v0,\n                  avoidedEnergy: adjustedBase - row->v0\n                }\n              end\n  \n  // Calculate statistics\n  avoidedUsage: energyUse.foldCol(\"avoidedEnergy\", sum)\n  adjustedTotal: energyUse.foldCol(\"adjustedBase\", sum)\n  f: avoidedUsage / adjustedTotal\n  m: reg.meta[\"rowCount\"]\n  avoidedUncertainty68: 1.26 * 1 / (m * baseRegRes[\"measuredAvg\"] * f) * sqrt(baseRegRes[\"mse\"] * (1 + 2 / baseRegRes[\"n\"]) * m)\n  //avoided_rel_u68 <- 1.26 * 1 / (m * base_measured_avg * f) * sqrt(base_mse_eff * (1+2/n_eff) * m)\n  \n  // Compile results\n  avoidedResults: {\n    avoidedUsage: avoidedUsage,\n    avoidedUsageRelative: (f*100).as(1%),\n    adjustedTotal: adjustedTotal,\n    uncertainty68: (avoidedUncertainty68*100).as(1%)\n  }\n  \n  // Create graph of data (regression not yet shown)\n  graph: hisJoin([hdd, usage_factor])\n    .keepCols([\"heat\",\"usageWeekday\",\"usageWeekend\"])\n    .sort(\"heat\")\n    .addCol(\"regressionWeekday\", row => if(row.has(\"heat\")) (regRes[\"intercept\"]+regRes[\"slopeWeekday\"]*row->heat).as(1therm) else null)\n    .addCol(\"regressionWeekend\", row => if(row.has(\"heat\")) (regRes[\"intercept\"]+regRes[\"slopeWeekend\"]*row->heat).as(1therm) else null)\n    .addCol(\"adjustedBaseWeekday\", row => if(row.has(\"heat\")) (baseRegRes[\"intercept\"]+baseRegRes[\"slopeWeekday\"]*row->heat).as(1therm) else null)\n    .addCol(\"adjustedBaseWeekend\", row => if(row.has(\"heat\")) (baseRegRes[\"intercept\"]+baseRegRes[\"slopeWeekend\"]*row->heat).as(1therm) else null)\n    .addColMeta(\"usageWeekday\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#1D80F1\"})\n    .addColMeta(\"usageWeekend\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#07203C\"})\n    .addColMeta(\"regressionWeekday\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#C7DFFB\"})\n    .addColMeta(\"regressionWeekend\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#C1C7CE\"})\n    .addColMeta(\"adjustedBaseWeekday\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#F18E1D\"})\n    .addColMeta(\"adjustedBaseWeekend\", {chartType:\"scatter\", chartGroup:\"main\", color:\"#B56B16\"})\n    .reorderCols([\"heat\",\"adjustedBaseWeekend\",\"adjustedBaseWeekday\",\"regressionWeekend\",\"regressionWeekday\",\"usageWeekend\",\"usageWeekday\"])\n    .addMeta({title:titlePrefix+\"Daily gas usage vs HDD grouped by day type\"})\n    \n  // Return dict of regression results and graph\n  return {reg:regRes, graph:graph, energyUse:energyUse, avoidedResults:avoidedResults}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"boilerOrChillerPumpMismatch",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates, minTime: 15min) => do\n  \n  runPeriods: []\n  pumpRunPeriods: []\n   \n  runPts: readAll(point and run and cmd and hisEnd and equipRef==equip->id)\n  if (isEmpty(runPts)) return null\n  runPts.each pt => do\n    //find all run periods for each chiller/boiler\n    runPeriods = runPeriods.add(pt.hisRead(dates).hisFindPeriods(v=> v != false))\n  end\n      \n  pumps: readAll(equip and equipRef== equip->id and pump)\n  if (isEmpty(pumps)) return null\n  pumps.each pump => do \n    equipId: pump->id\n    runPts: readAll(point and run and sensor and equipRef==equipId)\n    if (isEmpty(runPts)) return null\n    runPts.each pt => do\n      //find all run periods for each pump\n      pumpRunPeriods = runPeriods.add(pt.hisRead(dates).hisFindPeriods(v=> v != false))\n    end\n  end\n    \n  // find when multiple chillers are running at the same time\n  oneDeviceOn: hisPeriodMatrix(pumpRunPeriods).findAll r => r->numTrue ==1\n  oneDeviceOn = oneDeviceOn.findAll(r => r->dur >= minTime)\n\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74PointsFH",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point, add these points to zone and to equips that already exist.\n \n The file includes a match to the 2018-12-07 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(file: `io/integration_b74/fh_points.csv`,\ntypes: [2,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(file)\n  \n  siteId: read(site and dis==\"74\")->id\n  failedList: []\n\n  // Cycle through existing terminal units\n  tus: readAll(fumeHood and equip\n               and siteRef==siteId\n               and connRef)\n  \n  tus.each((tu, i) => do\n    jobProgress(round(i/tus.size()*100).as(\"%\"), tu.dis())\n    locationId: tu->locationRef\n    zoneId: tu->equipRef\n    connectorId: tu->connRef\n    instance: tu->connInstance\n    \n    // Prepare list of bacnet grids containing all bacnet info for given types\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"TL\"]\n    \n    try do\n      types.each type => do\n        learn: bacnetLearn(connectorId, type)\n        bacnetPtList= bacnetPtList.set(type, learn)\n      end\n    end catch (ex) do\n      failedList= failedList.add(tu.dis())\n      // Skip terminal unit\n      return null\n    end\n\n    // Cycle through given points of interest, find and integrate\n    alcPtList.each pt => do\n      // Find corresponding tag set info in tagging standard\n      tagRow: tagStd.find(tag => tag->index==pt->indexTagStandard)\n    \n      // Initialize found bacnet rows to null\n      bacnetCurRow: null\n      bacnetHisRow: null\n    \n      // If bacnetCur is available, retrieve corresponding info\n      if (pt[\"bacnetCurName\"] != null) do\n        curType: bacnetObjMap.index(pt[\"bacnetCurType\"])\n        curName: pt->bacnetCurName + \"_\" + instance\n        \n        // Find available BACnet point info\n        bacnetCurGrid: bacnetPtList[curType]\n        if (bacnetCurGrid == null) bacnetCurGrid= [].toGrid()\n        bacnetCurRow= bacnetCurGrid.find(row => row[\"dis\"]==curName)\n        \n        // If point not found in BACnet, it is hidden or does not\n        // exist for this zone. Skip point only if bacnetHis also missing\n      end // If bacnetCur is available\n      \n      // If bacnetHis is available, retrieve corresponding info\n      if (pt[\"bacnetHisName\"] != null) do\n        hisName: pt->bacnetHisName + \"_\" + instance\n        \n        // Find available BACnet point info\n        bacnetHisGrid: bacnetPtList[20]\n        if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n        bacnetHisRow= bacnetHisGrid.find(row => row[\"dis\"]==hisName)\n      end\n\n      // If we did not find BACnet info for either Cur or His, skip point\n      if ((bacnetCurRow == null) and (bacnetHisRow == null)) return null\n      \n      // Check equipment type to determine proper equipRef\n      equipId: if (pt->eq==\"fh\") tu->id\n\n      // If point already exists, skip\n      ptFilter: \"point and equipRef==@\" + equipId + \" and \"\n                + tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n      if (read(parseFilter(ptFilter),false) != null) return null\n          \n      // Prepare polling variables as needed (null if bacnetHis)\n      hisCollectCov: if (pt[\"hisCollectCov\"]==null) null else marker()\n      hisCollectInterval: if (pt[\"hisCollectCov\"]==null) null else 12h\n      \n      // Prepare new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: if (bacnetCurRow != null) bacnetCurRow[\"bacnetCur\"],\n               bacnetHis: if (bacnetHisRow != null) bacnetHisRow[\"bacnetHis\"],\n               bacnetCurName: if(pt[\"bacnetCurName\"] != null) pt->bacnetCurName + \"_\" + instance,\n               bacnetHisName: if(pt[\"bacnetHisName\"] != null) pt->bacnetHisName + \"_\" + instance,\n               bacnetDesc: if (bacnetCurRow != null) bacnetCurRow[\"bacnetDesc\"], //optional\n               kind: if (bacnetCurRow != null) bacnetCurRow[\"kind\"] else pt[\"kind\"],\n               unit: if (pt[\"unit\"] != null or bacnetCurRow == null) pt[\"unit\"]\n                     else bacnetCurRow[\"unit\"],\n               enum: if (bacnetCurRow != null) bacnetCurRow[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               hisCollectCov: hisCollectCov,\n               hisCollectInterval: hisCollectInterval,\n               notes: pt[\"alcDisplay\"], //optional\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp2: today()}\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n    end  // alcPtList.each pt\n  end)  // each tu\n  \n  return failedList\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"viPointCacheList",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays formatted grid of connector cached point records.\n  \n  Arguments:\n  connRefs        Ref[] to connectors\n  type            Str, enum:\"All,Cur,His,Unique,Unique & New\"\n                  Option for filtering out records based on tags\n  filter          Str, optional, filter to apply as regex to the\n                  bacnet fields and controls field\n  logShow         Bool, optional, show BACnet TL object info\n  intgShow        Bool, optional, show added equipRef and tagSetRef\n*/\n\n(connRefs, type:\"Unique\", filter:\"\", logShow:true, intgShow:false) => do\n  // Load all cached records and filter by connectors\n  grid: readAll(connPointCache)\n  if (connRefs!=null and not(isEmpty(connRefs)))\n    grid= grid.findAll(co => connRefs.contains(co->connRef))\n  \n  if (isEmpty(grid)) return null\n  \n  // Filter for types: All, Cur, His\n  grid= grid.findAll(row =>\n    if (type==\"All\") true\n    else if (type==\"Cur\") row.has(\"bacnetCurName\")\n    else if (type==\"His\") row.has(\"bacnetHisName\")\n                          and not(row.has(\"bacnetCurName\"))\n    else if (type==\"Unique\") not(row.has(\"bacnetCurLog\"))\n    else if (type==\"Unique & New\") not(row.has(\"bacnetCurLog\"))\n                                   and not(row.has(\"pointRef\"))\n    else true)\n  \n  // Filter by dis and desc\n  grid= grid.findAll(row =>\n    reMatches(\"(?i).*\"+filter+\".*\",\n              row[\"bacnetCurName\"]+\" \"+row[\"bacnetHisName\"]+\" \"+row[\"bacnetDesc\"]+\" \"+row[\"controls\"]))\n  \n  if (isEmpty(grid)) return null\n  \n  // Prepare list of display columns based on options\n  disCols: [\"bacnetCur\",\"bacnetCurName\",\n            \"bacnetHis\",\"bacnetHisName\"]\n  disCols= disCols.addAll([\"bacnetDesc\"])\n  \n  if (logShow)\n    disCols= disCols.addAll([\"bacnetLogInterval\",\n            \"bacnetLogCovIncrement\",\"bacnetLogBufferSize\"])\n  \n  disCols= disCols.addAll([\"kind\",\"unit\",\"enum\",\"pointRef\"])\n  \n  if (intgShow)\n    disCols= disCols.addAll([\"controls\",\"equipRef\",\"tagSetRef\"])\n  \n  // Format and return\n  return grid.toolFormatGrid(disCols)\n             .sort((a,b) => a.dis() <=> b.dis())\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["bacnetObjConvert"],,,,M,,,,,,"intgUpdateConnCacheHis",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given BACnet connector, review previously cached trend log objects\n  and use bacnetReadObject to store additional information about each object.\n*/\n\n(connRef) => do\n  // If record is passed instead of id, retrieve id\n  if (not(isRef(connRef)))\n    try connRef= connRef->id\n    catch return {error: \"Incorrect input argument. \"\n                  + \"Expected ID of a connector object.\"}\n                 .toGrid()\n  \n  // Obtain list of cached TL objects\n  tls: readAll(connPointCache and connRef==connRef\n               and bacnetHis and not bacnetCur)\n  \n  // Cycle through TL objects and query connector for additional info\n  tls.each tl => do\n    grid: bacnetReadObject(connRef, tl->bacnetHis,\n                           [\"LOG_INTERVAL\",\n                            \"BUFFER_SIZE\",\n                            \"CLIENT_COV_INCREMENT\",\n                            \"LOG_DEVICE_OBJECT_PROPERTY\"])\n    changes: {}\n                           \n    // Set log interval\n    iRow: grid.find(row => row[\"propertyName\"]==\"LOG_INTERVAL\")\n    interval: 0\n    if (iRow!=null and iRow.has(\"value\")) do\n      interval= iRow[\"value\"]/100\n      changes= changes.set(\"bacnetLogInterval\",\n                           interval.as(\"s\").to(\"min\"))\n    end else\n      changes= changes.set(\"bacnetLogInterval\", removeMarker())\n      \n    // Set log buffer\n    bRow: grid.find(row => row[\"propertyName\"]==\"BUFFER_SIZE\")\n    if (bRow!=null and bRow.has(\"value\"))\n      changes= changes.set(\"bacnetLogBufferSize\",\n                           bRow[\"value\"].as(\"_records\"))\n    else\n      changes= changes.set(\"bacnetLogBufferSize\", removeMarker())\n      \n    // Set log cov increment\n    cRow: grid.find(row => row[\"propertyName\"]==\"CLIENT_COV_INCREMENT\")\n    if (cRow!=null and cRow.has(\"value\") and interval==0)\n      changes= changes.set(\"bacnetLogCovIncrement\",\n                           cRow[\"value\"])\n    else\n      changes= changes.set(\"bacnetLogCovIncrement\", removeMarker())\n      \n    // Set corresponding bacnetCur, if available\n    dRow: grid.find(row => row[\"propertyName\"]==\"LOG_DEVICE_OBJECT_PROPERTY\")\n    try do\n      curRead: bacnetReadObject(connRef, dRow[\"value\"][\"objId\"])\n      changes= changes.set(\"bacnetCurLog\",\n                             dRow[\"value\"][\"objId\"].bacnetObjConvert())\n      if (isEmpty(curRead))\n        changes= changes.set(\"bacnetCurLog\", removeMarker())\n    catch\n      changes= changes.set(\"bacnetCurLog\", removeMarker())\n      \n    // Update existing record\n    commit(diff(tl, changes))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldHisDerivMin",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, ts, acc) => do\n  if (val == foldStart()) return {vlast:na(), tlast:0, dmin: 0}\n  if (val == foldEnd()) return acc->dmin\n  if (val == na()) return na()\n  \n  if (acc->tlast == 0) return {vlast: val, tlast: ts, dmin: 0}\n  if (acc->tlast == ts) return acc\n  return {vlast: val, tlast: ts,\n          dmin: min(acc->dmin,\n                    (val - acc->vlast)/(ts - acc->tlast))}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"sqlTestScript",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n\n  //Need to add some error checking\n  //if not point->equipRef->ionSqlConn then return False???\n\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND S.Name = '\" + \"LBL_ION_06.33_639A1A1A\" + \"'\" +\n       \" AND D.QuantityID = \" + \"128\" +\n       \" AND D.TimestampUTC >= '\" + \"2017-08-20 23:59:00\" + \"'\" +\n       \" AND D.TimestampUTC < '\" + now().toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: read(sqlConn and dis==\"ionDB\").sqlQuery(sql)\n\n  mapped: data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                .toTimeZone(\"Los_Angeles\"),\n                            val: row->val }\nend\n\n/*() => do\n\n  //Need to add some error checking\n  //if not point->equipRef->ionSqlConn then return False???\n\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND S.Name = '\" + \"LBL_ION_02.90_90A\" + \"'\" +\n       \" AND D.QuantityID = \" + \"128\" +\n       \" AND D.TimestampUTC >= '\" + \"2018-03-20 23:00:00\" + \"'\" +\n       \" AND D.TimestampUTC < '\" + now().toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: read(sqlConn).sqlQuery(sql)\n\n  mapped: data.map row => { ts: (row->ts+\" UTC\").parseDateTime(\"YYYY-MM-DD hh:mm:ss zzz\")\n                                                .toTimeZone(\"Los_Angeles\"),\n                            val: row->val }\nend\n*/\n\n/*\nread(sqlConn and dis==\"ionDB\").sqlQuery(\"SELECT * FROM ION_Data.dbo.Source WHERE Name = 'LBL_ION_06.30_650A'\").renameCol(\"id\",\"ionId\")\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB37LCWPressControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236cf112-7089a42a,\n             @p:lbnl:r:236a551f-bd495215,\n             @p:lbnl:r:236a551f-7ef8d091,\n             @p:lbnl:r:236a551f-5f05f8ad,\n             @p:lbnl:r:236a551f-fde5b01e,\n             @p:lbnl:r:236a551f-30c902ef,\n             @p:lbnl:r:236a551f-28be83a6,\n             @p:lbnl:r:236a551f-4186877a,\n             @p:lbnl:r:236a551f-fba6b9d0,\n             @p:lbnl:r:236a551f-286c0bbb,\n             @p:lbnl:r:236a551f-505a2ba7,\n             @p:lbnl:r:236a551f-a9b2ee4e,\n             @p:lbnl:r:236a551f-f3101570,\n             @p:lbnl:r:236a551f-e053beb3])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap91RAM",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with radiant manifold info and addresses, create equips\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b91/ram.csv`)\n  \n  siteDis: \"91\"\n  siteId: read(site and dis==siteDis)->id\n  \n  // Cycle through each row of CSV file\n  file.each row => do\n    // Prepare location\n    floorDis: row[\"floor\"]\n    locationDis: \"B91 Floor \" + floorDis    \n    location: read(location and siteRef==siteId and\n                   dis==locationDis, false) \n                   \n    // Create location if it doesn't exist\n    if (location==null) do\n      locDict: {\n        dis: locationDis,\n        location,\n        siteRef: siteId,\n      }\n      \n      locationId: commit(diff(null, locDict, {add}))->id\n    end else locationId: location->id\n    \n    // Prepare zone\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    zone: read(zone and locationRef==locationId and\n               navName==roomDis, false)\n    \n    // Create zone if it doesn't exist\n    if (zone==null) do\n      zoneDict: {\n        disMacro: \"\\\$locationRef \\\$navName\",\n        equip,\n        locationRef: locationId,\n        navName: roomDis,\n        siteRef: siteId,\n        zone,\n        tmp:today(),\n      }\n      \n      zoneId: commit(diff(null, zoneDict, {add}))->id\n    end else zoneId: zone->id\n    \n    // Prepare ram equip\n    eqDis: reGroups(\"^91-(.{3}-\\\\d\\\\d\\\\d)\",row[\"ram\"])[1]\n\n    eq: read(locationRef==locationId and\n             equip and navName==eqDis, false)\n    \n    // Create equip if it doesn't exist\n    if (eq==null) do\n      eqDict: {\n        navName: eqDis,\n        disMacro: \"\\\$equipRef \\\$navName\",\n        controls: row[\"controlProgram\"],\n        radiant,\n        flooring,\n        equip,\n        locationRef: locationId,\n        siteRef: siteId,\n        equipRef: zoneId,\n        tmp: today(),\n      }\n\n      eqId: commit(diff(null, eqDict, {add}))->id\n    end else eqId: eq->id\n    \n    // Prepare connector\n    connUri: row[\"ramBACnet\"]\n    connDis: if (row.has(\"address\")) eqDis + \" - Device \" + row[\"deviceInstance\"]\n             else \"Router \" + row[\"deviceInstance\"]\n    if (connUri!=null and connUri!=\"\") do\n      connUri= parseUri(connUri)\n      conn: read(conn and uri==connUri, false)\n      \n      // Create conn if it doesn't exist\n      if (conn==null) do\n        connDict: {\n          bacnetConn,\n          conn,\n          dis: locationDis + \" - \" + connDis,\n          siteRef: siteId,\n          uri: connUri,\n          tmp: today(),\n        }\n\n        connId: commit(diff(null, connDict, {add}))->id\n      end else connId: conn->id\n      \n      // Add tags on equip\n      eq= readById(eqId)\n      commit(diff(eq, {connRef: connId,\n                       connInstance: row[\"objectInstance\"],\n                      }))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viEquipTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates:yesterday(), ptFilter:\"point\")=> do\n  // Prepare filter and read points\n  if (isRef(equip)) equipId: equip else equipId: equip[\"id\"]\n  ptFilter= ptFilter + \" and equipRef==@\" + equipId\n  pts: readAll(parseFilter(ptFilter))\n  \n  // Load points history and sparks, combine\n  ptsHis: pts.hisRead(dates, {limit:null})\n  spks: ruleSparks(equipId, dates, readAll(sparkRule)).ruleSparkHis()\n  \n  return hisJoin([ptsHis, spks])\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"weatherChartSunWind",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ptRefs, span, interval: null, nlimit: 50000) => do\n  ptsHis: ptRefs.hisRead(span, {limit: nlimit})\n  \n  if (interval == null) do \n    ptsHisRolled: ptsHis\n    rollupInfo: ptRefs.map((ptRef, i) => do\n      if (readLink(ptRef).has(\"accumulation\")) \" sum over \"+readLink(ptRef)->accumulation\n      else \" \" \n    end)\n  end else do\n    ptsHisRolled: ptsHis.hisRollupAuto(interval)\n    rollupInfo: ptRefs.map ptRef => \" \"+readLink(ptRef)->hisRollupFunc+\" over \"+interval\n  end\n  \n  ptsHisRolled.addMeta({title: ptRefs[0]->weatherRef->dis+\": Sun, Rain, Pressure, Wind\"})\n    .addColMeta(\"v0\",{chartGroup: \"1\", \n                      color:\"gold\", \n                      dis:readLink(ptRefs[0])->navName+rollupInfo[0]+\" (\"+readLink(ptRefs[0])->unit+\")\", \n                      chartType: \"area\"})\n    .addColMeta(\"v1\",{chartGroup: \"1\", \n                      color:\"aqua\", \n                      dis:readLink(ptRefs[1])->navName+rollupInfo[1]+\" (\"+readLink(ptRefs[1])->unit+\")\", \n                      chartType: \"area\", chartMin: 0, chartMax: max(0.01, ptsHisRolled.foldCol(\"v1\",max))})\n    .addColMeta(\"v2\",{chartGroup: \"2\", \n                      color:\"indigo\", \n                      dis:readLink(ptRefs[2])->navName+rollupInfo[2]+\" (\"+readLink(ptRefs[2])->unit+\")\", \n                      chartType: \"line\"})\n    .addColMeta(\"v3\",{chartGroup: \"3\", \n                      color:\"grey\", \n                      dis:readLink(ptRefs[3])->navName+rollupInfo[3]+\" (\"+readLink(ptRefs[3])->unit+\")\", \n                      chartType: \"line\"})\n    .addColMeta(\"v4\",{chartGroup: \"3\", \n                      color:\"silver\", \n                      dis:readLink(ptRefs[4])->navName+rollupInfo[4]+\" (\"+readLink(ptRefs[4])->unit+\")\", \n                      chartType: \"line\"})\n    .addColMeta(\"v5\",{chartGroup: \"3\", \n                      color:\"mediumblue\", \n                      dis:readLink(ptRefs[5])->navName+rollupInfo[5]+\" (\"+readLink(ptRefs[5])->unit+\")\", \n                      chartType: \"line\", chartMin: 0, chartMax:360})\nend\n\n/*\n{{ptRefs}}.hisRead({{span}}, {limit: 50000}).hisRollupAuto({{interval}}).addMeta({title: \"LBNL Weather Station: Sun, Rain, Pressure, Wind\"}).addColMeta(\"v0\",{chartGroup: \"1\", color:\"gold\", dis:readLink({{ptRefs}}[0])->navName+\" \"+readLink({{ptRefs}}[0])->hisRollupFunc+\" over \"+{{interval}}+\" (\"+readLink({{ptRefs}}[0])->unit+\")\", chartType: \"area\"}).addColMeta(\"v1\",{chartGroup: \"1\", color:\"aqua\", dis:readLink({{ptRefs}}[1])->navName+\" \"+readLink({{ptRefs}}[1])->hisRollupFunc+\" over \"+{{interval}}+\" (\"+readLink({{ptRefs}}[1])->unit+\")\", chartType: \"area\"}).addColMeta(\"v2\",{chartGroup: \"2\", color:\"indigo\", dis:readLink({{ptRefs}}[2])->navName+\" \"+readLink({{ptRefs}}[2])->hisRollupFunc+\" over \"+{{interval}}+\" (\"+readLink({{ptRefs}}[2])->unit+\")\", chartType: \"line\"}).addColMeta(\"v3\",{chartGroup: \"3\", color:\"grey\", dis:readLink({{ptRefs}}[3])->navName+\" \"+readLink({{ptRefs}}[3])->hisRollupFunc+\" over \"+{{interval}}+\" (\"+readLink({{ptRefs}}[3])->unit+\")\", chartType: \"line\"}).addColMeta(\"v4\",{chartGroup: \"3\", color:\"silver\", dis:readLink({{ptRefs}}[4])->navName+\" \"+readLink({{ptRefs}}[4])->hisRollupFunc+\" over \"+{{interval}}+\" (\"+readLink({{ptRefs}}[4])->unit+\")\", chartType: \"line\"}).addColMeta(\"v5\",{chartGroup: \"3\", color:\"mediumblue\", dis:readLink({{ptRefs}}[5])->navName+\" \"+readLink({{ptRefs}}[5])->hisRollupFunc+\" over \"+{{interval}}+\" (\"+readLink({{ptRefs}}[5])->unit+\")\", chartType: \"line\", chartMin: 0, chartMax:360})\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viMeterConsumption","anReadMeterMonthly"],,,,M,,,,,,"viMeterMonthly",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, load monthlyRead records, and display\n  all readings on a bar chart.\n  \n  Arguments: \n  meterRef        Target id\n*/\n(meterRef, hddBase:65°F, cddBase:55°F, perDayOnly:false,\n disregardIgnore:false, intervalCompare:false) => do\n  // Variables\n  prevDate: null\n  \n  meter: if (isRef(meterRef)) readById(meterRef) else meterRef\n  meterId: meter->id\n\n  // Load and process monthly consumptions records\n  grid: anReadMeterMonthly(meterRef, hddBase, cddBase, disregardIgnore)\n  \n  // If intervalCompare is true, load and process available interval data\n  if (intervalCompare and grid.has(\"meterRef\")) do\n    grid= grid.addCol(\"prevReadDate\", cRow => do\n      pGrid: grid.findAll(row => row->meterRef==cRow->meterRef and\n                          row->readDate < cRow->readDate)\n      if (isEmpty(pGrid)) return null\n      else return pGrid.sortr((a,b) => a->readDate <=> b->readDate)\n                       .first->readDate\n    end)\n    \n    grid= grid.map(r => do\n      if (r[\"prevReadDate\"]==null) return r\n      startDate: r[\"prevReadDate\"]\n      endDate: r[\"readDate\"] - 1day\n      resDict: viMeterConsumption([r->meterRef], startDate..endDate, true)\n               .first\n      if (resDict==null)\n        return r\n      else do\n        resDict.each((v,k) => r=r.set(k,v))\n        return r\n      end\n    end)\n    \n    if (grid.has(\"total\")) grid= grid.renameCol(\"total\", \"intervalConsumption\")\n    if (grid.has(\"uptime\")) grid= grid.renameCol(\"uptime\", \"intervalUptime\")\n    \n    // Calculate percent error\n    grid= grid.addCol(\"percentError\", r => do\n      if (r[\"intervalConsumption\"]==null or r[\"cons\"]==null or r[\"cons\"]==0)\n        return null\n      else return (abs(r[\"cons\"]-r[\"intervalConsumption\"])/r[\"cons\"]*100).as(\"%\")\n    end)\n  end\n  \n  // Add display names, colors, chartGroup\n  if (grid.has(\"consumptionPerDay\"))\n    grid= grid.addColMeta(\"consumptionPerDay\",\n        {dis:meter.dis+\", Avg Daily Consumption\",\n         color: if (meter.has(\"gas\")) \"crimson\"\n                else \"royalblue\",\n         chartGroup:\"2\",\n         chartType:\"bar\"})\n  if (grid.has(\"cons\"))\n    grid= grid.addColMeta(\"cons\",  \n        {dis:meter.dis+\", Consumption\",\n         color:\"gold\",\n         chartGroup:\"0\",\n         chartType:\"bar\"})\n  if (grid.has(\"heat\"))\n    grid= grid.addColMeta(\"heat\",\n        {dis:\"Avg Daily Heating Degree Days, Base: \"+hddBase,\n         color:\"red\",\n         chartGroup:\"3\",\n         chartType:\"bar\"})\n  if (grid.has(\"cool\"))\n    grid= grid.addColMeta(\"cool\",\n        {dis:\"Avg Daily Cooling Degree Days, Base: \"+cddBase,\n         color:\"blue\",\n         chartGroup:\"3\",\n         chartType:\"bar\"})\n  if (grid.has(\"intervalConsumption\"))\n    grid= grid.addColMeta(\"intervalConsumption\",\n        {dis:meter.dis+\", Interval Data Consumption\",\n         color:\"black\",\n         chartGroup:\"0\",\n         chartType:\"bar\"})\n  if (grid.has(\"intervalUptime\"))\n    grid= grid.addColMeta(\"intervalUptime\",\n        {dis:meter.dis+\", Interval Data Uptime\",\n         color:\"forestGreen\",\n         chartGroup:\"1\",\n         chartType:\"bar\",\n         chartMin:0%,\n         chartMax:100%})\n  if (grid.has(\"percentError\"))\n    grid= grid.addColMeta(\"percentError\",\n        {dis:meter.dis+\", Interval vs Monthly Reads Percent Error\",\n         color:\"red\",\n         chartGroup:\"1\",\n         chartType:\"bar\",\n         chartMin:0%,\n         chartMax:100%})\n  \n  // Prepare display grid, readDate first for proper display\n  grid= grid.reorderCols(grid.colNames.moveTo(\"readDate\",0))\n  grid= if (perDayOnly) grid.keepCols([\"readDate\",\"consumptionPerDay\"])\n        else grid.keepCols([\"readDate\",\"consumptionPerDay\",\"cons\",\n                            \"intervalConsumption\",\"intervalUptime\",\"percentError\",\n                            \"heat\",\"cool\"])\n  grid= grid.addMeta({view:\"chart\",\n                      title:\"Monthly Meter Reads for \"+meter.dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viPUEAndWetBulb",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return trends of PUE and OA WB Temp (in °F) data at B59\n*/\n\n(dateRange: toDateSpan(2019-06-01..2019-09-01),\n minCompPower: null, maxCompPower: null,\n pueEquipRef:null,\n suffix:\"\") => do\n  // Default to B59 for siteRef\n  bldgRef: read(site and dis==\"59\")\n  bldgRefId: bldgRef->id\n   \n  // Look up B59 Data Center compute power, used later for filtering\n  totalCompRef: read(locationRef->dis==\"B59 Data Center\"\n                     and superComputer and navName==\"Computers\")->id\n  totalCompMeterRef: read(meter and compute and equipRef==totalCompRef)->id\n  totalCompPower: read(power and sensor and point and equipRef==totalCompMeterRef)\n\n  // Get the PUE point for this siteRef and hisInterval\n  pue: read(siteRef==bldgRefId \n            and equipRef->navName==pueEquipRef \n            and pue and point)\n  \n  // Get the PUE trend for the given range\n  pueTrend: hisRead(pue, dateRange, {limit:null})\n            .renameCol(\"v0\",\"pue\"+suffix)\n  \n  // Get the reference for the TW Plant (for wetbulb)  \n  twPlantEquip: read(siteRef==bldgRefId\n                     and equip\n                     and condenserWaterPlant\n                     and navName == \"Plant\")\n                    \n  //wetbulb temperature (defaulting to the same location as the default)\n  wbTemp: read(equipRef==twPlantEquip->id and outside and point and sensor and wetBulb)\n          .hisRead(dateRange, {limit:null})\n          .renameCol(\"v0\",\"oaWetBulb\")\n  \n  // join trends\n  allTrends: hisJoin([wbTemp, pueTrend])\n   \n  // determine valid period based on compute power filter\n  filterPeriod: hisRead(totalCompPower, dateRange, {limit:null})\n                .hisFindPeriods(v => (minCompPower==null or v >= minCompPower)\n                                     and (maxCompPower==null or v <= maxCompPower))    \n   \n  // Apply filter to grid\n  grid: allTrends.hisFindInPeriods(filterPeriod)\n  return(grid.toolHisAlign(avg, min, true))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB37TRWTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236cedc4-aa786cf9,\n             @p:lbnl:r:236a1b0a-7ddd72a4,\n             @p:lbnl:r:236a1b0a-ce9b5d35,\n             @p:lbnl:r:236a1b0a-94301898,\n             @p:lbnl:r:236a1b0a-999a0dad])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ptAccumulatorUptime"],,,,M,,,,,,"ptAccumulatorUptime",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n For a meter record (uptime, accumulator or other), return uptime in hour \n for each data point, based on parameters provided on the uptime point or\n as opts. If provided record has a history (hisEnd), use that record's\n history, otherwise look for accumulator on the same meter.\n\n  Tags:\n  - virtual\n  --- hisIntervalMax1    (dTmax1)\n  --- hisDeltaMax1       (dVmax1)\n  --- hisIntervalMax2    (dTmax2, optional)\n  --- hisDeltaMax2       (dVmax2, optional)\n  \n  Data is considered missing when\n  (dT > dTmax1 AND dV > dVmax1) OR dT > dTmax2 OR dV > dVmax2\n\n  When data is missing at t1, the missing span is (t1 - t0)\n \n  Arguments:\n  *** Typical arguments for hisFunc\n  opts       Dict with hisIntervalMax1, hisDeltaMax1, etc. (see above)\n*/\n\n(rec, dates, opts:null, yield:null) => do\n  // Convert ref to rec\n  if (isRef(rec)) rec= readById(rec)\n  // If record has history or calculated history other than from this function,\n  // use \"as is\" otherwise find raw accumulator\n  pt: if (rec.has(\"hisEnd\")\n          or (rec[\"hisFunc\"]!=null and rec[\"hisFunc\"] != \"ptAccumulatorUptime\")) rec\n      else read(raw and accumulator and equipRef==rec->equipRef, false)\n  // If there is no raw accumulator, default to volume accumulator\n  if (pt==null)\n    pt= read(volume and accumulator and equipRef==rec->equipRef, false)\n  // If no raw and no volume accumulator, exit\n  if (pt==null)\n    return null\n\n  // Load parameters from opts or input record tags\n  if (opts==null) opts= {}\n  dTmax1: if (opts.has(\"hisIntervalMax1\")) opts->hisIntervalMax1\n          else rec[\"hisIntervalMax1\"]\n  dVmax1: if (opts.has(\"hisDeltaMax1\")) opts->hisDeltaMax1\n          else rec[\"hisDeltaMax1\"]\n  dTmax2: if (opts.has(\"hisIntervalMax2\")) opts->hisIntervalMax2\n          else rec[\"hisIntervalMax2\"]\n  dVmax2: if (opts.has(\"hisDeltaMax2\")) opts->hisDeltaMax2\n          else rec[\"hisDeltaMax2\"]\n  if (dTmax1==null or dVmax1==null) return null\n\n  // Initialize previous value and previous timestamp trackers, and result grid\n  prevVal: null\n  prevTs: null\n  result: {}.toGrid()\n\n  pt\n  // Load history\n  .hisRead(dates, {limit: null})\n  \n  // Remove missing or invalid values, missing data stats only based on valid points\n  .hisFindAll(v => v!=null and v!=na())\n  \n  .each row => do\n    // All rows that are not first row\n    if (prevVal != null) do\n      // Calculate delta\n      dT: (row->ts - prevTs)\n      dV: (row->v0 - prevVal)\n      \n      // Flag if data is considered missing\n      missing: (dT.to(1h) > dTmax1.to(1h) and dV.as(1) > dVmax1.as(1))\n               or (dTmax2!=null and dT.to(1h) > dTmax2.to(1h))\n               or (dVmax2!=null and dV.as(1) > dVmax2.as(1))\n      \n      // Credit hours to trend if data is not missing, else credit 0h\n      dT= if (missing) 0h else dT.to(1h)\n      \n      // If yield function is available, yield\n      if (yield != null)\n        yield(row->ts, dT)\n      else\n        result= result.addRow({ts:row->ts, v0:dT})\n    end\n    // Update values\n    prevTs = row->ts\n    prevVal = row->v0\n  end\n  \n  return result\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMoveZonePts33",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  zones: readAll(zone and equip and siteRef->dis==\"33\")\n         .map(row => {id: row->id,\n                      numSupplyTUs: readAll(supply and terminalUnit and equipRef->id==row->id).foldCol(\"id\",count),\n                      supplyTUId: read(supply and terminalUnit and equipRef->id==row->id)->id})\n  zonesOneVAV: zones.findAll(row => row->numSupplyTUs==1)\n  \n  zonesOneVAV.each row => do\n    zoneId: row->id\n    supplyTUId: row->supplyTUId\n    readAll(point and equipRef==zoneId and\n            not pressure and not offset)\n    .each pt => do\n      commit(diff(pt, {equipRef: supplyTUId, tmp: today()}))\n    end\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptSetpointNotMet",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return true when setpoint is not met for longer \n    than a given amount of time\n*/\n\n(rec, dates, opts, yield) => do\n  // Retrieve sensor and setpoint references\n  sensorRef: rec->sensorRef\n  setpointRef: rec->spRef\n  \n  // Retrieve max tolerance and max period\n  tolerance: setpointRef->notMetTolerance\n  maxTime: setpointRef->notMetPeriod\n  \n  // Retrieve and join histories, interpolate\n  inputs: [sensorRef, setpointRef].hisRead(dates, {limit: null}).hisInterpolate({limit: null})\n  \n  // Calculate difference between setpoint and sensor reading\n  difference: inputs.map row => {ts: row->ts, v0: abs(row.get(\"v0\") - row.get(\"v1\"))}\n\n  // Find periods when difference is above tolerance for longer than maxTime\n  oot_periods: difference.hisFindPeriods(x => x > tolerance).findAll(r => r->v0 > maxTime)\n  \n  // Convert back from periods to interval readings and yield\n  inputs.each row => do\n    oot: if (hisInWindows(row->ts, oot_periods)) 1 else 0\n    yield(row->ts, oot)\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptMetricsCommonAreaAirflowPpue",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This virtual point function (hisFunc) calculated the common area airflow\n  pPUE of the common area IT at B59, comparing the airflow cooling systems \n  with the commmon area IT compute kW.\n  \n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n\n  //Common Area IT Power call\n  commITPower: @p:lbnl:r:251434a4-d3b13739\n  \n  interval: rec->hisVirtualInterval\n  \n  //Name the locations for additional power trends needed\n  ahuLocRef: @p:lbnl:r:2373a7aa-df0b1ca4\n  \n  \n  //Grab specific ahu fan power trends for B59\n  ahuFanPowerPts:readAll(locationRef==ahuLocRef\n                    and (equipRef->equipRef->navName == \"AHU-11\" or equipRef->equipRef->navName == \"AHU-12\")\n                    and power\n                    and sensor)\n  \n  //Grab specific ef fan power trends for B59\n  efFanPowerPts:readAll(locationRef==ahuLocRef\n                    and equipRef->equipRef->navName == \"EBL-1A\"\n                    and power\n                    and sensor)\n  \n  //hisRead and rollups for these histories\n  ahuFanPower: ahuFanPowerPts.hisRead(dates, {limit:null})\n                             .hisRollup(avg, interval)\n                             .hisFoldCols(sum)\n                             .renameCol(\"v0\",\"ahuFans\")\n    \n  efFanPower: efFanPowerPts.hisRead(dates, {limit:null})\n                      .hisRollup(avg, interval)\n                      .renameCol(\"v0\",\"efFan\")\n \n  computePower: commITPower.hisRead(dates, {limit:null})\n                              .hisRollup(avg, interval)\n                              .renameCol(\"v0\",\"compute\")\n\n  \n  grid: hisJoin([ahuFanPower, efFanPower, computePower])\n        .addCol(\"commonAreaPpue\", row => do\n          if (row.any(v => v==null or v==na() or v==0)) return na()\n          else return ((row->compute + row->ahuFans + row->efFan) / row->compute).as(1)\n        end)\n        .each(row => yield(row->ts, row->commonAreaPpue))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneCoolingNeeds","toolRecursiveSearch","anAhuZonePressureNeeds","anAhuAirflowsCompare"],,,,M,,,,,,"viAhuDspTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find AHU data points related to the AHU DSP, as well as related\n  terminal unit trends of interest. Analyzes the zone trends to\n  return a summary of zones in need of more airflow / pressure.\n  Load and display historical data for all these points across\n  the given date span.\n  \n  Arguments: \n  ahuRef       ref, id of the AHU\n  dates        dateSpan, dates of data to display\n  coolNeeds    bool, it true, display count of TUs that need cooling\n  statusFilter bool, if true, display trends only when AHU is ON\n  ahuReqs      bool, if true, display AHU request sensor trends\n  tolerance    number, increases ZAT cooling setpoint and reduces\n               ZAT heating setpoint\n  threshold    number, threshold to compare damper position to\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), coolNeeds: false,\n ahuReqs:true, tolerance: 1°F, threshold: 95%,\n rollup: 15min, add:\"\") => do\n  // Calculation of total requests requires a rollup\n  reqRollup: if(rollup < 5min) 5min else rollup\n \n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve and compile counts of zones that need more cooling,\n  // heating or pressure\n  presCount: anAhuZonePressureNeeds(ahuRef, dates, threshold, reqRollup)\n  \n  if (presCount == null)\n    needs: null\n  else\n    needs: presCount\n  \n  if (coolNeeds) do\n    coolCount: anAhuZoneCoolingNeeds(ahuRef, dates, tolerance, reqRollup)\n    if (coolCount != null)\n      if (needs != null)\n        needs= hisJoin([needs,coolCount])\n      else needs= coolCount\n  end\n  \n  // Retrieve weather station points of interest\n  wsOat: read(weatherPoint and weatherRef==ahu->siteRef->weatherRef\n              and air and temp and sensor and not secondary)\n         .hisRead(dates, {limit: null})\n         .addColMeta(\"v0\", {weatherPoint: null, chartGroup: \"OAT\",\n                            color: \"#225600\"})\n  \n  // Retrieve one copy of AHU OAT, if available, to superimpose\n  oatPt: read(point and outside and air and temp and equipRef==ahuRef,\n              false)\n  if (oatPt != null) do\n    oat: oatPt.hisRead(dates, {limit:null})\n              .addColMeta(\"v0\", {color: \"#02ce93\"})\n    oatHis: hisJoin([wsOat, oat.addColMeta(\"v0\", {chartGroup: \"OAT\"})])\n  end else\n    oatHis: wsOat\n  \n  // Retrieve AHU points of interest\n  ahuFilter: \"point and (\"\n             + \"(air and pressure and discharge and equipRef->ahu)\"\n             + \" or ((speed or run) and sensor and equipRef->discharge)\"\n             + (if(ahuReqs) \" or (request and sensor)\" else \"\")\n             + (if(add!=\"\") \" or (\" + add + \")\" else \"\")\n             + \")\"\n  ahuHis: toolRecursiveSearch(ahuRef, ahuFilter)\n          .hisRead(dates, {limit: null})\n   \n  if (isEmpty(ahuHis)) return null\n  \n  // Retrieve airflows\n  airflows: anAhuAirflowsCompare(ahuRef, dates, rollup)\n  \n  // Apply rollup\n  if (rollup > 0) do\n    oatHis= oatHis.hisInterpolate.hisRollupAuto(rollup)\n    ahuHis= ahuHis.hisInterpolate.hisRollupAuto(rollup)\n  end\n  \n  // Join all trends and return\n  hisGrid: [oatHis,ahuHis,needs,airflows]\n           .findAll(g => g != null)\n           .hisJoin()\n  \n  // Format hisGrid with meta\n  hisGrid.removeCols([\"ts\"]).colNames.each colName => do\n    hisGrid= hisGrid.addColMeta(colName, {strokeWidth: 2})\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends","toolRecursiveSearch","anFumeHoodSash"],,,,M,,,,,,"viFumeHoodTrends_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays given trends with formatting.\n  \n  Arguments:\n  fumeHoodRef    Ref to a fume hood equip\n  pointsRefs     list of point IDs, display history for those points\n                 in addition to all fumeHood points\n  span           period to display\n  rollup         time rollup to use for all trends\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(fumeHoodRef:null, pointsRefs:[], span:today()-3day..today()-1day,\n rollup:0, group:\"Default\", tagGroups:[], colorFilters:null,\n width:0, limit:null) => do\n   if (fumeHoodRef==null) return {}.toGrid()\n   else try fumeHood: readById(fumeHoodRef)\n        catch return {}.toGrid()\n \n  gridE: try toolRecursiveSearch(fumeHoodRef, \"point and his\")\n         catch {}.toGrid()\n  \n  gridP: try readByIds(pointsRefs)\n         catch {}.toGrid()\n         \n  grid: if(isEmpty(gridP)) gridE else gridE.addRows(gridP)\n  grid= grid.hisRead(span, {limit:limit})\n\n  // Filter out bad airflow / face velocity\n  // (can be removed once global error handling implemented)\n  grid= grid.hisMap((val, ts, his) => do\n    if(his.has(\"flow\") or his.has(\"speed\")) do\n      if(val==na() or round(val)==0) return na()\n      else return val\n    end\n    else return val\n  end)\n\n  // Perform rollup if requested\n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  sash: anFumeHoodSash(fumeHoodRef,span, 0.1, null, 0cfm)\n  if (sash==null or isEmpty(sash)) null\n  else do\n    if (rollup != 0)\n      try grid= hisJoin([grid, sash.hisRollup(avg, 10min)])\n      catch null\n    else\n      grid= hisJoin([grid, sash])\n  end\n\n  // Add min airflow if available\n  if (fumeHood.has(\"minAirflow\")) do\n    grid= grid.addCol(\"minAirflow\", row => fumeHood->minAirflow)\n              .addColMeta(\"minAirflow\",{air, flow, sp,\n                  dis: fumeHood.dis() + \" Minimum Airflow\",\n                  kind:\"Number\",unit:\"cfm\"})\n  end\n\n  grid= grid.addMeta({title: readById(fumeHoodRef).dis()\n                      + \" trend details\"})\n\n  if (colorFilters==null)\n    colorFilters= [\"air and flow and sensor:mediumseagreen\",\n                   \"damper and cmd:darkslategray\",\n                   \"face and air and speed and sensor:cornflowerblue\",\n                   \"sash and height and sensor:blueviolet\",\n                   \"sp:black\"]\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, null, width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Lagged History",,M,,,,,,"hisTimeCompare_v1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(point, dates, duration) => do\n  r_ts: point.hisRead(dates)\n  r_ts_meta: r_ts.meta\n  r: point.hisRead(dates - duration)\n  v0_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"dis\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  list_ts: colToList(r_ts,\"ts\")\n  list_v0: colToList(r,\"v0\")\n  r_combined: list_ts.toGrid.map( (row,index) => {ts:row->val, v0:list_v0[index]} )\n  r_comb_meta: r_combined.addMeta(r_ts_meta).addMeta({dis: \"LAGGED \"+duration+\" \"+v0_dis})\n  r_out: r_comb_meta.addColMeta(\"v0\", {dis: \"LAGGED \"+duration+\" \"+v0_dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"suTestScramIterations",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  auth: {c:2000, hash:\"SHA-256\", salt:\"dH2YfOhG+Dcc217+zSwAcQ6FT3QT1VMz2Tn0qqBMvzE=\", scheme:\"scram\"}\n  userNew({username:\"testIterations\", dis:\"Test Iter\", user, userRole:\"op\", tz:\"New_York\", userAuth:auth, userPasswordReset})\n  userSetPassword(\"testIterations\", \"tmp0123\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualLinScale",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  value of the source point (referenced by rawRef), scaled based\n  on the linScaleZero and linScaleHundred tag values in the\n  virtual point. Output uses unit \"%\". Output values are clipped\n  at 0% min and 100% max.\n\n  Arguments:\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  rawPt: rec->rawRef\n  \n  if (rec.has(\"linScaleZero\") and rec.has(\"linScaleHundred\")) do\n    zero: rec->linScaleZero\n    hundred: rec->linScaleHundred\n    mult: 100 / (hundred-zero)\n    rawPt.hisRead(dates, {limit: null})\n         .each(row => if (row[\"v0\"] != null)\n                        yield(row->ts, min(100%, max(0%,\n                          (row->v0.as(1) - zero) * mult).as(\"%\")))\n                        )\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["psyWetBulb"],,,,M,,,,,,"calculateWetBulbfromDewPoint",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate wet bulb temperature history from histories of dry bulb temperature, dew point and\n  ambient pressure and write it to history for faster retrieval. If the input is a date,\n  delete, recalculate, and rewrite history since that date. If the input is null, calculate\n  and write only since the last available history point.\n  \n  Arguments:\n  restartDate (optional)   Date to rewrite history from. Must be a date, not a dateTime.\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2018-06-14 //\n*/\n\n(restartDate:null) => do\n  //Initialize important variables.\n  today: now().date\n  ptList: readAll(weatherPoint and virtual and wetBulb and sensor and temp and his and not hisFunc)\n  \n  // For each point, do the following calculations.\n  ptList.each pt => do\n    // Load date for last valid history point, if any\n    hisEnd: pt[\"hisEnd\"]\n\n    // Check restartDate to make sure it is a valid date.\n    if (restartDate != null) do // If there is some input\n      if (restartDate > today) do // If input is a date later than today\n        return {written: null, status: \"Invalid restartDate\"}\n      end else do\n        hisClear(pt,restartDate..today) // Clear history between input date and today\n        hisEnd = dateTime(restartDate, time(0,0,0)) // Then start from that date\n        dates: restartDate..today\n      end\n    end else do\n      // What happens when restartDate is null\n      if (hisEnd == null) do // If there is no history\n        // What happens when restartDate is null and there is no history for that point\n        dates: pastWeek() // Then default back on an arbitrary date\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else do\n        // What happens when restart Date is null and the point already has some history loaded -> append to data\n        dates: hisEnd.date..today\n      end\n    end\n    \n    // Retrieve needed values from other histories associated with same weather station\n    dryBulb: read(weatherPoint and weatherRef==pt->weatherRef\n                  and air and temp and sensor and not secondary)\n             .hisRead(dates, {limit: null})\n    dewPoint: read(weatherPoint and weatherRef==pt->weatherRef\n                   and dew and temp and sensor)\n              .hisRead(dates, {limit: null})\n    ambPressure: read(weatherPoint and weatherRef==pt->weatherRef\n                      and barometric and pressure and sensor)\n                 .hisRead(dates, {limit: null})\n\n    // Join grids and interpolate null values\n    inputGrid: hisJoin([dryBulb, dewPoint, ambPressure], {limit: null}).hisInterpolate({limit: null})\n\n    // For each timestamp, calculate wet bulb temperature and return pair\n    outputGrid: inputGrid.map row => do\n      {\n        ts: row->ts,\n        v0: if(row[\"v0\"] != null and row[\"v1\"] != null and row[\"v2\"] != null)\n              psyWetBulb(row->v0, row->v1, row->v2)\n            else\n              null\n      }\n      end\n\n    // Remove any redundant data that is assumed to already be in history\n    filteredGrid: outputGrid.findAll(row => row->ts > hisEnd and row[\"v0\"] != null)\n\n    // Write the calculated data to point history.\n    hisWrite(filteredGrid, pt)\n    return {written: filteredGrid.size, status: \"OK\"}\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB06RingTempControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readAll((point and locationRef==@p:lbnl:r:23133031-d5f4f137) and ((\n          zone and air and temp and sensor) or (\n          cool and valve and cmd)))\n  .hisRead(span, {limit:limit})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [\"zone and air and temp:70°F,80\",\"cmd and valve:0%,100%\"], width)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDisabledConn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Shows what connectors are disabled. Points associated with\n  a disabled connector are excluded from other dbHisHealth tests.\n  Return grid with:\n    idDisabledConn:   conn id\n    notes:            Connector notes, if any \n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  disabled: readAll(conn and disabled)\n            .map(row =>\n             {idDisabledConn: row->id,\n              notes: row[\"notes\"]\n             }\n            )\n   \n  if (isEmpty(disabled))\n    disabled = {success: \"All connectors active\"}\n               .toGrid\n  \n  return disabled\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d9bce9-061451a1 "dbHisHealth",
,[],,,,M,,,,,,"tmpMap74Zone",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create zones\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b74/vav_equip.csv`)\n  \n  siteDis: \"74\"\n  siteId: read(site and dis==siteDis)->id\n  \n  file.each row => do\n    floorDis: row[\"floor\"]\n    locationDis: \"B74 Floor \" + floorDis    \n    locationId: read(location and siteRef==siteId and\n                  dis==locationDis)->id\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    \n    exist: readAll(siteRef==siteId and \n                   locationRef==locationId and\n                   equip and\n                   navName==room)\n    \n    uriText: row[\"bacnetAddress\"]\n    uri: parseUri(uriText)\n    connRef: read(conn and bacnetConn and uri==uri)->id\n                   \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: roomDis,\n         disMacro: \"\\\$locationRef \\\$navName\",\n         zone,\n         equip,\n         locationRef: locationId,\n         siteRef: siteId,\n         tmp:today()\n        },\n        {add}\n      ))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid"],,,,M,,,,,,"viMeterFormula",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, if this meter has associated formulas\n  return a formatted grid showing the formula\n  \n  Arguments: \n  meterRef        Id of meter to display formulas for\n*/\n\n(meterRef) => do\n  try formula: readById(meterRef)->meterFormula.ioReadZinc()\n  catch return null\n  \n  formula= formula.toGrid()\n                  .sort(\"startInclusive\")\n\n  // Determine what meter columns contain data\n  meterColNames: (0..8).map(v => \"meter\"+v.toStr)\n  meterColNames.each colName => do\n    if (formula.colToList(colName)\n               .findAll(v => v != \"\")\n               .isEmpty)\n      meterColNames= meterColNames\n      .remove(meterColNames.index(colName))\n  end\n  if (isEmpty(meterColNames)) return null\n\n  disColNames: [\"startInclusive\",\"endExclusive\"]\n  disColNames= disColNames.addAll(meterColNames)\n  disColNames= disColNames.addAll([\"globalMult\",\"globalAdder\"])\n  \n  formula= toolFormatGrid(formula, disColNames)\n  return formula\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridGapsPeriods"],,,,M,,,,,,"toolPointsDataGaps",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given grid of point refs or point records, load history\n  data for each point, analyze the presence of data gaps using \n  toolHisGridGaps, and combine the results into one trend.\n  \n  Arguments:\n  ptRefs          Grid of point records to analyze\n  dates           Span to run analysis on\n  maxGap          Number (time), longest allowed gap between readings\n  method          Str, \"Union\" or \"Intersection\"\n*/\n\n(ptRefs, dates, maxGap:1min, method:\"Union\") => do\n  grids: []\n  \n  ptRefs.each ptRef => do\n    if (isRef(ptRef)) pt: readById(ptRef)\n    else pt: ptRef\n    \n    gridGap: pt.hisRead(dates, {limit: null})\n               .toolHisGridGapsPeriods(maxGap)\n               .hisFindPeriods(v => v)\n                            \n    grids= grids.add(gridGap)\n  end\n  \n  grids= if (method==\"Union\") grids.hisPeriodUnion\n         else grids.hisPeriodIntersection\n  \n  return grids.addMeta({view:\"chart\"})\n              .addColMeta(\"v0\",\n                {dis: method+\" of Data Gaps > \"+maxGap})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolSummarizeCol",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(grid, colName, priorityList:null) => do\n  if (not(grid.has(colName))) return null\n  list: grid.colToList(colName).unique().findAll(v => v!=null)\n  if (list.size==0) return null\n  if (list.size==1) return list[0]\n  \n  if (priorityList==null) do\n    g: list.map(v => {item:v}).toGrid\n    g.addCol(\"count\", row => grid.colToList(colName).findAll(v => v==row->item).size)\n     .sortr((a,b) => a->count <=> b->count)\n  \n    return g[0]->item+\"+\"\n  end else do\n    priorityList= priorityList\n                  .map(pItem => if (list.contains(pItem)) pItem else null)\n                  .findAll(v => v!=null)\n    return priorityList[0]\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolModelStats",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Perform a linear regression of the data in a provided grid based\n  on provided columns names that identify y values and x values. Return\n  a dictionary of results including regression coefficients and\n  model fit statistics.\n  \n  Arguments: \n  grid       Data grid\n  yCol       Name of column with y values\n  xCols      List, names of column(s) with x values\n*/\n(grid, yCol, xCols) => do\n  // Remove rows with any null values (typically ignored values)\n  grid= grid.findAll(r => r.all(v => v != null))\n  \n  // Perform regression\n  yCol= if (isList(yCol)) yCol[0] else yCol\n  yColList: [yCol]\n  xColsList: if (isList(xCols)) xCols else [xCols]\n  y: grid.keepCols(yColList)\n  x: grid.keepCols(xColsList)\n  reg: try matrixFitLinearRegression(y, x)\n       catch return null\n       \n  // Initialize results dictionary\n  results: {}\n  \n  // Extract coefficients\n  results= results.set(\"a\", reg.meta[\"bias\"])\n  xColsList.each((xCol, i) =>\n    results= results.set(\"b\"+capitalize(xCol), reg[i][\"b\"]))\n\n  // Calculate fitted values using coefficients\n  grid= grid.addCol(\"fitted\", row => do\n      v: reg.meta[\"bias\"]\n      xColsList.each((xCol, i) => v = v + reg[i][\"b\"] * row[xCol])\n      return v.as(row[yCol])\n    end)\n  \n  // Calculate statistics\n  measuredTotal: grid.foldCol(yCol, sum)\n  n: reg.meta[\"rowCount\"]\n  measuredAvg: measuredTotal / n\n  perror: grid.addCol(\"ae\", row => abs((row->fitted - row[yCol])/row[yCol]))\n              .foldCol(\"ae\", sum)\n  sqError: grid.addCol(\"se\", row => pow(row->fitted - row[yCol], 2))\n               .foldCol(\"se\", sum)\n  p: xColsList.size\n  mse: sqError / (n-p)\n  mape: perror / n\n  rmse: sqrt(mse)\n  cvrmse: rmse / measuredAvg\n\n  // Build dictionary of results\n  regRes: {\n    rSquared: reg.meta[\"r2\"],\n    n: n,\n    p: p,\n    measuredAvg: measuredAvg,\n    mape: (mape*100).as(1%),\n    mse: mse,\n    rmse: rmse,\n    cvrmse: (cvrmse*100).as(1%)\n  }\n  .each((v,n) => results= results.set(n,v))\n  \n  return results\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"ptVirtualWaterLoad",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates historical values for a virtual water load\n  point based on the supply temperature, return temperature and flow\n  sensors that are part of the same equip.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  \n  mult: if (rec[\"multiplierNeeded\"] == null) 1 else rec[\"multiplierNeeded\"]\n  ptUnit: if (rec[\"unit\"] == null) \"BTU/h\" else rec[\"unit\"]\n  \n  flow: read(flow and sensor and equipRef==rec->equipRef, false)\n  sup: read(supply and temp and sensor and equipRef==rec->equipRef, false)\n  ret: read(\"return\" and temp and sensor and equipRef==rec->equipRef, false)\n  \n  [flow, sup, ret].hisRead(dates, {limit: null})\n      .renameCol(\"v0\",\"flow\")\n      .renameCol(\"v1\",\"tSup\")\n      .renameCol(\"v2\",\"tRet\")\n      .toolHisAlign(avg, max, true)  // rollupFunc, intervalFunc, removeMissing\n      .addCol(\"load\", r => do\n        flow: if (r[\"flow\"] == null or r[\"flow\"] == na()) return na()\n              else r->flow.to(\"gal/min\")\n        tSup: if (r[\"tSup\"] == null or r[\"tSup\"] == na()) return na()\n              else r->tSup.to(\"°F\")\n        tRet: if (r[\"tRet\"] == null or r[\"tRet\"] == na()) return na()\n              else r->tRet.to(\"°F\")\n              \n        return (flow * (tSup - tRet) * 500.4 * mult).as(\"BTU/h\").to(ptUnit)\n      end)\n      .keepCols([\"ts\",\"load\"])\n      .each(row => if(row[\"load\"] != na()) yield(row->ts, row->load))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateDeficiency"],,,,M,,,,,,"recEditDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyDict) => do\n  // Normalize action input\n  deficiencyDict= actionNormInput(deficiencyDict, \"dict\")\n  \n  if(deficiencyDict.has(\"equipRef\") and deficiencyDict[\"equipRef\"]!=removeMarker())\n    deficiencyDict= deficiencyDict\n      .set(\"siteRef\", readById(deficiencyDict[\"equipRef\"])->siteRef)\n      .set(\"locationRef\", readById(deficiencyDict[\"equipRef\"])->locationRef)\n      .set(\"disMacro\", \"\\\$equipRef \\\$navName\")\n  else if (deficiencyDict.has(\"siteRef\")  and deficiencyDict[\"siteRef\"]!=removeMarker()) do\n    siteRec: readById(deficiencyDict[\"siteRef\"])\n    deficiencyDict= deficiencyDict\n    .set(\"disMacro\", if (parseNumber(siteRec->dis, false)==null) \"\\\$siteRef \\\$navName\"\n                     else \"B\\\$siteRef \\\$navName\")\n  end\n\n  deficiencyDict= deficiencyDict\n                  .remove(\"hasResponses\")\n                  .set(\"lastModifiedBy\", userCur()->dis)\n\n  // Validate record\n  // deficiencyDict= recValidateDeficiency(deficiencyDict)\n\n  recEdit(deficiencyDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"ptVirtualPUE",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load history of numerator and denominator points on same equip, which\n  must have the same unit. Calculate ratio. This function assumes the\n  numerator and denominator already have aligned histories.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n\n  Tags:\n  - virtual\n  --- hisFunc\n  --- hisInterval (optional)\n*/\n\n(rec, dates, opts, yield) => do\n  // Determine numerator and denominator\n  numeratorPt: read(numerator and equipRef==rec->equipRef, false)\n  denominatorPt: read(denominator and equipRef==rec->equipRef, false)\n  if (numeratorPt==null or denominatorPt==null) return null\n  if (numeratorPt->unit != denominatorPt->unit) return null\n  \n  // Check for presence of hisInterval tag\n  rollup: if (rec.has(\"hisInterval\")) rec->hisInterval\n          else null\n\n  // Read available history, align, calculate ratio, yield\n  hisGrid: [numeratorPt, denominatorPt]\n           .hisRead(dates, {limit:null})\n  if (rollup != null)\n    hisGrid= hisGrid.toolHisAlign(avg, min,         // rollupFunc, intervalFunc\n                                  true, rollup)     // removeMissing, minRollup\n  else\n    // If not using toolHisAlign, remove rows for which any column\n    // is missing a value (null)\n    hisGrid= hisGrid.findAll(r => r.all(v => v != null))\n  \n  hisGrid= hisGrid\n  .addCol(\"pue\", row => do\n      num: row->v0\n      denom: row->v1\n      if (num==na() or denom==na()) return na()\n      if (num==null or denom==null) return null\n      if (denom==0) return na()\n      return (num.as(1) / denom.as(1)).as(rec->unit)\n  end)\n  .each(row => yield(row->ts, row->pue))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends"],,,,M,,,,,,"viB37TRWPressControls",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays specific trends with formatting.\n  \n  Arguments: \n  span           period to display\n  rollup         time rollup to use for all trends\n  addPointsRefs  list of point IDs, add history for those points to results\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n*/\n\n(span:today()-3day..today()-1day, rollup:0, addPointsRefs:[],\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null) => do\n  grid:\n  readByIds([@p:lbnl:r:236cedc4-aa786cf9,\n             @p:lbnl:r:236b4e12-840a2289,\n             @p:lbnl:r:236b4e12-3cb6a795,\n             @p:lbnl:r:236b4e12-d3286b05,\n             @p:lbnl:r:236b4e12-730490d5,\n             @p:lbnl:r:236b4e12-8bcc8441,\n             @p:lbnl:r:236b4e12-800f2822,\n             @p:lbnl:r:236b4e12-743970a3,\n             @p:lbnl:r:236b4e12-f1c07022])\n  .hisRead(span, {limit:null})\n  // Convert loads to tonref\n  .hisMap((val, ts, his) =>\n    if (readById(his->equipRef).has(\"load\") and his.has(\"power\")\n        and val != null)\n      return val.to(\"tonref\")\n    else return val)\n  \n  if (addPointsRefs != null and not(isEmpty(addPointsRefs))) do\n    try addGrid: readByIds(addPointsRefs).hisRead(span, {limit:limit})\n    catch return {error: \"Invalid addPointsRefs parameter\"}.toGrid()\n    \n    if (group==\"Added points together\")\n      addGrid.colNames.remove(0).each colName => do\n        addGrid= addGrid.addColMeta(colName, {chartGroup:\"AddedPts\"})\n      end\n    else null\n  \n    grid= hisJoin([grid, addGrid])\n  end\n  \n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  return grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viCTOperations",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find wetbulb temperature, tower water supply setpoint and temperature\n  and tower fan speed for a given time range\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n  addedPtRecs      Optional, grid of additional points to show on graph\n*/\n\n(wbLocation:null, sysRef:null, dates: today, rollup: 5min) => do\n  // Default to B59 TW Plant if no ref is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and condenserWaterPlant and navName==\"Plant\")\n    \n  sysRef= sysRef->id  \n  \n  // Default to B59 TW Plant Wetbulb if no ref is provided\n  if(wbLocation==null)\n    wbLocation= read(equip and siteRef->dis==\"59\" and condenserWaterPlant and navName==\"Plant\")\n    \n  wbLocation= wbLocation->id  \n    \n  // Get the supply setpoint and temp for tower water\n  twSupplyTempPts: read(equipRef==sysRef\n                    and temp\n                    and sensor\n                    and water)\n  twSupplySP: read(equipRef==sysRef\n                    and temp\n                    and sp\n                    and water)\n  wbTemp: read(equipRef==wbLocation\n                    and temp\n                    and sensor\n                    and wetBulb) \n                    \n  // Read out the histories for the three temperatures\n  twSupplyTrend: hisRead(twSupplyTempPts, dates, {limit:null})\n                    .renameCol(\"v0\",\"twSupply\")\n                    .hisRollup(avg, rollup)\n  \n      twSPTrend: hisRead(twSupplySP, dates, {limit:null})\n                    .renameCol(\"v0\",\"twSP\")  \n                    .hisRollup(avg, rollup)\n  \n    wbTempTrend: hisRead(wbTemp, dates, {limit:null})\n                    .renameCol(\"v0\",\"oaWetbulb\")\n                    .hisRollup(avg, rollup)\n  \n  // Get all the CT Fan Speeds\n    ctFanSpeeds: readAll(locationRef==sysRef->locationRef\n                     and equipRef->fan\n                     and speed\n                     and sensor)\n  \n  // Average the histories for all the Fan Speeds \n    avgFanSpeeds: hisRead(ctFanSpeeds, dates, {limit:null})\n                    .hisRollup(avg, rollup)\n                    .hisFoldCols(avg)\n                \n  //Join the histories into a common map\n        combined: hisJoin([wbTempTrend, twSupplyTrend, twSPTrend, avgFanSpeeds])\n                    .addColMeta(\"twSupply\",\n                      {dis: \"TW Supply Temp\",\n                      unit: \"°F\", color: \"#008080\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"twSP\",\n                      {dis: \"TW Supply Temp Setpoint\",\n                      unit: \"°F\", color: \"#48D1CC\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"oaWetbulb\",\n                      {dis: \"Outside Air Wetbulb Temp\",\n                      unit: \"°F\", color: \"#4B0082\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"v0\",\n                      {dis: \"Average Cooling Tower Fan Speed\",\n                      unit: \"%\", color: \"#FF8C00\",\n                      chartGroup: \"all\"})\n  return combined\nend\n                    \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridShowGaps","gapExists","toolHisAlign","toolRecursiveSearch","benchmarkDataLBT"],,,,M,,,,,,"benchmarkDataLBT",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function grabs data relevant to the LBT Benchmarking tool\n  and outputs a report that nicely gives the answers to the\n  questions on the website.\n  \n  There are 17 fields we will try to find. If a field does not have\n  sufficient info, the report will simply output \"Insufficient\n  Data.\"\n  \n  Arguments:\n  building                 Reference to desired building\n  \n  maxGap:                  The threshold at which we want to alert\n                           the user that there is a significant gap\n                           that we may want to examine\n  \n  year (optional)          Desired calendar year. Default is year\n                           previous to current year.\n                           \n  // Helpful code for seeing the peaks: benchmarkDataLBT()[6][\"metric\"] for Building Peak Elec\n  //   - you can change the 6 to a row with multiple vals (zero-indexed)\n  //   - benchmarkDataLBT()[12][\"metric\"] for Ventilation Peaks\n  //   - benchmarkDataLBT()[15][\"metric\"] for Peak Airflow\n\n  // Sustainable Berkeley Lab // AMP // Last Update: 2019-11-19 //\n*/\n\n(buildRef:null,maxGap:2day,dataYear:now().year-1,yearOverride:false) => do\n  //buildRef = @p:lbnl:r:22399b67-d9dcb8b7 // 30\n  buildRef= @p:lbnl:r:21cd60fc-808d8404 // 33\n  //buildRef= @p:lbnl:r:22c912f0-91f6badd // 74\n  //buildRef= @p:lbnl:r:225ffa71-7758e5e3 // 67\n  \n  if (dataYear>now().year) return \"Future year entered\"\n  if (dataYear==now().year and yearOverride==false) return \"Year is incomplete\"\n  dates: date(dataYear,1,1)..date(dataYear,12,31)\n  // for a different year other than previous calendar year, use syntax benchmarkDataLBT(null,2day,2018,false)\n  \n  //////////////////////////////////////////\n  // 1. Building Electricity (kWh)        //\n  //////////////////////////////////////////\n  \n  //    Check if the electricity history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the elec hist\n  location1: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\"))\n  locRef1: location1[\"id\"]\n  meter1: readAll(equip and meter and virtual and elec and not submeterOf)\n            .find(met => met[\"locationRef\"]==locRef1)\n  if (meter1!=null) do\n    metRef1: meter1[\"id\"]\n  end else do\n    metRef1: null\n  end\n  if (metRef1!=null) do\n    point1: read(point and energy and his and virtual and equipRef==metRef1)\n  end else do\n    point1: null\n  end\n  if (point1!=null and point1.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point1.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment1: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment1: \"No data significant gaps.\"\n    end\n    \n    // Sum all values in that column.\n    metric1: point1.hisRead(dates, {limit:null}).hisFoldCols(sum)\n               .foldCol(\"v0\",sum)\n    metric1 = metric1.to(\"kWh\") // convert to kWh if not already kWh\n  end else do\n    metric1: \"Insufficient Data\"\n    comment1: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 2. Building Natural Gas (therms)     //\n  //////////////////////////////////////////\n  \n  //    Check if the natural gas history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the gas hist.\n  location2: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\")==true)\n  locRef2: location2[\"id\"]\n  meter2: readAll(equip and meter and virtual and gas and not submeterOf)\n            .find(met => met[\"locationRef\"]==locRef2)\n  if (meter2!=null) do\n    metRef2: meter2[\"id\"]\n  end else do\n    metRef2: null\n  end\n  if (metRef2!=null) do\n    point2: read(point and energy and his and virtual and equipRef==metRef2)\n  end else do\n    point2: null\n  end\n  if (point2!=null and point2.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point2.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment2: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment2: \"No data significant gaps.\"\n    end\n    \n    // Sum all values in that column.\n    metric2: point2.hisRead(dates, {limit:null}).hisFoldCols(sum)\n               .foldCol(\"v0\",sum)\n    metric2 = metric2.to(\"therm\") // convert to therms if not already\n  end else do\n    metric2: \"Insufficient Data\"\n    comment2: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 3. Building CHW (ton-hrs)            //\n  //////////////////////////////////////////\n  \n  metric3: \"Insufficient Data\"\n  comment3: \"Most likely 0 bc it's district.\"\n  \n  //////////////////////////////////////////\n  // 4. Building DHW (MMBTU)              //\n  //////////////////////////////////////////\n  \n  //    Check if the natural gas history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the gas hist.\n  location4: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\")==true)\n  locRef4: location4[\"id\"]\n  meter4: readAll(equip and meter and gas and submeterOf)\n                 .find(met => met[\"locationRef\"]==locRef4 and met[\"navName\"].contains(\"DHW\"))\n  if (meter4!=null) do\n    metRef4: meter4[\"id\"]\n  end else do\n    metRef4: null\n  end\n  if (metRef4!=null) do\n    point4: read(point and energy and his and equipRef==metRef4 and not accumulator)\n  end else do\n    point4: null\n  end\n  if (point4!=null and point4.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point4.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment4: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment4: \"No data significant gaps.\"\n    end\n    \n    // Sum all values in that column.\n    metric4: point4.hisRead(dates, {limit:null}).hisFoldCols(sum)\n               .foldCol(\"v0\",sum)\n    metric4 = metric4.to(\"MMBTU\") // convert to MMBTU if not already\n  end else do\n    metric4: \"Insufficient Data\"\n    comment4: \"N/A\"\n  end\n  comment4 = \"Most likely 0 bc district.\"\n  \n  //////////////////////////////////////////\n  // 4b. Building HHW (MMBTU)             //\n  //////////////////////////////////////////\n  \n  //    Borrow most of the work from (4)\n  location4b: location4\n  locRef4b: locRef4\n  meter4b: readAll(equip and meter and gas and submeterOf)\n                 .find(met => met[\"locationRef\"]==locRef4b and met[\"navName\"].contains(\"HHW\"))\n  if (meter4b!=null) do\n    metRef4b: meter4b[\"id\"]\n  end else do\n    metRef4b: null\n  end\n  if (metRef4b!=null) do\n    point4b: read(point and energy and his and equipRef==metRef4b and not accumulator)\n  end else do\n    point4b: null\n  end\n  if (point4b!=null and point4b.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point4b.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment4b: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment4b: \"No data significant gaps.\"\n    end\n    \n    // Sum all values in that column.\n    metric4b: point4b.hisRead(dates, {limit:null}).hisFoldCols(sum)\n               .foldCol(\"v0\",sum)\n    metric4b = metric4b.to(\"MMBTU\") // convert to MMBTU if not already\n  end else do\n    metric4b: \"Insufficient Data\"\n    comment4b: \"N/A\"\n  end\n  comment4b = \"Most likely 0 bc district.\"\n  \n  //////////////////////////////////////////\n  // 4c. Building DHW + HHW (MMBTU)       //\n  //////////////////////////////////////////\n  metric4c: metric4+metric4b\n  comment4c: \"Most likely 0 bc it's district.\"\n  \n  //////////////////////////////////////////\n  // 5. Building Peak Electricity (kW)    //\n  //////////////////////////////////////////\n  \n  //    We did much of the work in (1). Set metRef5 equal to metRef1.\n  //    Point5 will have almost all the same tags, but instead of energy\n  //    and metRef1 it will have power and metRef5\n  metRef5: metRef1\n  point5: read(point and power and his and virtual and equipRef==metRef5)\n  \n  //    Check if the electricity history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the elec hist.\n  if (point5.hisRead(dates).hisClip.size > 2) do\n    \n    // Check if there is a significant data gap.\n    if (point5.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment5: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment5: \"No data significant gaps.\"\n    end\n    \n    // Find the max of all values in that column.\n    // First store the history in the variable buildPeakElecHis.\n    // Then find the max of that history and store it as met5_1.\n    // Finally, remove that max from buildPeakElecHis then find the next max.\n    // Repeat to find 3 maximums.\n    buildPeakElecHis: point5.hisRead(dates, {limit:null}).hisFoldCols(sum)\n    met5_1: buildPeakElecHis.foldCol(\"v0\",max)\n    buildPeakElecHis= buildPeakElecHis.findAll(row => row->v0 != met5_1)\n    met5_2: buildPeakElecHis.foldCol(\"v0\",max)\n    buildPeakElecHis= buildPeakElecHis.findAll(row => row->v0 != met5_1 and row->v0 != met5_2)\n    met5_3: buildPeakElecHis.foldCol(\"v0\",max)\n    metrics5:[met5_1,met5_2,met5_3]\n    metric5: metrics5.map m => do\n      {max: m.to(\"kW\")} // convert to kW if not already kW\n      end\n  end else do\n    metric5: \"Insufficient Data\"\n    comment5: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 6. Plug Elec (kWh)                   //\n  //////////////////////////////////////////\n  \n  //    Check if the electricity history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the elec hist\n  location6: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\"))\n  locRef6: location6[\"id\"]\n  meter6: readAll(equip and meter and elec and submeterOf)\n            .find(met => met[\"locationRef\"]==locRef6 and met[\"navName\"].contains(\"Plug\")\n             and met[\"navName\"].contains(\"All\"))\n  if (meter6!=null) do\n    metRef6: meter6[\"id\"]\n  end else do\n    metRef6: null\n  end\n  if (metRef6!=null) do\n    point6: read(point and energy and his and equipRef==metRef6)\n  end else do\n    point6: null\n  end\n  if (point6!=null and point6.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point6.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment6: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment6: \"No data significant gaps.\"\n    end\n    \n    // Sum all values in that column.\n    metric6: point6.hisRead(dates, {limit:null}).hisFoldCols(sum)\n               .foldCol(\"v0\",sum)\n    metric6 = metric6.to(\"kWh\") // convert to kWh if not already kWh\n  end else do\n    metric6: \"Insufficient Data\"\n    comment6: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 7. Ventilation Elec (kWh)            //\n  //////////////////////////////////////////\n  \n  equip7: readAll(fan and (equipRef->ahu or equipRef->exhaustSystem))\n                  .findAll(eq => eq[\"siteRef\"]==buildRef)\n  \n  if (not isEmpty(equip7)) do\n    equipIdsList7: equip7.colToList(\"id\")\n    points7: readAll(point and his and power)\n                    .findAll(pt => equipIdsList7.contains(pt[\"equipRef\"]))\n    //colNames7: points7.colToList(\"id\")\n    if (not isEmpty(points7) and points7.hisRead(dates).hisClip.size > 2) do\n      try do\n        ventPowerHis: points7.hisRead(dates,{limit:null}).hisClip\n        ventPowerHisFiltered: ventPowerHis.toolHisAlign             // for use in (11)\n        ventPowerHisFiltered= ventPowerHisFiltered.hisFoldCols(sum) // for use in (11)\n        ventPowerHisRoll: ventPowerHis.hisRollup(sum,1hr)\n        ventPowerHisRollFiltered: ventPowerHisRoll.toolHisAlign\n        ventPowerHisRollFiltered= ventPowerHisRollFiltered.hisFoldCols(sum)\n        comment7: toStr(ventPowerHisRollFiltered.size)+\" hours of \"+toStr(ventPowerHisRoll.size)+\" counted.\"\n        metric7: ventPowerHisFiltered.toolHisGridShowGaps(15min)\n                                     .hisRollup(avg,1hr)\n                                     .foldCol(\"v0\",sum).as(\"kWh\")\n        if (points7.size!=equip7.size) comment7= \"Point list size does not match equipment list size. \"+comment7\n        if (metric7==null) metric7= \"Some points empty.\"\n        end catch do\n          comment7: \"Probably an NA in His\"\n          metric7: \"Insufficient Data\"\n        end\n    end else do\n      metric7: \"Insufficent Data\"\n      comment7: \"No points\"\n    end\n  end else do\n    metric7: \"Insufficient Data\"\n    comment7: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 8. Cooling Plant Elec (kWh)          //\n  //////////////////////////////////////////\n  \n  try\n    points8: toolRecursiveSearch(read(chilledWaterPlant and siteRef->id==buildRef)->id, \"power and sensor and not equipRef->load\", [\"equipRef\"])\n    catch\n      points8: readAll(nothing and not nothing) // Create empty list\n  \n  if (not isEmpty(points8) and points8.hisRead(dates).hisClip.size > 0) do\n    try do\n      coolPlantHis: points8.hisRead(dates,{limit:null}).hisClip\n      coolPlantHisFiltered: coolPlantHis.toolHisAlign             // for use in (12)\n      coolPlantHisFiltered= coolPlantHisFiltered.hisFoldCols(sum) // for use in (12)\n      coolPlantHisRoll: coolPlantHis.hisRollup(sum,1hr)\n      coolPlantHisRollFiltered: coolPlantHisRoll.toolHisAlign\n      coolPlantHisRollFiltered= coolPlantHisRollFiltered.hisFoldCols(sum)\n      comment8: toStr(coolPlantHisRollFiltered.size)+\" hours of \"+toStr(coolPlantHisRoll.size)+\" counted.\"\n      metric8: coolPlantHisFiltered.toolHisGridShowGaps(15min)\n                                   .hisRollup(avg,1hr)\n                                   .foldCol(\"v0\",sum).as(\"kWh\")\n      equips8: toolRecursiveSearch(read(chilledWaterPlant and siteRef->id==buildRef)->id, \"equip and (chiller or pump or fan)\", [\"equipRef\"])\n      if (points8.size!=equips8.size) comment8= \"Point list size does not match equipment list size. \"+comment8\n      end\n      catch\n        comment8: \"Probably an NA in his\"\n        metric8: \"Insufficient Data\"\n  end else do\n    metric8: \"Insufficient Data\"\n    comment8: \"Points list empty.\"\n  end\n  \n  //////////////////////////////////////////\n  // 9. Lighting Elec (kWh)               //\n  //////////////////////////////////////////\n  \n  //    Check if the electricity history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the elec hist\n  location9: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\"))\n  locRef9: location9[\"id\"]\n  meter9: readAll(equip and meter and elec and submeterOf)\n            .find(met => met[\"locationRef\"]==locRef9 and met[\"navName\"].contains(\"Lighting\"))\n  if (meter9!=null) do\n    metRef9: meter9[\"id\"]\n  end else do\n    metRef9: null\n  end\n  if (metRef9!=null) do\n    point9: read(point and energy and his and equipRef==metRef9 and not accumulator)\n  end else do\n    point9: null\n  end\n  if (point9!=null and point9.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point9.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment9: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment9: \"No data significant gaps.\"\n    end\n    \n    // Sum all values in that column.\n    metric9: point9.hisRead(dates, {limit:null}).hisFoldCols(sum)\n               .foldCol(\"v0\",sum)\n    metric9 = metric9.to(\"kWh\") // convert to kWh if not already kWh\n  end else do\n    metric9: \"Insufficient Data\"\n    comment9: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 10. Plug Peak Electricity (kW)       //\n  //////////////////////////////////////////\n  \n  //    We did much of the work in (6). Set metRef10 equal to metRef6.\n  //    Point10 will have almost all the same tags, but instead of energy\n  //    and metRef6 it will have power and metRef10\n  metRef10: metRef6\n  if (metRef10!=null) do\n    point10: read(point and power and his and virtual and equipRef==metRef10)\n  end else do\n    point10: null\n  end\n  \n  //    Check if the electricity history is empty. If empty say\n  //    \"Insufficient Data.\"\n  if (point10!=null and point10.hisRead(dates).hisClip.size > 2) do\n    \n    // Check if there is a significant data gap.\n    if (point10.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment10: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment10: \"No data significant gaps.\"\n    end\n    \n    // Find the max of all values in that column.\n    // First store the history in the variable plugPeakElecHis.\n    // Then find the max of that history and store it as met5_1.\n    // Finally, remove that max from plugPeakElecHis then find the next max.\n    // Repeat to find 3 maximums.\n    plugPeakElecHis: point10.hisRead(dates, {limit:null}).hisFoldCols(sum)\n    met10_1: plugPeakElecHis.foldCol(\"v0\",max)\n    plugPeakElecHis= plugPeakElecHis.findAll(row => row->v0 != met10_1)\n    met10_2: plugPeakElecHis.foldCol(\"v0\",max)\n    plugPeakElecHis= plugPeakElecHis.findAll(row => row->v0 != met10_1 and row->v0 != met10_2)\n    met10_3: plugPeakElecHis.foldCol(\"v0\",max)\n    metrics10:[met10_1,met10_2,met10_3]\n    metric10: metrics10.map m => do\n      {max: m.to(\"kW\")} // convert to kW if not already kW\n      end\n    //metric10= [{max:500kW},{max:97kW},{max:96kW}]\n  end else do\n    metric10: \"Insufficient Data\"\n    comment10: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 11. Ventilation Peak (kW)            //\n  //////////////////////////////////////////\n  equip11: equip7\n  \n  if (not isEmpty(equip11)) do\n    equipIdsList11: equipIdsList7\n    points11: points7\n    //colNames11: colNames7\n    if (not isEmpty(points11) and points11.hisRead(dates).hisClip.size > 0) do\n      if (ventPowerHisFiltered.size > 3) do\n        met11_1: ventPowerHisFiltered.foldCol(\"v0\",max).to(\"kW\")\n        ventPowerHisFiltered= ventPowerHisFiltered.findAll(row => row->v0 != met11_1)\n        met11_2: ventPowerHisFiltered.foldCol(\"v0\",max).to(\"kW\")\n        ventPowerHisFiltered= ventPowerHisFiltered.findAll(row => row->v0 != met11_1 and row->v0 != met11_1)\n        met11_3: ventPowerHisFiltered.foldCol(\"v0\",max).to(\"kW\")\n        metric11:[{max:met11_1},{max:met11_2},{max:met11_3}]\n        comment11: comment7\n      end else do\n        metric11: \"Insufficient Data\"\n        comment11: \"Fewer than 3 data points\"\n    end else do\n      metric11: \"Insufficent Data\"\n      comment11: \"No points\"\n    end\n  end else do\n    metric11: \"Insufficient Data\"\n    comment11: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 12. Cooling Plant Peak (kW)          //\n  //////////////////////////////////////////\n  \n  points12: points8\n  \n  if (not isEmpty(points12) and points12.hisRead(dates).hisClip.size > 0) do\n    if (ventPowerHisFiltered.size > 3) do\n      met12_1: coolPlantHisFiltered.foldCol(\"v0\",max).to(\"kW\")\n      coolPlantHisFiltered= coolPlantHisFiltered.findAll(row => row->v0 != met12_1)\n      met12_2: coolPlantHisFiltered.foldCol(\"v0\",max).to(\"kW\")\n      coolPlantHisFiltered= coolPlantHisFiltered.findAll(row => row->v0 != met12_1 and row->v0 != met12_1)\n      met12_3: coolPlantHisFiltered.foldCol(\"v0\",max).to(\"kW\")\n      metric12:[{max:met12_1},{max:met12_2},{max:met12_3}]\n      comment12: comment8\n    end else do\n      metric12: \"Insufficient Data\"\n      comment12: \"Fewer than 3 data points\"\n  end else do\n    metric12: \"Insufficent Data\"\n    comment12: \"No points\"\n  end\n  \n  //////////////////////////////////////////\n  // 13. Lighting Peak Electricity (kW)   //\n  //////////////////////////////////////////\n  \n  //    We did much of the work in (6). Set metRef13 equal to metRef6.\n  //    Point10 will have almost all the same tags, but instead of energy\n  //    and metRef6 it will have power and metRef13\n  metRef13: metRef9\n  if (metRef13!=null) do\n    point13: read(point and power and his and equipRef==metRef13)\n  end else do\n    point13: null\n  end\n  \n  //    Check if the electricity history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the elec hist.\n  if (point13!=null and point10.hisRead(dates).hisClip.size > 2) do\n    \n    // Check if there is a significant data gap.\n    if (point13.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment13: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment13: \"No data significant gaps.\"\n    end\n    \n    // Find the max of all values in that column.\n    // First store the history in the variable lightingPeakElecHis.\n    // Then find the max of that history and store it as met13_1.\n    // Finally, remove that max from lightingPeakElecHis then find the next max.\n    // Repeat to find 3 maximums.\n    lightingPeakElecHis: point13.hisRead(dates, {limit:null}).hisFoldCols(sum)\n    met13_1: lightingPeakElecHis.foldCol(\"v0\",max)\n    lightingPeakElecHis= lightingPeakElecHis.findAll(row => row->v0 != met13_1)\n    met13_2: lightingPeakElecHis.foldCol(\"v0\",max)\n    lightingPeakElecHis= lightingPeakElecHis.findAll(row => row->v0 != met13_1 and row->v0 != met13_2)\n    met13_3: lightingPeakElecHis.foldCol(\"v0\",max)\n    metrics13:[met13_1,met13_2,met13_3]\n    metric13: metrics13.map m => do\n      {max: m.to(\"kW\")} // convert to kWh if not already kWh\n      end\n  end else do\n    metric13: \"Insufficient Data\"\n    comment13: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 14. Peak Airflow (cfm)               //\n  //////////////////////////////////////////\n  \n  equip14: readAll(equip and ahu and not vfd and not virtual).findAll(equip => equip[\"siteRef\"]==buildRef)\n  \n  if (equip14!=null) do\n    equipIdsList14: equip14.colToList(\"id\")\n    points14: readAll(point and his and discharge and air and flow and not virtual)\n              .findAll(pt => equipIdsList14.contains(pt[\"equipRef\"]))\n    if (points14!=null and points14.hisRead(dates).hisClip.size > 2) do\n      // Check if there is a significant data gap.\n      if (points14.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n        comment14: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n      end else do\n        comment14: \"No data significant gaps.\"\n      end\n      airflowHis: points14.hisRead(dates,{limit:null})\n      airflowHis= airflowHis.toolHisAlign\n\n      // Find the max of all values in that column.\n      // First store the history in the variable airflowHis.\n      // Then find the max of that history and store it as met14_1.\n      // Finally, remove that max from airflowHis then find the next max.\n      // Repeat to find 3 maximums.\n      airflowHis= airflowHis.hisFoldCols(sum)\n      met14_1: airflowHis.foldCol(\"v0\",max)\n      airflowHis= airflowHis.findAll(row => row->v0 != met14_1)\n      met14_2: airflowHis.foldCol(\"v0\",max)\n      airflowHis= airflowHis.findAll(row => row->v0 != met14_1 and row->v0 != met14_2)\n      met14_3: airflowHis.foldCol(\"v0\",max)\n      metrics14:[met14_1,met14_2,met14_3]\n      metric14: metrics14.map m => do\n        {max: m.to(\"cfm\")} // convert to cfm if not already cfm\n        end\n      end else do\n        metric14: \"Insufficient Data\"\n        comment14: \"equip14 not null, but points14 is either null or has hisSize=0\"\n      end\n  end else do\n    metric14: \"Insufficient Data\"\n    comment14: \"N/A\"\n  end\n  \n  \n  //////////////////////////////////////////\n  // 15. Peak Cooling Load (tons)         //\n  //////////////////////////////////////////\n  \n  try\n    meter15: read(equip and meter and load and siteRef->id==buildRef and siteMeter and not submeterOf)\n    catch\n      meter15: null\n  \n  if (meter15!=null) do\n    metRef15: meter15[\"id\"]\n  end else do\n    metRef15: null\n  end\n  if (metRef15!=null) do\n    point15: read(point and power and his and equipRef==metRef15)\n  end else do\n    point15: null\n  end\n  if (point15!=null and point15.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point15.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment15: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment15: \"No data significant gaps.\"\n    end\n    \n    coolLoadHis: point15.hisRead(dates,{limit:null})\n\n    // Find the max of all values in that column.\n    // First store the history in the variable coolLoadHis.\n    // Then find the max of that history and store it as met15_1.\n    // Finally, remove that max from coolLoadHis then find the next max.\n    // Repeat to find 3 maximums.\n    met15_1: coolLoadHis.foldCol(\"v0\",max).to(\"tonref\")\n    coolLoadHis= coolLoadHis.findAll(row => row->v0 != met15_1)\n    met15_2: coolLoadHis.foldCol(\"v0\",max).to(\"tonref\")\n    coolLoadHis= coolLoadHis.findAll(row => row->v0 != met15_1 and row->v0 != met15_2)\n    met15_3: coolLoadHis.foldCol(\"v0\",max).to(\"tonref\")\n    metric15:[met15_1,met15_2,met15_3]\n    \n  end else do\n    metric15: \"Insufficient Data\"\n    comment15: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 16. Building Water (gal)             //\n  //////////////////////////////////////////\n  \n  //    Check if the water history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the water hist\n  location16: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\")==true)\n  locRef16: location16[\"id\"]\n  meter16: readAll(equip and meter and water and not submeterOf)\n            .find(met => met[\"locationRef\"]==locRef16)\n  if (meter16!=null) do\n    metRef16: meter16[\"id\"]\n  end else do\n    metRef16: null\n  end\n  try\n    point16: read(point and volume and his and equipRef==metRef16 and not accumulator)\n    catch\n      point16: null\n  \n  if (point16!=null and point16.hisRead(dates).hisClip.size > 2) do\n    waterHis: point16.hisRead(dates, {limit:null}).hisClip.hisFoldCols(sum)\n    waterHisFiltered: waterHis.toolHisGridShowGaps(15min).findAll(row => row[\"v0\"]!=na())\n    waterHisFilteredRolled: waterHisFiltered.hisRollup(sum,1hr)\n    comment16: toStr(waterHisFilteredRolled.size)+\" hours of 8760 counted.\"\n    metric16: waterHisFilteredRolled.foldCol(\"v0\",sum).to(\"gal\")\n    \n  end else do\n    metric16: \"Insufficient Data\"\n    comment16: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 17. Electricity Cost (\$, calculated) //\n  //////////////////////////////////////////\n  if (metric1!=\"Insufficient Data\") do\n    metric17: metric1*0.058\n    metric17= metric17.as(\"\\\$\")\n  end else do\n    metric17: \"Insufficient Data\"\n  end\n  comment17: \"Value calculated from \\\$0.058/kWh\"\n  \n  //////////////////////////////////////////\n  // 18. Gas Cost (\$, calculated)         //\n  //////////////////////////////////////////\n  if (metric2!=\"Insufficient Data\") do\n    metric18: metric2*0.59\n    metric18= metric18.as(\"\\\$\")\n  end else do\n    metric18: \"Insufficient Data\"\n  end\n  comment18: \"Value calculated from \\\$0.59/therm\"\n  \n  //////////////////////////////////////////\n  // 19. Water Cost (\$, calculated)       //\n  //////////////////////////////////////////\n  if (metric16!=\"Insufficient Data\") do\n    metric19: metric16*11*0.001\n    metric19= metric19.as(\"\\\$\")\n  end else do\n    metric19: \"Insufficient Data\"\n  end\n  comment19: \"Value calculated from \\\$11/1000gal\"\n  \n  \n  \n  // Create list of the Data Needed. Each respectively corresponds to\n  // the above metric. For example, \"Building Elec,\" the first element\n  // of the list below, corresponds to the first metric above.\n  dataNeeded: [\"B\"+readById(buildRef)[\"dis\"]+\" Elec (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Nat Gas (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" CHW (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" DHW (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" HHW (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" DHW+HHW (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Peak Elec (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Plug Elec (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Ventilation Elec (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Cooling Plant Elec (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Lighting Elec (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Plug Peak (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Ventilation Peak (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Cooling Plant Peak (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Lighting Peak (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Peak Airflow (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Peak Cooling Load (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Building Water (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Elec Cost, Calculated (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Gas Cost, Calculated (\" + toStr(dataYear)+ \")\",\n               \"B\"+readById(buildRef)[\"dis\"]+\" Water Cost, Calculated (\" + toStr(dataYear)+ \")\"]\n  \n  metrics:  [metric1,metric2, metric3,metric4,metric4b,metric4c,metric5,metric6,metric7,metric8,metric9,metric10,metric11,metric12,metric13,metric14,metric15,metric16,metric17,metric18,metric19]\n  comments: [comment1,comment2,comment3,comment4,comment4b,comment4c,comment5,comment6,comment7,comment8,comment9,comment10,comment11,comment12,comment13,comment14,comment15,comment16,comment17,comment18,comment19]\n  \n  i: 0\n  outputGrid: metrics.map metric => do\n    dataNeeded_i: dataNeeded[i]\n    metric_i: metrics[i]\n    comment_i: comments[i]\n    i = i+1\n    {dataNeeded:dataNeeded_i,metric:metric_i,remarks:comment_i}\n  end\n  outputGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viFormattedTrends"],,,,M,,,,,,"viB67G36",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(targets, span:yesterday()) => do\n  viFormattedTrends(null, targets, span, 0, \"By Unit\", [], null, 2, 50000, false, false)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"viSysCOPScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find input and output power points under a certain system and calculate\n  heat rejection effectiveness.\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n  addedPtRecs      Optional, grid of additional points to show on graph\n*/\n\n(sysRef:null, dates: today) => do\n  // Default to B59 TW Sys if no ref is provided\n  if(sysRef==null)\n    sysRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n  // Get all power sensor points under sysRef (recursive)\n  // All input powers must be in kW and not on a load meter\n  // Output power is from a load meter\n  inputPowerPts: toolRecursiveSearch(sysRef,\n                   \"point and power and sensor and unit==\\\"kW\\\"\" +\n                   \" and not equipRef->load and not equipRef->meter\")\n  outputPowerPts: toolRecursiveSearch(sysRef,\n                    \"point and power and sensor\" +\n                    \" and equipRef->load and equipRef->meter\")\n\n  // Get Outside Air Wetbulb from the sysRef\n  oaWB: read(equipRef==sysRef and wetBulb)\n  \n  // Interpolate, filter and calculate total input and output power\n  inputPowers: hisRead(inputPowerPts,dates,{limit:null})\n                 .hisInterpolate\n                 .findAll(row => row.all(v => v != null))\n  outputPowers: hisRead(outputPowerPts,dates,{limit:null})\n                  .hisInterpolate\n                  .findAll(row => row.all(v => v != null))\n                  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .hisInterpolate\n                  .renameCol(\"v0\",\"oaWB\")\n\n  totalInputPower: inputPowers.hisFoldCols(sum).renameCol(\"v0\",\"in\")\n  totalOutputPower: outputPowers.hisFoldCols(sum).renameCol(\"v0\",\"out\")\n                                .hisMap(v => if (v != null) v.to(\"kBTU/h\"))\n\n  //convert totalOutputPower to kW\n  totalOutputPower= totalOutputPower.addCol(\"out_kW\",\n      row => if(row->out == null) null else row->out.to(\"kW\"))\n\n  // Join input and output, then calculate effectiveness\n  totals: hisJoin([totalInputPower,totalOutputPower])\n            .hisInterpolate\n            .findAll(row => row.all(v => v != null))\n\n  totals= addCol(totals, \"sysCOP\",\n                 row => if(row->in != 0) (row->out_kW / row->in).as(\"_\") else null)\n  \n  //Add OA Wetbulb to the collection of histories\n  totals= hisJoin([oaWetBulb, totals])\n  \n  metric: keepCols(totals, [\"oaWB\",\"sysCOP\"])\n            .addColMeta(\"oaWB\",\n              {dis: readById(sysRef).dis + \" OA Wetbulb\",\n               unit: \"°F\", color: \"#000000\"})\n            .addColMeta(\"sysCOP\",\n              {dis: readById(sysRef).dis + \" Coeff. of Performance\",\n               unit: \"_\", color: \"#000000\"})\n            \n  //create scatter chart from OA Wetbulb and COP \n  scatterGraph: keepCols(metric, [\"oaWB\",\"sysCOP\"])\n                    .addMeta({chartType: \"scatter\", title: \"Tower COP vs. Outside Air Wetbulb Temperature\"})\n                    .addColMeta(\"sysCOP\", {chartType: \"scatter\", dis: \"Coeff. of Performance\"})\n  \n  return scatterGraph\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgCacheDefaultEquip",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site, find associated connectors and review all\n  previously cached objects. For objects whose connRef associated\n  connector has a vavZn tag, find the corresponding equip and\n  associate its ID with the cached object.\n*/\n\n(siteDis:\"30\") => do\n  siteId: read(site and dis==siteDis)->id\n  \n  // Obtain list of connectors\n  conns: readAll(conn and cached and siteRef==siteId)\n  \n  // Cycle through connectors, review vavZn tag, and if present\n  // associate corresponding equipId with all cached objects\n  conns.each co => do\n    if (not(co.has(\"vavZn\"))) return null\n    tuNum: reGroups(\"(SVAV|VAV|Supply VAV|EVAV) ?-?([A-Za-z0-9]{1,4})\",\n                 co[\"vavZn\"])[2]\n    tus: readAll(equip and terminalUnit and siteRef==siteId)\n    tu: tus.find(row =>\n      tuNum==reGroups(\"(SVAV|VAV|Supply VAV|EVAV) ?-?([A-Za-z0-9]{1,4})\",\n            row[\"navName\"])[2])\n    tuId: tu->id\n    readAll(connPointCache and connRef==co->id)\n    .each c => commit(diff(c, {equipRef: tuId}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Compared Deviation from Trimmed Mean",,M,,M,,,,"hisDeviationCompare_v3",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// This his a hisSrc function, which displays:\n//   - history for selected point over selected period of time\n//   - low and high limits for the history based on trimmed mean and tolerance\n//   - percentage of point values that are out of tolerance\n//   - same thing for the history of the point \"\$duration\" earlier, for comparison\n// duration: time shift for comparison\n// number:   tolerance for deviation around trimmed mean\n//\n// Hardcoded: percentile thresholds for trimmed mean\n// Warning: percentage of out of tolerance counts points, and will be inaccurate if\n//          interval time varies.\n// Known issue: when loaded in Historian and changing datespan, the colors and groups\n//   will default to blue and (1). Work-around: reset to AUTO manually.\n\n(point, dates, duration, number) => do\n  // Allowed deviation from trimmed mean, remove unit since this will be used in additions\n  //   and subtractions. If a \"delta\" appeared in resulting unit, secondary axis would be used\n  tolerance: number.as(1)\n\n  // Low percentile threshold for trimmed mean, suggest keeping under 30%\n  // High threshold will be 1 minus low percentile threshold (symmetrical)\n  // Hardcoded due to limitation of inputs of hisSrc func (expr macro)\n  percentile:20\n\n  // Read data from current historian display, get meta info needed for proper display\n  r_current: point.hisRead(dates)\n  his_meta: r_current.meta\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_c_lo: round(r_current.size*percentile/100,0)\n  i_c_hi: round(r_current.size*(1.0 - percentile/100),0)\n  current_ref: r_current.sort(\"v0\")[i_c_lo..i_c_hi].foldCol(\"v0\",avg)\n  r_current = r_current.addCol(\"v0_limit_lo\", row => (current_ref - tolerance))\n  r_current = r_current.addCol(\"v0_limit_hi\", row => (current_ref + tolerance))\n  cur_out_num: r_current.findAll(row => (row->v0 < (current_ref - tolerance)) or (row->v0 > (current_ref + tolerance))).foldCol(\"v0\",count)\n  cur_out_pct: round(cur_out_num / r_current.size * 100, 0)\n\n  // Read data from earlier, shift timestamps to current historian display, make grid\n  r: point.hisRead(dates - duration)\n  list_ts: colToList(r,\"ts\")\n  list_v1: colToList(r,\"v0\")\n  list_ts0: list_ts.map s => s + duration\n  r_past: list_ts0.toGrid.map( (row,index) => {ts:row->val, v1:list_v1[index]} )\n  \n  // Determine reference value based on average of mid-range values and add to same grid\n  i_p_lo: round(r_past.size*percentile/100,0)\n  i_p_hi: round(r_past.size*(1.0 - percentile/100),0)\n  past_ref: r_past.sort(\"v1\")[i_p_lo..i_p_hi].foldCol(\"v1\",avg)\n  r_past = r_past.addCol(\"v1_limit_lo\", row => (past_ref - tolerance))\n  r_past = r_past.addCol(\"v1_limit_hi\", row => (past_ref + tolerance))\n  past_out_num: r_past.findAll(row => (row->v1 < (past_ref - tolerance)) or (row->v1 > (past_ref + tolerance))).foldCol(\"v1\",count)\n  past_out_pct: round(past_out_num / r_past.size * 100, 0)\n  \n  // Merge current and past grids and set meta information for proper display\n  r_past_meta: r_past.addMeta(his_meta)\n  r_joined: hisJoin([r_current, r_past_meta])\n  \n  point_dis: readLink(r.col(\"v0\").meta[\"equipRef\"])[\"dis\"] + \" \" + r.col(\"v0\").meta[\"navName\"]\n  r_out: r_joined.addColMeta(\"v0\", {dis: point_dis+\", out of tolerance \"+cur_out_pct+\"%\", color: \"#3d80df\", chartGroup:\"1\"})\n                 .addColMeta(\"v0_limit_lo\", {dis: point_dis+\" low limit\", color: \"#4dcde1\", chartGroup:\"1\"})\n                 .addColMeta(\"v0_limit_hi\", {dis: point_dis+\" high limit\", color: \"#4dcde1\", chartGroup:\"1\"})\n                 .addColMeta(\"v1\", {dis: duration+\" earlier: \"+point_dis+\", out of tolerance \"+past_out_pct+\"%\", color: \"#d73d40\", chartGroup:\"2\"})\n                 .addColMeta(\"v1_limit_lo\", {dis: duration+\" earlier: \"+point_dis+\" low limit\", color: \"#c123b0\", chartGroup:\"2\"})\n                 .addColMeta(\"v1_limit_hi\", {dis: duration+\" earlier: \"+point_dis+\" high limit\", color: \"#c123b0\", chartGroup:\"2\"})\n                 .addMeta({dis: \"LAGGED \"+duration+\" \"+point_dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolRecursiveSearch"],,,,M,,,,,,"tmpAhuZoneDamperPosThreshold",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ahuRef, span:yesterday(), damperPosThreshold:90%) => do\n  // Obtain ahu record and ID\n  ahu: if (isRef(ahuRef)) readById(ahuRef)\n       else ahuRef\n  ahuId: ahu->id\n  \n  // Find supply terminal units served by the AHU\n  tuGrid: readAll(supply and terminalUnit and equip and ahuRef==ahuId)\n  \n  // Assume one damper position per TU and map damper position\n  damperPosGrid: tuGrid.map(tu => toolRecursiveSearch(tu->id, \"damper and cmd and point\").first)\n  \n  // If we don't assume one for one relationship\n  //damperPosGrid2: {}.toGrid()\n  //tuGrid.each(tu => do\n  //  resGrid: toolRecursiveSearch(tu->id, \"damper and cmd and point\")\n  //  damperPosGrid2= damperPosGrid2.addRows(resGrid)\n  //end)\n  \n  // Load history of damper positions\n  damperPosHis: damperPosGrid\n  .hisRead(span, {limit:null})\n  // Align trends, with minimum interval of 5min\n  .toolHisAlign(avg, max, false, 5min)  \n  \n  // Map positions to requests using threshold\n  requestsHis: damperPosHis.hisMap(v => if (v > damperPosThreshold) 1 else 0)\n  \n  // Sum up requests\n  requestHis: requestsHis.hisFoldCols(sum)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viSprintVelocity",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Returns a grid formatted as a chart, showing work units per sprint\n  per status, either for sprint snapshots or for most recent statuses,\n  or sprint velocity for closed and resolved items.\n  \n  Arguments: \n  snapshots     Bool, if true use most recent snapshots,\n                if false, use most current deficiency statuses\n  velocity      Bool, if true, show scatter \n*/\n\n(snapshots:false, velocity:false) => do\n  grid: {}.toGrid()\n  \n  if (snapshots) do\n    readAll(sprintVelocitySnap)\n    .colToList(\"sprintRef\")\n    .unique()\n    .each sprintId => do\n      snap: readAll(sprintVelocitySnap and sprintRef==sprintId)\n            .sortr((a,b) => a->date <=> b->date)\n            .first\n      \n      newRow: {\n       sprint: readById(sprintId)->sprint.toStr,\n       personDays: readById(sprintId)[\"personDays\"],\n       workDays: readById(sprintId)[\"workDays\"],\n       wuAbandoned: snap[\"wuAbandoned\"],\n       wuClosed: snap[\"wuClosed\"],\n       wuInProgress: snap[\"wuInProgress\"],\n       wuPending: snap[\"wuPending\"],\n       wuResolved: snap[\"wuResolved\"],\n       wuToDo: snap[\"wuToDo\"],\n      }\n      .map(v => if (v==null) 0 else v)\n      \n      grid= grid.addRow(newRow)\n    end\n  end else do\n    readAll(sprint>0)\n    .each spr => do\n      deficiencies: readAll(deficiency and sprintRef==spr->id)\n      \n      newRow: {\n       sprint: spr->sprint.toStr,\n       personDays: spr[\"personDays\"],\n       workDays: spr[\"workDays\"],\n       wuToDo: deficiencies.findAll(d => d[\"state\"]==\"To Do\").foldCol(\"size\", sum),\n       wuInProgress: deficiencies.findAll(d => d[\"state\"]==\"In Progress\").foldCol(\"size\", sum),\n       wuPending: deficiencies.findAll(d => d[\"state\"]==\"Pending\").foldCol(\"size\", sum),\n       wuResolved: deficiencies.findAll(d => d[\"state\"]==\"Resolved\").foldCol(\"size\", sum),\n       wuClosed: deficiencies.findAll(d => d[\"state\"]==\"Closed\").foldCol(\"size\", sum),\n       wuAbandoned: deficiencies.findAll(d => d[\"state\"]==\"Abandoned\").foldCol(\"size\", sum),\n      }\n      .map(v => if (v==null) 0 else v)\n      \n      grid= grid.addRow(newRow)\n    end\n  end\n  \n  // Formatting\n  if (velocity) do\n    grid= grid\n    .sort((a,b) => parseNumber(a->sprint) <=> parseNumber(b->sprint))\n    .reorderCols(grid.colNames.moveTo(\"sprint\",0))\n    .addCol(\"velocityP\", row => do\n      v: if (row[\"personDays\"]==0) null\n         else (row[\"wuClosed\"]+row[\"wuResolved\"]) / row[\"personDays\"]\n      if (isNumber(v)) v.as(\"_WU/PD\")\n      else v\n    end)\n    .addCol(\"velocityW\", row => do\n      v: if (row[\"workDays\"]==0) null\n         else (row[\"wuClosed\"]+row[\"wuResolved\"]) / row[\"workDays\"]\n      if (isNumber(v)) v.as(\"_WU/WD\")\n      else v\n    end)\n    .findAll(row => row[\"velocityP\"] != null and row[\"velocityP\"] > 0)\n    .keepCols([\"sprint\",\"velocityP\",\"velocityW\"])\n    .addColMeta(\"velocityP\", {color:\"darkturquoise\", dis:\"Work Units per Person Day\"})\n    .addColMeta(\"velocityW\", {color:\"darkviolet\", dis:\"Work Units per Workday\"})\n    .addMeta({title: \"Sprint Velocity\",\n              view:\"chart\",\n              chartType:\"scatter\"})\n  end else do\n    // Title\n    title: \"Work Units per Sprint\"\n    if (snapshots) title= title+\", as Sprint is Ending\"\n    else title= title+\", Latest Status\"\n  \n    grid= grid\n    .sort((a,b) => parseNumber(a->sprint) <=> parseNumber(b->sprint))\n    .addColMeta(\"wuToDo\", {color:\"orange\", dis:\"1 To Do\"})\n    .addColMeta(\"wuInProgress\", {color:\"yellow\", dis:\"2 In Progress\"})\n    .addColMeta(\"wuPending\", {color:\"black\", dis:\"3 Pending\"})\n    .addColMeta(\"wuResolved\", {color:\"green\", dis:\"4 Resolved\"})\n    .addColMeta(\"wuClosed\", {color:\"blue\", dis:\"5 Closed\"})\n    .reorderCols(grid.colNames.moveTo(\"sprint\",0))\n    .removeCols([\"wuAbandoned\",\"personDays\",\"workDays\"])\n    .addMeta({title: title,\n              view:\"chart\",\n              chartType:\"stackedBar\"})\n  end\n  \n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["transferRoomPressureReport"],,,,M,,,,,,"setRPRFieldValue",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/* Sub-function of transferRoomPressureReport app.\n   Takes in the result of calling ioReadLines on the spreadsheet,\n   and does the actual filling up of the tags in the RPR object\n   from the data taken.\n   \n   The first item in the list is always the title of the field\n   \n   Last modified: 2019-09-05\n*/\n\n(rpr, grid) => do\n  \n  title: grid[0]->v0  //split(split(list[0], \",\")[0], \"\\\"\")[1]\n  //rawdata: list.remove(0)\n  //processed: []\n  //rawdata.each item => do\n  //  processed= processed.add(split(split(item, \",\")[1], \"\\\"\")[1])\n  //end\n  processed: grid[1..-1].colToList(\"v1\")\n  \n  if (title == \"Room Pressure Report\") do\n    diff(readById(rpr), {date: processed[0],\n                         buildNum: processed[1], \n                         roomNum: processed[2], \n                         tsiModel: processed[3], \n                         dim: processed[4], \n                         con: processed[5]}).commit()\n    return 1\n  end\n  \n  if (title == \"SETPOINTS\") do\n    diff(readById(rpr), {setpoint: processed[0],\n                         remSetpoint: processed[1], \n                         ventMinSet: processed[2], \n                         coolingFlow: processed[3], \n                         unoccupySet: processed[4], \n                         maxSupSet: processed[5], \n                         minExhSet: processed[6], \n                         minOffset: processed[7], \n                         maxOffset: processed[8], \n                         tempSetpoint: processed[9], \n                         unocTemp: processed[10]}).commit()\n    return 2\n  /* note: code below doesn't work in Axon :(\n  setpoints_tags: [setpoint, remSetpoint, ventMinSet, coolingFlow, unoccupySet, maxSupSet, minExhSet, minOffset, maxOffset, tempSetpoint, unocTemp]\n  counter:0\n  setpoints_tags.each tag => do\n    diff(read(rpr), {setpoints_tags[counter]: processed[counter]})\n    counter=counter+1\n    end\n    \n  */\n  end\n  \n  if (title == \"ALARMS\") do\n    diff(readById(rpr), {lowAlarm: processed[0],\n                         highAlarm: processed[1], \n                         remLowAlm: processed[2], \n                         remHighAlm: processed[3], \n                         minSupAlm: processed[4], \n                         maxExhAlm: processed[5], \n                         alarmReset: processed[6], \n                         audibleAlm: processed[7], \n                         alarmDelay: processed[8], \n                         muteTimeout: processed[9], \n                         alarmRelay: processed[10]}).commit()                  \n    return 3\n  end\n  \n  if (title == \"INTERFACE\") do\n    diff(readById(rpr), {netProtocol: processed[0],\n                         netAddress: processed[1], \n                         outputRange: processed[2], \n                         outputSig: processed[3], \n                         maxFlowOut: processed[4]}).commit()                  \n    return 4\n  end\n  \n\n  \n  if (title == \"CONTROL\") do\n    diff(readById(rpr), {speed: processed[0],\n                         sensitivity: processed[1], \n                         controlSignal: processed[2], \n                         supContDir: processed[3], \n                         exhContDir: processed[4], \n                         tempDir: processed[5], \n                         reheatSig: processed[6], \n                         kc: processed[7], \n                         ti: processed[8], \n                         kcOffset: processed[9], \n                         tempDB: processed[10],\n                         tempTR: processed[11],\n                         tempTI: processed[12]}).commit()    \n    return 5\n  end\n  \n  if (title == \"CONFIGURE\") do\n    diff(readById(rpr), {unitsConfig: processed[0],\n                     exhConfig: processed[1], \n                     accessCodes: processed[2], \n                     macAddress: processed[3]}).commit()    \n    return 6\n  end\n  \n  if (title == \"SYSTEM FLOW\") do\n    diff(readById(rpr), {totalSupFlow: processed[0],\n                     totalExhFlow: processed[1], \n                     offsetValue: processed[2], \n                     supSetpoint: processed[3], \n                     exhSetpoint: processed[4]}).commit() \n    return 7 \n  end\n  \n  if (title == \"INPUT CHECK\") do\n    diff(readById(rpr), {sup1: processed[0],\n                         sup2: processed[1], \n                         sup3: processed[2], \n                         sup4: processed[3], \n                         exh1: processed[4], \n                         exh2: processed[5], \n                         hood1: processed[6], \n                         hood2: processed[7], \n                         hood3: processed[8], \n                         hood4: processed[9], \n                         hood5: processed[10],\n                         hood6: processed[11],\n                         hood7: processed[12]}).commit() \n    return 8\n  end\n  \n  if (title == \"FLOW CHECK\") do\n    diff(readById(rpr), {sp1FlowIn: processed[0],\n                         sp2FlowIn: processed[1], \n                         sp3FlowIn: processed[2], \n                         sp4FlowIn: processed[3], \n                         ex1FlowIn: processed[4], \n                         ex2FlowIn: processed[5], \n                         hd1FlowIn: processed[6], \n                         hd2FlowIn: processed[7], \n                         hd3FlowIn: processed[8], \n                         hd4FlowIn: processed[9], \n                         hd5FlowIn: processed[10],\n                         hd6FlowIn: processed[11],\n                         hd7FlowIn: processed[12]}).commit()   \n    return 9\n  end\n  \n  if (title == \"SUPPLY FLOW\") do\n    diff(readById(rpr), {sp1DctArea: processed[0],\n                         sp2DctArea: processed[1],\n                         sp3DctArea: processed[2],\n                         sp4DctArea: processed[3],\n                         flowStaType_supflow: processed[4],\n                         topVelocity_supflow: processed[5],\n                         spLowSetp: processed[6],\n                         spHighSetp: processed[7],\n                         sp1LowCal: processed[8],\n                         sp1HighCal: processed[9],\n                         sp2LowCal: processed[10],\n                         sp2HighCal: processed[11],\n                         sp3LowCal: processed[12],\n                         sp3HighCal: processed[13],\n                         sp4LowCal: processed[14],\n                         sp4HighCal: processed[15]}).commit()\n    return 10\n  end                 \n  \n  if (title == \"EXHAUST FLOW\") do\n    diff(readById(rpr), {ex1DctArea: processed[0],\n                         ex2DctArea: processed[1],\n                         floStaType_exhflow: processed[2],\n                         topVelocity_exhflow: processed[3],\n                         exLowSetp: processed[4],\n                         exHighSetp: processed[5],\n                         ex1LowCal: processed[6],\n                         ex1HighCal: processed[7],\n                         ex2LowCal: processed[8],\n                         ex2HighCal: processed[9]}).commit()  \n    return 11\n  end\n  \n  if (title == \"HOOD FLOW\") do\n    diff(readById(rpr), {hd1DctArea: processed[0],\n                         hd2DctArea: processed[1],\n                         hd3DctArea: processed[2],\n                         hd4DctArea: processed[3],\n                         hd5DctArea: processed[4],\n                         hd6DctArea: processed[5],\n                         hd7DctArea: processed[6],\n                         flowStaType_hoodflow: processed[7],\n                         topVelocity_hoodflow: processed[8]}).commit()  \n    return 12\n  end\n  \n  if (title == \"HOOD CAL\") do\n    diff(readById(rpr), {hd1LowCal: processed[0],\n                         hd1HighCal: processed[1],\n                         hd2LowCal: processed[2],\n                         hd2HighCal: processed[3],\n                         hd3LowCal: processed[4],\n                         hd3HighCal: processed[5],\n                         hd4LowCal: processed[6],\n                         hd4HighCal: processed[7],\n                         hd5LowCal: processed[8],\n                         hd5HighCal: processed[9],\n                         hd6LowCal: processed[10],\n                         hd6HighCal: processed[11],\n                         hd7LowCal: processed[12],\n                         hd7HighCal: processed[13]}).commit()\n    return 13\n  end\n  \n  if (title == \"SEQUENCE OF OPERATION\") do\n    diff(readById(rpr), {sequenceOfOperation: processed[0]}).commit()\n    return 14\n  end\n  \n  if (title == \"OTHER INFORMATION\") do\n    diff(readById(rpr), {otherInformation : processed[0]}).commit()\n    return 15\n  end\n  \nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"plantAndDeviceOperation",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/**************************************************************************************\nGiven a CHW plant and date range find all associated cooling coils and determine operation periods\nthen compare to CHW plant operation to identify periods when plant doesn't need to operate\n\nAuthor: LCH - kW Engineering\n**************************************************************************************/\n(plant, dates, minTime: 30min)=> do\n\n// normalize minTime to hours\n  minTime = minTime.to(1h)\n\ncoolingDevices: readAll(chilledWaterPlantRef==plant->id or dis==\"AHU-38 (UMF MAU)\" or dis==\"AHU-37 (UMF MAU)\")\ncoolingSupplyDevices: readAll(equipRef==plant->id and equip and chiller)\n\ndemandPeriods: []\nsupplyPeriods: []\n\ncoolingDevices.each device => do \n  equipId: device->id\n  pts: readAll( chilled and water and valve and unit==\"%\" and equipRef==equipId )\n  pts.each rec => do\n    demandPeriods = demandPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v>5%))\n  end\n  hisPeriodMatrix(demandPeriods)\nend\n\nspark1: hisPeriodMatrix(demandPeriods).findAll r => r->numTrue <= 1\n\ncoolingSupplyDevices.each device => do \n  equipId: device->id\n  pts: readAll(point and cmd and enable and navName == \"CMD\" and hisSize and equipRef==equipId)\n  pts.each rec => do\n    supplyPeriods = supplyPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v !=0))\n  end\n\n  hisPeriodMatrix(supplyPeriods)\nend\n\nspark2: hisPeriodMatrix(supplyPeriods).findAll r => r->numTrue != 0\nsparkFinal: hisPeriodIntersection([spark1, spark2]).findAll(r => r->v0 >= minTime)\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"dbCopiesBacnetCur",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  bacnetConnRef + bacnetCur combinations are unique, and there should\n  only be one point per such combination. This function finds duplicates,\n  which typically reflect a typo or error during the point creation.\n  \n  Stores grid as io/dbHealth/copiesBacnetCur.trio trio file with:\n    id:            point id, for all points with duplicate combinations\n    bacnetConnRef: ref \n    bacnetCur:     text\n    copies:        number of duplicate combinations (2+)\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  copy: readAll(point and bacnetCur and bacnetConnRef)\n        .map(row =>\n          {id: row->id,\n           bacnetConnRef: row->bacnetConnRef,\n           bacnetCur: row->bacnetCur,\n           copies: readAll(point and bacnetCur and bacnetConnRef)\n                   .findAll(pt => (pt->bacnetCur == row->bacnetCur \n                                   and pt->bacnetConnRef == row->bacnetConnRef))\n                   .foldCol(\"id\", count)\n          }\n        )\n        .findAll(pt => pt->copies>1)\n        \n  if (isEmpty(copy))\n    copy = {success: \"No duplicate bacnetConnRef + bacnetCur\"}\n           .toGrid\n  \n  copy.ioWriteTrio(`io/dbHealth/copiesBacnetCur.trio`)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["scrapeConvertStrToNum"],,,,M,,,,,,"writeBuildingOS",,,"/*\n  Copyright 2020 Anthony Petelo\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function parses a csv downloaded from BuildingOS and writes\n its data to a point.\n \n ***Before running this script, two things must be done:\n   1.) A csv of the format Link##-##.csv must be uploaded to Folio.\n       The beginning must be \"Link.\" The first ## may be 1 or 2\n       digits, depending on the link number. The second ## must be\n       2 digits.\n   2.) A point with the tag \"BuildingOS\" must already exist. The\n       value of the tag should be the link as a string.\n\n Arguments:\n link        Link is a string of the link number you want to fill\n             BuildingOS data. \n*/\n\n\n(link, restartDate:null) => do\n  linkForCsv: link.replace(\".\",\"-\")\n  csvGrid: ioReadLines(read(dis==\"Link\"+linkForCsv+\".csv\"))\n  csvGrid= csvGrid[5..-1]\n  \n  dataGrid: csvGrid.map row => do\n    data: split(row, \",\")\n    dateString: data[0].split(\" \")[0]\n    timeString: data[0].split(\" \")[1]\n    valueString: data[1]\n    \n    // Convert dateString to date. Depending on the format of the\n    // date string, use the proper parseDate format to convert from\n    // str to date.\n    if (dateString.size == 8) do // First possible parseDate format.\n      date: parseDate(dateString,\"MM/DD/YY\")\n    end else if (dateString.size == 7) do \n      try date: parseDate(dateString,\"M/DD/YY\") // Second possible format.\n      catch date: parseDate(dateString,\"MM/D/YY\") // Third possible format.\n    end else if (dateString.size == 6) do\n      date: parseDate(dateString,\"M/D/YY\") // Fourth possible format.\n    end\n    \n    // Convert timeString to time. Depending on the format of the\n    // time string, use the proper parseTime format to convert from\n    // str to time.\n    if (timeString.size == 5) do\n      time: parseTime(timeString, \"hh:mm\")\n    end else if (timeString.size == 4) do\n      time: parseTime(timeString, \"h:mm\")\n    end\n    \n    dateTime: dateTime(date,time)\n    \n    // Convert valueString to value. Then add unit.\n    value: scrapeConvertStrToNum(valueString)\n    value= value*1therm\n    value= value.to(\"BTU\")\n    \n    {ts: dateTime, val: value}\n  end\n  dataGrid= dataGrid.toGrid\n  \n  // Filter redundant data. Get or assign hisEnd, then find\n  // all rows where new data is greater than that hisEnd.\n  pt: read(buildingOS==link)\n  hisEnd: pt[\"hisEnd\"]\n  /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    argument). Assign dates, clear history, and/or assign\n    hisEnd based on which of the 4 cases is presented\n    (noHis/his and noInput/input) */\n  if (hisEnd != null) do\n    if (restartDate != null) do\n      // his, input\n      hisClear(pt, restartDate..now().date)\n      hisEnd = dateTime(restartDate, time(0,0,0))\n      dates: restartDate..now().date\n    end else if (restartDate == null) do\n      // his, no input\n      dates: hisEnd.date..now().date\n    end\n  end else if (hisEnd == null) do\n    if (restartDate == null) do\n      // no his, no input\n      dates: date(2013,1,1)..now().date\n      hisEnd = dateTime(dates.start,time(0,0,0))\n    end else if (restartDate != null) do\n      // no his, input\n      dates: restartDate..now().date\n      hisEnd = dateTime(dates.start,time(0,0,0))\n    end\n  end\n  filteredGrid: dataGrid.findAll row => row->ts > hisEnd\n  filteredGrid= filteredGrid.findAll row => row[\"val\"] != null\n  \n  \n  // Write filteredGrid to point.\n  hisWrite(filteredGrid,pt)\n  return {written: filteredGrid.size, status: \"OK\"}\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgCreateVavs",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv file and create corresponding zones and supply \n  VAV TU equips\n  The csv file should follow the same template as\n  \n  https://docs.google.com/spreadsheets/d/1mmIjeHY3Y2ezVszcpFX21FleYTYYcnW3r59MdNGoB7I/edit#gid=519007507\n  \n  In particular, the following fields are used:\n  - room\n  - supplyVAV\n  - floor\n*/\n\n(filePath:`io/integration_b30/rm_svav.csv`, siteDis:\"30\") => do\n  siteId: read(site and dis==siteDis)->id\n\n  ioReadCsv(filePath)\n  .each row => do\n    locStr: \"B\" + siteDis + \" Floor \" + row[\"floor\"]\n    zoneStr: \"Rm \" + row[\"room\"]\n    tuStr: \"SVAV-\"+reGroups(\".*VAV-? ?([A-Za-z0-9]{1,4})\", row[\"supplyVAV\"])[1]\n\n    // Create group / location if it doesn't already exist\n    if (read(siteRef==siteId and location and dis==locStr, false)==null)\n      commit(diff(\n        null,\n        {dis: locStr,\n         location,\n         siteRef: siteId},\n        {add}\n      ))\n    \n    locationId: read(siteRef==siteId and location and dis==locStr)->id\n    \n    // Create zone if it doesn't already exist\n    if (read(locationRef==locationId and zone and equip and navName==zoneStr, false)==null)\n      commit(diff(\n        null,\n        {navName: zoneStr,\n         disMacro: \"\\\$locationRef \\\$navName\",\n         zone,\n         equip,\n         locationRef: locationId,\n         siteRef: siteId},\n        {add}\n      ))\n      \n    zoneId: read(locationRef==locationId and zone and equip and navName==zoneStr)->id\n    \n    // Create supply TU if it doesn't already exist\n    if (read(equipRef==zoneId and supply and terminalUnit and equip and navName==tuStr, false)==null)\n      commit(diff(\n        null,\n        {navName: tuStr,\n         disMacro: \"\\\$equipRef \\\$navName\",\n         supply,\n         terminalUnit,\n         equip,\n         equipRef: zoneId,\n         locationRef: locationId,\n         siteRef: siteId},\n        {add}\n      ))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anZoneAirflowDriver","toolRecursiveSearch"],,,,M,,,,,,"anAirflowSavings",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ahuRef: @p:lbnl:r:23ac4eb8-a99ecb1c,\n exhaustRef: @p:lbnl:r:239d97da-7dffb107,\n span:lastWeek(), rollup:15min) => do\n  // Paramaters\n  htgEfficiency: 0.9\n  clgCost: 1 // kW/ton\n  energyMult: (rollup.to(\"min\") / 60min).as(1)\n  \n  ahu: readById(ahuRef)\n  exh: readById(exhaustRef)\n  \n  zones: readAll(zone and equip and minAirflowSp)\n  selectedZones: zones.findAll(zone => read(equipRef==zone->id and ahuRef==ahuRef,false)!=null)\n  \n  ahuSat: read(equipRef==ahuRef and discharge and air and temp and sensor)\n          .hisRead(span, {limit:null})\n          .hisRollup(avg, rollup)\n          .renameCol(\"v0\",\"sat\")\n  \n  ahuOat: read(equipRef==ahuRef and outside and air and temp and sensor)\n          .hisRead(span, {limit:null})\n          .hisRollup(avg, rollup)\n          .renameCol(\"v0\",\"oat\")\n          \n  ahuSaf: read(equipRef==ahuRef and discharge and air and flow and sensor)\n          .hisRead(span, {limit:null})\n          .hisRollup(avg, rollup)\n          .renameCol(\"v0\",\"saf\")\n\n  supplyPowers: toolRecursiveSearch(ahuRef, \"power and sensor and equipRef->discharge and equipRef->fan\")\n  supplyPower: supplyPowers\n               .hisRead(span, {limit:null})\n               .hisRollup(avg, rollup)\n               .hisFoldCols(sum)\n               .renameCol(\"v0\",\"supplyFanPower\")\n  \n  exhaustPowers: toolRecursiveSearch(exhaustRef, \"power and sensor and (equipRef->exhaust or equipRef->return) and equipRef->fan\")\n  exhaustPower: exhaustPowers\n               .hisRead(span, {limit:null})\n               .hisRollup(avg, rollup)\n               .hisFoldCols(sum)\n               .renameCol(\"v0\",\"exhaustFanPower\")\n  \n  obsAirflows: null\n  propAirflows: null\n  reheatReduc: null\n  \n  selectedZones.each(zone => do\n    grid: anZoneAirflowDriver(zone->id, span, 0.05, 0%, rollup)\n    \n    if (grid==null) return null\n    \n    else grid= grid\n          .addCol(\"propSaSp\", row => if (row[\"mode\"]==\"minAirflowSp\")\n                                       zone[\"minAirflowSpProposed\"]\n                                     else row[\"saSp\"])\n          .addColMeta(\"saSp\", {dis: zone.dis()})\n    \n    grid= hisJoin([grid, ahuSat])\n    \n    grid= grid.addCol(\"reheatReduc\", row => do\n      if (row.any(v => v==null)) return 0therm\n      else return ((row[\"saSp\"] - row[\"propSaSp\"]) * (row[\"zat\"] - row[\"sat\"]) * 1.08 * energyMult / htgEfficiency).as(\"BTU\").to(\"therm\")\n    end)\n          \n    if (obsAirflows==null) do\n      obsAirflows= grid.keepCols([\"ts\",\"saSp\"])\n      propAirflows= grid.keepCols([\"ts\",\"propSaSp\"])\n      reheatReduc= grid.keepCols([\"ts\",\"reheatReduc\"])\n    end else do\n      obsAirflows= hisJoin([obsAirflows,\n                            grid.keepCols([\"ts\",\"saSp\"])])\n      propAirflows= hisJoin([propAirflows,\n                             grid.keepCols([\"ts\",\"propSaSp\"])])\n      reheatReduc= hisJoin([reheatReduc,\n                             grid.keepCols([\"ts\",\"reheatReduc\"])])\n    end\n  end)\n  \n  summary: hisJoin([obsAirflows.hisFoldCols(sum),\n                  propAirflows.hisFoldCols(sum),\n                  reheatReduc.hisFoldCols(sum),\n                  ahuSat,\n                  ahuOat,\n                  ahuSaf,\n                  supplyPower,\n                  exhaustPower])\n         .renameCol(\"v0\",\"observedAirflowSp\")\n         .renameCol(\"v1\",\"proposedAirflowSp\")\n         .renameCol(\"v2\",\"reheatReduc\")\n         .addColMeta(\"reheatReduc\", {unit:\"therm\"})\n         .addCol(\"airflowReduc\", row => row[\"observedAirflowSp\"] - row[\"proposedAirflowSp\"])\n         .addCol(\"coolingReduc\", row =>\n           if(row.has(\"oat\") and row.has(\"sat\") and row.has(\"airflowReduc\"))\n             (row[\"airflowReduc\"] * max(0, (row[\"oat\"] - row[\"sat\"])) * 1.08 * energyMult / 12000 * clgCost).as(\"kWh\")\n           else 0kWh)\n         .addCol(\"heatingReduc\", row =>\n           if(row.has(\"oat\") and row.has(\"sat\") and row.has(\"airflowReduc\"))\n             (((row[\"airflowReduc\"] * max(0, (row[\"sat\"] - row[\"oat\"])) * 1.08).as(\"BTU/h\") - row[\"supplyFanPower\"].to(\"BTU/h\")) * energyMult / htgEfficiency).as(\"BTU\").to(\"therm\")\n           else 0therm)\n         .addCol(\"supplyFanReduc\", row => do\n           (row[\"supplyFanPower\"] * (1 - pow(row[\"proposedAirflowSp\"] / row[\"observedAirflowSp\"], 2.7)) * energyMult).as(\"kWh\")\n         end)\n         .addCol(\"exhaustFanReduc\", row => do\n           (row[\"exhaustFanPower\"] * (1 - pow(row[\"proposedAirflowSp\"] / row[\"observedAirflowSp\"], 2.7)) * energyMult).as(\"kWh\")\n         end)\n  \n  summary= summary.addColMeta(\"observedAirflowSp\", {chartMin:0cfm})\n                  .addColMeta(\"proposedAirflowSp\", {chartMin:0cfm})\n                  .addColMeta(\"airflowReduc\", {chartMin:0cfm})\n                  .removeCols([\"oat\",\"sat\",\"supplyFanPower\",\"exhaustFanPower\"])\n                  \n  coolingSavings: summary.foldCol(\"coolingReduc\",sum)\n  heatingSavings: summary.foldCol(\"heatingReduc\",sum)\n  reheatSavings: summary.foldCol(\"reheatReduc\",sum)\n  supplyFanSavings: summary.foldCol(\"supplyFanReduc\",sum)\n  exhaustFanSavings: summary.foldCol(\"exhaustFanReduc\",sum)\n  \n  summary= summary\n           .addColMeta(\"reheatReduc\",{color:\"red\",\n                                      dis: ahu.dis() + \" Reheat Savings: Total \"+reheatSavings.format(\"#,###\")})\n           .addColMeta(\"coolingReduc\",{color:\"blue\",\n                                      dis: ahu.dis() + \" Cooling Savings: Total \"+coolingSavings.format(\"#,###\")})\n           .addColMeta(\"heatingReduc\",{color:\"darkred\",\n                                      dis: ahu.dis() + \" Heating Savings: Total \"+heatingSavings.format(\"#,###\")}) \n           .addColMeta(\"supplyFanReduc\",{color:\"green\",\n                                      dis: ahu.dis() + \" Supply Fan Savings: Total \"+supplyFanSavings.format(\"#,###\")})\n           .addColMeta(\"exhaustFanReduc\",{color:\"black\",\n                                      dis: ahu.dis() + \" Exhaust Fan Savings: Total \"+exhaustFanSavings.format(\"#,###\")})     \n                                      \n  return summary\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"viZoneTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all data points associated with a given zone in a given\n  building, including all points in sub-equips of that zone that\n  are not raw points, and any discharge air temp points from the\n  AHU associated with the first terminal unit of the zone. Load\n  and display historical data for all these points across the given\n  date span.\n  \n  Arguments: \n  siteStr      string, site name / dis, e.g. \"67\"\n  roomStr      string, room navName, e.g. \"Rm 1236D\"\n  dates        dateSpan, dates of data to display\n  rules        bool, whether to display result of sparkRules\n  zonePtsStr   string, filter used to customize what points to return\n               at the zone level, default \"point and not raw\"\n  ahuChartG... string, force same chartGroup for all AHU trends\n  datChartG... string, force given chartGroup for DAT trend\n*/\n\n(siteStr: \"67\", roomStr: \"Rm 1236D\", dates: yesterday(), rules: true,\n zonePtsStr: \"point and not raw\",\n ahuChartGroup: \"AHU\", datChartGroup: null) => do\n  // Attempt to find zone, exit if no zone found\n  zone: read(navName==roomStr and siteRef->dis==siteStr, false)\n  if (zone==null) return {error: \"No corresponding zone found\"}\n                         .toGrid()\n  \n  // Retrieve IDs of all points in zone or sub-equips that match\n  // string filter zonePtsStr\n  subPts: toolRecursiveSearch(zone->id,zonePtsStr)\n  \n  // Force supply terminal unit DAT chartGroup\n  subPts= subPts.map(row =>\n    if (row.has(\"discharge\") and row.has(\"temp\") and row.has(\"air\"))\n      row.set(\"chartGroup\", datChartGroup)\n    else\n      row)\n  \n  // Find a supply terminal unit associated with zone\n  supplyTU: read(supply and terminalUnit and ahuRef and equip\n                 and equipRef==zone->id, false)\n  if (supplyTU==null or supplyTU[\"ahuRef\"]==null) graphPts: subPts\n  else do\n    ahuId: supplyTU->ahuRef\n    satPts: readAll(point and his and not raw\n                    and discharge and air and (temp or pressure)\n                    and equipRef==ahuId)\n            .addCol(\"chartGroup\", row => ahuChartGroup)\n    graphPts: subPts.addRows(satPts)\n  end\n  \n  // Load trend history\n  graphHis: graphPts.hisRead(dates, {limit: null})\n  \n  // Add detected periods from sparkRules\n  if (rules) do\n    ruHis: ruleSparks(toolRecursiveSearch(zone->id, \"equip\"),\n                      dates, readAll(sparkRule))\n           .ruleSparkHis()\n    \n    graphHis= hisJoin([graphHis, ruHis])\n  end\n  \n  return graphHis\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viZoneReheatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load reheat loads from all terminal units in a location and display\n  on a heat map.\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  locationRef   Ref for location under which to look for zone loads\n  span          Span of dates we want to display\n  clip          Value to clip load at for display (0..clip)\n*/\n\n(locationRef, span, clip) => do\n  unit: \"kBTU/h\"\n  \n  loads: readAll(locationRef==locationRef and heat and coil and power\n                 and sensor and equipRef->terminalUnit)\n  \n  if (isEmpty(loads)) return null\n  \n  loads= loads.hisRead(span, {limit: null})\n              .hisInterpolate()\n              .hisRollup(avg, 30min)\n  \n  try do\n    loads= loads.hisMap(v => if (v == null) null\n                             else min(v.to(unit),clip))\n        .hisFlatten((val, ts, his) => \n               {ts: ts,\n                rm: his->equipRef->equipRef->navName + \" \"\n                    + his->equipRef->navName,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: 0.as(unit),\n                           chartMax: clip.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: \"white, yellow, orange, red\"})\n  catch (ex) do\n    loads= null\n  end\nend\n\n\n  /*times: loads.colToList(\"ts\")\n  ts: times.sort()[0]\n  te: times.sort()[-1]\n  \n  loads= loads.addCol(\"scaleRef\", row => do\n    if (row->ts == ts) 0\n    else if (row->ts == te) clip\n    else null\n  end)\n  .hisInterpolate()*/\n  \n  \n/*\nif(isEmpty(readAll(locationRef==read(location and dis=={{location}})->id and heat and coil and power and sensor and equipRef->terminalUnit)))\n  null\nelse\n  readAll(locationRef==read(location and dis=={{location}})->id and heat and coil and power and sensor and equipRef->terminalUnit)\n  .hisRead({{span}})\n  .hisInterpolate()\n  .hisRollup(avg, 30min)\n  .hisMap(v => if (v == null) null else min(max(v,0).to(\"kBTU/h\"), {{clip}}))\n  .hisFlatten((val, ts, his) => {ts: ts, rm: his->equipRef->equipRef, v0: val})\n  .reorderCols([\"ts\",\"rm\",\"v0\"])\n  .addMeta({view: \"chart\", chartType:\"heatMap\", colors: \"white, yellow, orange, red\"})\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["facAhuResetSpNow","facAhuResetsJob"],,,,M,,,,,,"facAhuResetsJob",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Called by job app every 5min to execture facAhuResetsNow for all setpoints with\n  an associated resetSettings record.\n*/\n\n() => do\n  // Load resetSettings records and cycle through\n  readAll(resetSettings).each r => do\n    try do\n      facAhuResetSpNow(r->spRef, r[\"ahuRef\"])\n    end catch (ex) logErr(\"facAhuResetsJob\",\n                          \"Failed to calculate or write setpoint for \" +\n                          readById(r->spRef).dis()+ \": \" + ex->dis)\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"facCreateZoneReqPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create optional points to keep track of generated requests (heat, cool, pressure) for\n  a zone. These are not required for the Guideline 36 algorithms to work properly.\n  Individual zone requests are only used for documentation purposes.\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  equipRef     Id of the equip to create 3 request ignore points for\n  createCool   Bool, if true create cooling request point\n  createPres   Bool, if true create pressure request point\n  createHeat   Bool, if true create heating request point\n*/\n(equipRef, createCool:true, createPres:true, createHeat:true) => do\n  // Standardize to ref / id from rec (for easy map / each usage)\n  equipRef= if (isRef(equipRef)) equipRef\n            else equipRef->id\n  equip: readById(equipRef)\n            \n  // Create air cool ignore cmd point dict\n  coolPtDict: {disMacro: \"\\\$equipRef \\\$navName\",\n               equipRef: equipRef,\n               his,\n               kind:\"Number\",\n               locationRef: equip->locationRef,\n               point,\n               siteRef: equip->siteRef,\n               tz: \"Los_Angeles\",\n               unit: \"_request\",\n               air,\n               cool,\n               request,\n               cmd,\n               navName:\"Requests - Colder Supply Air\"\n              }\n\n  // Create air pressure ignore cmd point dict\n  presPtDict: {disMacro: \"\\\$equipRef \\\$navName\",\n               equipRef: equipRef,\n               his,\n               kind:\"Number\",\n               locationRef: equip->locationRef,\n               point,\n               siteRef: equip->siteRef,\n               tz: \"Los_Angeles\",\n               unit: \"_request\",\n               air,\n               pressure,\n               request,\n               cmd,\n               navName:\"Requests - Increased Air Pressure\"\n              }\n          \n  // Create general heat ignore cmd point dict\n  heatPtDict: {disMacro: \"\\\$equipRef \\\$navName\",\n               equipRef: equipRef,\n               his,\n               kind:\"Number\",\n               locationRef: equip->locationRef,\n               point,\n               siteRef: equip->siteRef,\n               tz: \"Los_Angeles\",\n               unit: \"_request\",\n               general,\n               heat,\n               request,\n               cmd,\n               navName:\"Requests - More Heat (Generic)\"\n              }\n          \n  // Check if air cool ignore cmd exists, create if not\n  coolPt: read(air and cool and request and cmd and equipRef==equipRef, false)\n  if (coolPt==null and createCool)\n    commit(diff(null, coolPtDict, {add}))\n    \n  // Check if air pressure ignore cmd exists, create if not\n  presPt: read(air and pressure and request and cmd and equipRef==equipRef, false)\n  if (presPt==null and createPres)\n    commit(diff(null, presPtDict, {add}))\n    \n  // Check if general heat ignore cmd exists, create if not\n  heatPt: read(general and heat and request and cmd and equipRef==equipRef, false)\n  if (heatPt==null and createHeat)\n    commit(diff(null, heatPtDict, {add}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["derivative"],,,M,M,,,,,,"derivative",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n////////////////////////////////////////////////////////////////////\n// Fold function to calculate derivative of point value\n\n(val, ts, acc) => do\n  //Initialization, retruning the accumulator\n  if (val == foldStart()) return {deltaTs:0,deltaVal:0}\n  \n  // Final, returning result\n  if (val == foldEnd()) do\n    if (acc->deltaTs>0) do\n      return acc->deltaVal / acc->deltaTs\n    end else do \n      return 0\n    end\n  end\n  \n  // Manage N/A value\n  if (val == na()) return na()\n  \n  // Manage NULL value\n  if (val == null) return na()\n  \n  // First time step\n  if (not acc.has(\"prevVal\")) return {deltaTs:0, deltaVal:0, prevVal:val, prevTs:ts}\n  \n  // All other time steps\n  return {deltaTs:acc->deltaTs + (ts - acc->prevTs),\n          deltaVal:acc->deltaVal + (val - acc->prevVal),\n          prevTs:ts,\n          prevVal:val\n         }\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpIntgB67FumeHoods",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n\n  Create fume hood equips and mark all related connPointCache points with right equipRef\n\n*/\n\n() => do\n  // Create equips from CSV\n  ioReadCsv(`io/integration_b67/b67_fh.csv`)\n  .addCol(\"roomId\", row => \n      read(zone and siteRef->dis==\"67\" and navName==\"Rm \"+row->room)->id)\n  .addCol(\"exhaustSystemRef\", row =>\n      readAll(siteRef->dis==\"67\" and exhaustSystem)\n      .find(exh => exh->navName.contains(reGroups(r\"67-BL-\\d(\\d\\d)\", row->exhaust)[1]))->id)\n  .each(row => do\n    // Skip if there is an existing fumeHood with the right controller\n    if (read(fumeHood and equip and equipRef==row->roomId and controller==row->controller,\n             false)!=null) return null\n    \n    // Create equip dictionary\n    fhDict: {equip,\n             fumeHood,\n             siteRef: row->roomId->siteRef,\n             locationRef: row->roomId->locationRef,\n             equipRef: row->roomId,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             controller: row->controller,\n             exhaustSystemRef: row->exhaustSystemRef,\n             navName: reGroups(r\"^67(-|_)(.+)\", row->fh)[2],\n             tmp:today()}\n             \n    // Commit\n    commit(diff(null, fhDict, {add}))\n  end)\n\n  // Add equipRef tags to connPointCache records\n  readAll(fumeHood and equip and siteRef->dis==\"67\")\n  .each(fh => if (fh.has(\"controller\")) do\n      cacheRecs: readAll(connPointCache and connRef->siteRef->dis==\"67\")\n      .findAll(row => if(row.has(\"bacnetCurName\"))\n                        row[\"bacnetCurName\"].contains(fh->controller)\n                      else if(row.has(\"bacnetHisName\"))\n                        row[\"bacnetHisName\"].contains(fh->controller)\n                      else false)\n      \n      if (isEmpty(cacheRecs)) return null\n      else cacheRecs\n           .each(rec => commit(diff(rec, {tmpEquipRef:fh->id})))\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolSplitTrends"],,,,M,,,,,,"anRegGasHddCalculate_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Calculate regression of daily natural gas usage versus HDD,\n  with factor of weekday / weekend (total 2 variables).\n  Return dictionary with:\n    results:  dict of model coefficients and fit statistics\n    graph:    chart grid for measured & fitted points\n    dataset:  grid of original dataset, plus fitted values\n  \n  Arguments: \n  meterUsageRef      Ref of gas meter usage data point (Btu or therm)\n  dateSpan           Span of dates to perform analysis on\n  ddRefTemp          Reference temp for calculation of degree days\n  titlePrefix        (Optional) Title prefix for graph title\n  datesHighlight     Span of dates to highlight in graph\n\n  Notes:\n  For degree days calculation, the weather station associated with\n  the site associated with the meter usage point is used. Function\n  will fail if weatherRef is not defined on the corresponding site.\n*/\n\n(meterUsageRef: @p:lbnl:r:2204f59c-5e34a792, dateSpan:2018, ddRefTemp:60°F,\n titlePrefix:\"\", datesHighlight:pastMonth()) => do\n  // Read usage from meter energy point\n  usage: readById(meterUsageRef)\n        .hisRead(dateSpan, {limit:null})\n        .hisRollup(sum, 1day)\n        .renameCol(\"v0\", \"usage\")\n  \n  // Reference value with unit, for later unit casting\n  refValue: 1.as(usage.first[\"usage\"])\n\n  // Read outside air temperature from weather station associated with\n  //   meterUsage point, and calculate degree days\n  hdd: read(weatherRef==readById(meterUsageRef)->siteRef->weatherRef\n            and weatherPoint and air and temp  // OAT is input to degreeDays\n            and not secondary)  // Do not use secondary sensor if one exists\n       .degreeDays(dateSpan, ddRefTemp)\n       .keepCols([\"ts\",\"heat\"])\n  \n  // Join regression data and filter out missing gas data points\n  dataset: hisJoin([hdd.hisRollup(sum, 1day), \n                    usage.hisRollup(sum, 1day)])\n             // Filter out dates with missing gas data\n             .findAll(row => row.has(\"usage\"))\n   \n  // Create design matrix, specifically apply day type factoring\n  //   to HDD, to separate weekdays and weekends\n  regMatrix: dataset.map row => {\n    ts: row->ts,\n    hddWeekday: if(isWeekday(row->ts)) row->heat else 0,\n    hddWeekend: if(isWeekday(row->ts)) 0 else row->heat,\n    usage: row->usage\n  }\n       \n  // Isolate dependent and independent variables for regression\n  y: regMatrix.keepCols([\"usage\"])\n  x: regMatrix.keepCols([\"hddWeekday\",\"hddWeekend\"])\n\n  // Perform regression and extract coefficients\n  reg: matrixFitLinearRegression(y, x)\n  intercept: reg.meta[\"bias\"]\n  slopeWeekday: reg[0][\"b\"]\n  slopeWeekend: reg[1][\"b\"]\n\n  // Calculate fitted values using coefficients and join with dataset\n  slope: null\n  dataset = dataset.addCol(\"fittedUsage\", row => do\n      slope = if(isWeekday(row->ts)) slopeWeekday else slopeWeekend\n      (intercept + slope*row->heat).as(refValue)\n    end)\n  \n  // Calculate statistics\n  measuredTotal: y.foldCol(\"usage\", sum)\n  n: reg.meta[\"rowCount\"]\n  measuredAvg: measuredTotal / n\n  sqError: dataset.addCol(\"se\", row => pow(row->fittedUsage - row->usage,2))\n                  .foldCol(\"se\", sum)\n  p: 2\n  mse: sqError / (n-p)\n  rmse: sqrt(mse)\n  cvrmse: rmse / measuredAvg\n  \n  // Build dictionary of results\n  regRes: {\n    intercept: intercept,\n    slopeWeekday: slopeWeekday,\n    slopeWeekend: slopeWeekend,\n    rSquared: reg.meta[\"r2\"],\n    n: n,\n    p: p,\n    measuredAvg: measuredAvg,\n    mse: mse,\n    rmse: rmse,\n    cvrmse: (cvrmse*100).as(1%),\n    ddRefTemp: ddRefTemp\n  }\n\n  // Apply day type factoring to usage, for graphing purposes\n  usage_factor: dataset.map row => {\n    ts: row->ts,\n    usageWeekday: if(isWeekday(row->ts)) row->usage else null,\n    usageWeekend: if(isWeekday(row->ts)) null else row->usage\n  }\n  usage_factor= usage_factor\n    .addColMeta(\"usageWeekday\", {dis: \"Weekday\"})\n    .addColMeta(\"usageWeekend\", {dis: \"Weekend\"})\n\n  usage_factor= toolSplitTrends(usage_factor, datesHighlight, \"orange\")\n  selectedCols: usage_factor.colNames().findAll(v => v != \"ts\")\n                .insert(0, \"heat\")\n  selCols2: selectedCols.insert(1, \"regressionWeekend\")\n                        .insert(2, \"regressionWeekday\")\n\n  // Create graph of data, scatter plot of usage vs HDD\n  graph: hisJoin([hdd, usage_factor])\n    // Keep only useful data for scatter plot\n    .keepCols(selectedCols)\n    // Sort so scatter plot uses proper xmin and xmax\n    .sort(\"heat\")\n    // Calculate fitted values per day type to show regression results\n    .addCol(\"regressionWeekday\", row => if(row.has(\"heat\"))\n      (intercept+regRes[\"slopeWeekday\"]*row->heat).as(refValue)\n      else null)\n    .addCol(\"regressionWeekend\", row => if(row.has(\"heat\"))\n      (intercept+regRes[\"slopeWeekend\"]*row->heat).as(refValue)\n      else null)\n    // Reorder columns to control overlay\n    .reorderCols(selCols2)\n    // Add meta data to control graph display\n    .addColMeta(\"usageWeekday\", {color:\"#1D80F1\", chartGroup:\"all\"})\n    .addColMeta(\"usageWeekend\", {color:\"#07203C\", chartGroup:\"all\"})\n    .addColMeta(\"regressionWeekday\", {color:\"#C7DFFB\", chartGroup:\"all\"})\n    .addColMeta(\"regressionWeekend\", {color:\"#C1C7CE\", chartGroup:\"all\"})\n    .addMeta({title:titlePrefix+\"Daily gas usage vs HDD grouped by day type\"})\n    \n  // Force all on same graph\n  graph.colNames.findAll(v => v != \"heat\").each colName =>\n    graph= graph.addColMeta(colName, {chartType:\"scatter\", chartGroup:\"all\"})\n    \n  // Return dict of: (dict) regression results, (grid) graph, (grid) dataset\n  return {results:regRes, graph:graph, dataset:dataset}\nend\n\n/*\n\nTest for calling a function in Axon by its tags. Can work, but cumbersome:\neval(read(func and regModel==\"dailyGasHDD\" and version==1 and apply)->name\n     +\"(parseRef(\\\"\"\n     +read(siteRef->dis==\"Campus Utility\" and gas and energy and point and \n       sensor)->id\n     +\"\\\"),2018-01-01..2018-01-28,\"\n     +(anRegGasDailyHDDv1(\n       read(siteRef->dis==\"Campus Utility\" and gas and energy and point and\n         sensor)->id,\n       2017-02-01..2018-01-28,\n       65°F)->results)\n     +\")\")\n\nEval argument looks like:\nanRegGasHddAv1(parseRef(\"p:lbnl:r:2204f59c-5e34a792\"),\n  2018-01-01..2018-01-28,\n  {intercept:1942.5582171226897,\n    slopeWeekday:258.6275333069492, \n    slopeWeekend:218.29285026361526, \n    rSquared:0.8963347812420092, \n    n:362, p:2, \n    measuredAvg:3980.441988950276therm, \n    mse:201978.87300901793, \n    rmse:449.4205970013145, \n    cvrmse:11.290720936240447%, \n    ddRefTemp:65°F})\n\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viCWPumpOperations",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find cooling water dp, dp setpoint and pump speed for \n  a given time range\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(cwSysRef:null, dates: today, rollup:5min, spdThreshold:1Hz) => do\n  // Default to B59 CW Plant if no ref is provided\n  if(cwSysRef==null)\n    cwSysRef= read(equip and siteRef->dis==\"59\" and treatedWaterPlant and navName==\"Plant\")\n    \n  cwSysId: cwSysRef->id\n    \n  // Get the dp setpoint and dp for cooling water\n  cwDiffPressPt: read(equipRef==cwSysId\n                    and pressure\n                    and sensor\n                    and water)\n  cwDPSetPt: read(equipRef==cwSysId\n                    and pressure\n                    and sp\n                    and water)\n  \n                    \n  // Read out the histories for the three temperatures\n  cwDiffPressTrend: hisRead(cwDiffPressPt, dates, {limit:null})\n                    .renameCol(\"v0\",\"cwDP\")\n                    .hisRollup(avg, rollup)\n\n  cwDPSetPtTrend: hisRead(cwDPSetPt, dates, {limit:null})\n                    .renameCol(\"v0\",\"cwDPSP\")\n                    .hisRollup(avg, rollup)\n  \n  // Get all the Tower Pump Speeds\n  pumpSpeeds: readAll(locationRef==cwSysRef->locationRef\n                     and equipRef->pump\n                     and speed\n                     and cmd)\n  \n  // Average pump speeds for pump speeds greater than threshold\n  avgPumpSpeeds: hisRead(pumpSpeeds, dates, {limit:null})\n                   .hisRollup(avg, rollup)\n                   .hisMap((val, ts, his) => do\n                      return if (val > spdThreshold) ((val.to(\"Hz\")/60)*100).as(\"%\") else null\n                    end)\n                    \n  avgPumpSpeeds= avgPumpSpeeds.hisFoldCols(avg)\n                \n        \n  //Join the histories into a common map\n  combined: hisJoin([cwDiffPressTrend, cwDPSetPtTrend, avgPumpSpeeds])\n                    .addColMeta(\"cwDP\",\n                      {dis: \"CW Differential Pressure\",\n                      unit: \"psi\", color: \"#9ACD32\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"cwDPSP\",\n                      {dis: \"CW DP Setpoint\",\n                      unit: \"psi\", color: \"#ADFF2F\",\n                      chartGroup: \"all\",\n                      hisInterpolate: \"cov\"})\n                    .addColMeta(\"v0\",\n                      {dis: \"Average CW Pump Speed\",\n                      color: \"#008000\",\n                      chartGroup: \"all\"})\n  return combined\nend\n                    \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneDeltaTemps"],,,,M,,,,,,"viAhuZoneDeltaTempsAbsOcc",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, calculate the absolute temperature deviation from zone \n  temp deadband for all TUs served by that AHU (using anAhuZoneDeltaTemps)\n  then display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), maxDev: 5°F, rollup: 15min, zoneIdList:null, filterUnocc:false) => do\n  devs: anAhuZoneDeltaTemps(ahuRef, dates, maxDev, rollup, zoneIdList, filterUnocc)\n  \n  try do\n    devs= devs\n        .findAll(r => r->ts.hour > 8 and r->ts.hour < 20)\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n                rm: if (ts.hour > 8 and ts.hour < 20) his->dis else null,\n                v0: if (isNumber(val)) abs(val) else val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {unit:\"°F\",\n                           chartMin: 0°F,\n                           chartMax: maxDev})\n        .addMeta({view: \"chart\", chartType:\"heatMap\",\n                  title: \"Absolute deviation from deadband, zones served by \"\n                         +readById(ahuRef).dis() + \", 9 AM - 8 PM\",\n                  colors: \"palegreen, red\"})\n  catch (ex) do\n    devs= null\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"timedeltaChart",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  \"Hello world!\"\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recEditDeficiency"],,,,M,,,,,,"recAssignDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Assign size and assignTo to deficiency, or to deficiencies in a group\n  \n  Arguments:\n  defGroupSizeDict   Dict containing only changes to the original\n                     selected record.\n*/\n\n(defGroupAssignDict) => do\n  // Normalize action input\n  defGroupAssignDict= actionNormInput(defGroupAssignDict, \"dict\")\n\n  if (defGroupAssignDict[\"size\"]!=null and not(isNumber(defGroupAssignDict[\"size\"])))\n    throw \"Size required\"\n    \n  // If id is provided and related object is a deficiency,\n  // use recEditDeficiency (actionNormInput may remove id from\n  // groups since the id does not directly correspond to the dict\n  if (defGroupAssignDict.has(\"id\") and\n      readById(defGroupAssignDict[\"id\"]).has(\"deficiency\")) do\n    // Keep only id, size and assignTo\n    defGroupAssignDict= defGroupAssignDict\n    .findAll((v,n) => [\"id\",\n                       \"size\",\n                       \"energyValue\",\n                       \"operationalValue\",\n                       \"assignedTo\",\n                       \"mod\"].contains(n))\n    // If current deficiency state is \"New\", change to \"Backlog\"\n    if (readById(defGroupAssignDict->id)[\"state\"]==\"New\")\n      defGroupAssignDict= defGroupAssignDict\n      .set(\"state\",\"Backlog\")\n    // Submit through recEdit function\n    recEditDeficiency(defGroupAssignDict)\n  end else do\n    // Else dict represents a group of deficiency, edit each one\n    avgSize: try defGroupAssignDict->size / defGroupAssignDict->count\n             catch null\n    \n    // Load each deficiency record and commit new size, new esp and oip\n    readAll(deficiency and\n            deficiencyGroupRef==defGroupAssignDict->deficiencyGroupRef and\n            siteRef==defGroupAssignDict->siteRef)\n    .findAll(r => r[\"sprintRef\"]==defGroupAssignDict[\"sprintRef\"])\n    .each(d => recEditDeficiency({id:d->id,\n                                  size:avgSize,\n                                  energyValue:defGroupAssignDict[\"energyValue\"],\n                                  operationalValue:defGroupAssignDict[\"operationalValue\"],\n                                  assignedTo:defGroupAssignDict[\"assignedTo\"],\n                                  mod:d->mod,\n                                  state: if(d[\"state\"]==\"New\") \"Backlog\" else null}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recEditDeficiency"],,,,M,,,,,,"recToggleDeficiencies",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Assign selected deficiencies to latest sprint, and change state to\n  To Do if previous state was New, Backlog or In Consideration\n  \n  Arguments:\n  defGroupSizeDict   Dict containing only changes to the original\n                     selected record, only id is being used.\n*/\n\n(sel) => do\n  // Normalize action input\n  sel= actionNormInput(sel, \"ids\")\n\n  // Find latest sprint (highest number)\n  latestSprintRef: readAll(sprint)\n                   .sortr((a,b) => a->sprint <=> b->sprint)\n                   .first->id\n\n  // Cycle through selection\n  sel.each sId => do\n    // Load record\n    sObj: readById(sId)\n    // Create list of target deficiencies' ids\n    defIds: if (sObj.has(\"deficiency\")) [sId]\n            // Else deficiencies need to be queried\n            else readAll(deficiency and\n                         deficiencyGroupRef==sObj->deficiencyGroupRef and\n                         siteRef==sObj->siteRef)\n                 // For sprintRef use findAll b/c it can be null\n                 .findAll(r => r[\"sprintRef\"]==sObj[\"sprintRef\"])\n                 .colToList(\"id\")\n    // Cycle through deficiencies in group\n    defIds.each dId => do\n      d: readById(dId)\n      // Change sprint to latest\n      dDictUpdate: {id: d->id,\n                    mod:d->mod}\n      // If state is New, Backlog or In Consideration, change to To Do\n      // and link to latest sprint\n      if ([\"New\",\"Backlog\",\"In Consideration\"].contains(d[\"state\"]))\n        dDictUpdate= dDictUpdate.set(\"state\", \"To Do\")\n                                .set(\"sprintRef\", latestSprintRef)\n      // If state is To Do or In Progress, change to Backlog and remove\n      // link to sprint\n      else if ([\"To Do\",\"In Progress\"].contains(d[\"state\"]))\n        dDictUpdate= dDictUpdate.set(\"state\", \"Backlog\")\n                                .set(\"sprintRef\", removeMarker())\n      else return null\n        \n      recEditDeficiency(dDictUpdate)\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAV",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point, add these points to zone and to equips that already exist.\n \n The file includes a match to the 2018-11-28 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(file: `io/integration_b33/vav.csv`,\ntypes: [0,1,2,3,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(file)\n  \n  siteId: read(site and dis==\"33\")->id\n  failedList: []\n  \n  // Load up grid of existing supply TUs for given site\n  tus: readAll(supply and terminalUnit and equip\n               and siteRef==siteId)\n  \n  // For each supply terminal unit, find the appropriate\n  // VAV ZN connector using the connector's vavZn info\n  tus= tus.addCol(\"vavConnRef\", row => do\n             vavDis: reFind(\"VAV-\\\\d\\\\d\\\\d\",row[\"navName\"])\n             read(conn and bacnetConn and vavZn==vavDis)->id\n           end)\n           \n  // Cycle through existing terminal units\n  tus.each((tu, i) => do\n    jobProgress(round(i/tus.size()*100).as(\"%\"), tu.dis())\n    locationId: tu->locationRef\n    zoneId: tu->equipRef\n    connectorId: tu->vavConnRef\n    \n    // Find exhaust TU if it exists\n    etu: read(exhaust and terminalUnit and equip and equipRef==zoneId,\n              false)\n    \n    // Prepare list of bacnet grids containing all bacnet info for given types\n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"TL\"]\n    \n    try do\n      types.each type => do\n        learn: bacnetLearn(connectorId, type)\n        bacnetPtList= bacnetPtList.set(type, learn)\n      end\n    end catch (ex) do\n      failedList= failedList.add(tu.dis())\n      // Skip terminal unit\n      return null\n    end\n\n    // Cycle through given points of interest, find and integrate\n    alcPtList.each pt => do\n      // Find corresponding tag set info in tagging standard\n      tagRow: tagStd.find(tag => tag->index==pt->indexTagStandard)\n    \n      // Initialize found bacnet rows to null\n      bacnetCurRow: null\n      bacnetHisRow: null\n    \n      // If bacnetCur is available, retrieve corresponding info\n      if (pt[\"bacnetCurName\"] != null) do\n        curType: bacnetObjMap.index(pt[\"bacnetCurType\"])\n        \n        // Find available BACnet point info\n        bacnetCurGrid: bacnetPtList[curType]\n        if (bacnetCurGrid == null) bacnetCurGrid= [].toGrid()\n        bacnetCurRow= bacnetCurGrid.find(row => row[\"dis\"]==pt->bacnetCurName)\n        \n        // If point not found in BACnet, it is hidden or does not\n        // exist for this zone. Skip point only if bacnetHis also missing\n      end // If bacnetCur is available\n      \n      // If bacnetHis is available, retrieve corresponding info\n      if (pt[\"bacnetHisName\"] != null) do      \n        // Find available BACnet point info\n        bacnetHisGrid: bacnetPtList[20]\n        if (bacnetHisGrid == null) bacnetHisGrid= [].toGrid()\n        bacnetHisRow= bacnetHisGrid.find(row => row[\"dis\"]==pt->bacnetHisName)\n      end\n\n      // If we did not find BACnet info for either Cur or His, skip point\n      if ((bacnetCurRow == null) and (bacnetHisRow == null)) return null\n      \n      // Check equipment type to determine proper equipRef\n      equipId: if (pt->eq==\"supply\") tu->id else etu->id\n          \n      // If point already exists, skip\n      ptFilter: \"point and equipRef==@\" + equipId + \" and \"\n                + tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n      if (read(parseFilter(ptFilter),false) != null) return null\n          \n      // Prepare polling variables as needed (null if bacnetHis)\n      hisCollectCov: if (pt[\"hisCollectCov\"]==null) null else marker()\n      hisCollectInterval: if (pt[\"hisCollectCov\"]==null) null else 12h\n      \n      // Prepare new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur: if(bacnetCurRow != null) marker() else null, // optional\n               bacnetCur: if (bacnetCurRow != null) bacnetCurRow[\"bacnetCur\"],\n               bacnetHis: if (bacnetHisRow != null) bacnetHisRow[\"bacnetHis\"],\n               bacnetCurName: pt[\"bacnetCurName\"],\n               bacnetHisName: pt[\"bacnetHisName\"],\n               kind: if (bacnetCurRow != null) bacnetCurRow[\"kind\"] else pt[\"kind\"],\n               unit: if (bacnetCurRow != null) bacnetCurRow[\"unit\"] else pt[\"unit\"],\n               enum: if (bacnetCurRow != null) bacnetCurRow[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               hisCollectCov: hisCollectCov,\n               hisCollectInterval: hisCollectInterval,\n               notes: if (bacnetCurRow != null) bacnetCurRow[\"bacnetDesc\"], //optional\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp2: today()}\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n    end  // alcPtList.each pt\n  end)  // each tu\n  \n  return failedList\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ruAirflowSpNotMet","anHunting","toolRecursiveSearch","ruSensorOoRange","ruReheatLeak","anStale","ruDamperControl"],,,,M,,,,,,"viZoneReport",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For all zones in a given site, run several analyses and display a summary\n  grid including type and number of issues found. Analyses currently include:\n  - anHunting, applied on valve and damper commands\n  - anStale, applies to all points that are not virtual and not sp\n             (currently cmd category excludes reheat valve cmd)\n  - ruAirflowSpNotMet, applies to all terminal units in zone\n  - ruDamperControl, applies to all terminal unit dampers\n  \n  Arguments: \n  siteRef        site to analyze\n  span           dateSpan, span of dates to run analysis on\n*/\n\n(siteRef: @p:lbnl:r:225ffa71-7758e5e3, span:pastWeek()) => do\n  zones: readAll(equip and zone and siteRef==siteRef)\n  \n  zones= zones.map z => do\n    zoneDict: {id: z->id, room: z->navName, lab: z[\"lab\"],\n               controls: z[\"controls\"],\n               vavController: z[\"controller\"],\n               untController: z[\"untController\"],\n               untZone: z[\"untZone\"]}\n    supplyTU: read(supply and terminalUnit and equip and equipRef==z->id,false)\n    \n    if (supplyTU != null) do\n      supplyAHU: readById(supplyTU->ahuRef)->navName\n      zoneDict= zoneDict.set(\"supplyAHU\", supplyAHU)\n      \n      if (zoneDict[\"vavController\"] == null)\n        zoneDict= zoneDict.set(\"vavController\", supplyTU[\"controller\"])\n        \n      if (zoneDict[\"untController\"] == null)\n        zoneDict= zoneDict.set(\"untController\", supplyTU[\"untController\"])\n        \n      if (zoneDict[\"untZone\"] == null)\n        zoneDict= zoneDict.set(\"untZone\", supplyTU[\"untZone\"])\n    end\n  \n    // Run anHunting on valve and damper commands\n    h: toolRecursiveSearch(z->id, \"(damper or valve) and cmd and unit==\\\"%\\\"\")\n         .map(pt => do\n           his: readById(pt->id).hisRead(span, {limit: null})\n           periods: anHunting(his)\n           flag: if (periods == null) null else periods.foldCol(\"v0\",sum)\n           {id: pt->id, flag: flag}\n         end)\n         .findAll(pt => pt[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"hunting\", if(isEmpty(h)) null\n                                      else h.foldCol(\"id\",count))\n                                      \n    // Run anStale on all sensors that are not virtual and of kind \"Number\"\n    s: toolRecursiveSearch(z->id, \"point and not virtual and sensor \" +\n                                  \"and kind==\\\"Number\\\"\")\n         .map(pt => do\n           his: readById(pt->id).hisRead(span, {limit: null})\n           periods: anStale(his)\n           flag: if (periods == null) null else periods.foldCol(\"v0\",sum)\n           {id: pt->id, flag: flag}\n         end)\n         .findAll(pt => pt[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"staleSensors\", if(isEmpty(s)) null\n                                           else s.foldCol(\"id\",count))\n                                           \n    // Run anStale on all cmds that are not virtual and of kind \"Number\"\n    c: toolRecursiveSearch(z->id, \"point and not virtual and cmd \" +\n                                  \"and not heat and not pid \" +\n                                  \"and kind==\\\"Number\\\"\")\n         .map(pt => do\n           his: readById(pt->id).hisRead(span, {limit: null})\n           periods: anStale(his)\n           flag: if (periods == null) null else periods.foldCol(\"v0\",sum)\n           {id: pt->id, flag: flag}\n         end)\n         .findAll(pt => pt[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"staleCommands\", if(isEmpty(c)) null\n                                           else c.foldCol(\"id\",count))\n                                           \n    // Run ruAirflowSpNotMet on all terminal units\n    a: toolRecursiveSearch(z->id, \"equip and terminalUnit\")\n         .map(eq => do\n           periods: ruAirflowSpNotMet(eq, span, 0.05)\n           flag: if (periods == null) null else periods.foldCol(\"diff\",sum)\n           {id: eq->id, flag: flag}\n         end)\n         .findAll(eq => eq[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"airflowIssues\", if(isEmpty(a)) null\n                                           else a.foldCol(\"id\",count)) \n                                           \n    // Run ruDamperControl on all terminal units (99%-100% open)\n    d: toolRecursiveSearch(z->id, \"equip and terminalUnit\")\n         .map(eq => do\n           periods: ruDamperControl(eq, span, [99%,100%])\n           flag: if (periods == null) null else periods.foldCol(\"v0\",sum)\n           {id: eq->id, flag: flag}\n         end)\n         .findAll(eq => eq[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"damperFullOpen\", if(isEmpty(d)) null\n                                           else d.foldCol(\"id\",count))\n                                           \n    // Run ruDamperControl on all terminal units (0%-1% open)\n    o: toolRecursiveSearch(z->id, \"equip and terminalUnit\")\n         .map(eq => do\n           periods: ruDamperControl(eq, span, [0%,1%])\n           flag: if (periods == null) null else periods.foldCol(\"v0\",sum)\n           {id: eq->id, flag: flag}\n         end)\n         .findAll(eq => eq[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"damperClosed\", if(isEmpty(o)) null\n                                           else o.foldCol(\"id\",count))\n                                           \n    // Run ruReheatLeak on all terminal units\n    r: toolRecursiveSearch(z->id, \"equip and terminalUnit\")\n         .map(eq => do\n           periods: ruReheatLeak(eq, span)\n           flag: if (periods == null) null else periods.foldCol(\"flag\",sum)\n           {id: eq->id, flag: flag}\n         end)\n         .findAll(eq => eq[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"reheatLeak_orSensorCalib\",\n                           if(isEmpty(r)) null\n                           else r.foldCol(\"id\",count))\n                           \n    // Run ruSensorOoRange on all terminal units\n    oor: toolRecursiveSearch(z->id, \"equip and terminalUnit\")\n         .map(eq => do\n           periods: ruSensorOoRange(eq, span)\n           flag: if (periods == null) null else periods.foldCol(\"v0\",sum)\n           {id: eq->id, flag: flag}\n         end)\n         .findAll(eq => eq[\"flag\"] != null)\n    zoneDict= zoneDict.set(\"sensorOutofRange\",\n                           if(isEmpty(oor)) null\n                           else oor.foldCol(\"id\",count))\n  end\n  \n  // Reorder columns for legibility\n  cols: zones.colNames().findAll(v => not(\n      [\"id\",\"room\",\"lab\",\"controls\",\"supplyAHU\",\n       \"vavController\",\"untController\",\"untZone\"]\n      .contains(v)))\n  cols= cols.sort((a,b) => a <=> b)\n  cols= cols.insert(0, \"id\")\n            .insert(1, \"room\")\n            .insert(2, \"supplyAHU\")\n            .insert(3, \"vavController\")\n            .insert(4, \"untController\")\n            .insert(5, \"untZone\")\n            .insert(6, \"lab\")\n            .insert(7, \"controls\")\n  zones= zones.reorderCols(cols)\n  \n  // Filter out zones without issues\n  zones.findAll(row => any(row.remove(\"id\")\n                              .remove(\"room\")\n                              .remove(\"lab\")\n                              .remove(\"controls\")\n                              .remove(\"supplyAHU\")\n                              .remove(\"vavController\")\n                              .remove(\"untController\")\n                              .remove(\"untZone\"),\n                           v => v != null))\n       .sort((a,b) => readById(a->id).dis() <=> readById(b->id).dis())\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateDeficiency","recValidateDeficiencyGroup"],,,,M,,,,,,"recNewDeficiencyGroup",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyGroupDict) => do\n  // Normalize action input\n  deficiencyGroupDict= actionNormInput(deficiencyGroupDict, \"dict\")\n  \n  // Validate record\n  deficiencyGroupDict= recValidateDeficiencyGroup(deficiencyGroupDict)\n\n  recNew(deficiencyGroupDict)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74EquipFH",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create fume hoods\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b74/tsi_fhc.csv`)\n  \n  siteDis: \"74\"\n  siteId: read(site and dis==siteDis)->id\n  \n  file.each row => do\n    floorDis: row[\"floor\"]\n    locationDis: \"B74 Floor \" + floorDis    \n    locationId: read(location and siteRef==siteId and\n                  dis==locationDis)->id\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    zoneId: read(zone and locationRef==locationId\n                 and navName==roomDis)->id\n                 \n    vavNum: reGroups(\"74-VAV-(\\\\d\\\\d\\\\d)\",row[\"vav\"])[1]\n    fhDis: \"Fume Hood, VAV-\" + vavNum\n    exhSysId: read(siteRef==siteId and exhaustSystem and equip\n                   and notes==row[\"exhaust\"])->id\n        \n    uriText: row[\"bacnetAddress\"]\n    uri: parseUri(uriText)\n    connRef: read(conn and bacnetConn and uri==uri)->id\n    \n    exist: readAll(siteRef==siteId and \n                   locationRef==locationId and\n                   equip and fumeHood\n                   and equipRef==zoneId\n                   and navName==fhDis)\n   \n    // Create Fume Hood\n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: fhDis,\n         disMacro: \"\\\$equipRef \\\$navName\",\n         exhaustSystemRef: exhSysId,\n         connRef: connRef,\n         connInstance: row[\"instance\"],\n         controls: row[\"controlProg\"],\n         fumeHood,\n         equip,\n         locationRef: locationId,\n         siteRef: siteId,\n         equipRef: zoneId,\n         size: parseNumber(row[\"nominalSize\"]).as(1ft),\n         tmp2:today()\n        },\n        {add}\n      ))\n    end\n    \n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolRecursiveSearch","toolRecTags"],,,,M,,,,,,"ptVirtualByTagsAvg",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Determine identifying tags of virtual point, then search for\n  points with the same tags downstream of the equip tree with\n  toolRecursiveSearch, and average their values.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  // Normalize to absolute ref (for old Historian)\n  rec= rec->id.readById\n  \n  // Determine identifying tags and create tags filter string\n  tagsSet: toolRecTags(rec)\n  tagsStr: tagsSet.concat(\" and \")\n  \n  // Look for non-virtual points with the same tags in equip tree\n  pts: toolRecursiveSearch(\n           rec->equipRef->id,                        // trunkRef\n           \"point and \"+tagsStr+\" and not virtual\",  // filterStr\n           [\"equipRef\"],                             // refTypes\n           5)                                        // maxDepth\n       // Ensure no infinite loop\n       .findAll(pt => pt->id != rec->id)\n  \n  // Read available history, align, fold, yield\n  hisGrid: pts.hisRead(dates, {limit:null})\n  hisGrid.toolHisAlign(avg, min,  // rollupFunc, intervalFunc\n                       true)      // removeMissing\n         .hisFoldCols(avg)\n         .each(row => yield(row->ts, row->v0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAVTSI",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_b33/tsi_integ_1of2.csv`\n to add these points to zone equips that exist and exhaust TUs that\n may not exist.\n \n The relation between ALC VAVs and the TSI integration programs\n is in file `io/integration_b33/vav_tsi.csv`\n \n The first file includes a match to the 2018-09-04 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n() => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b33/tsi_integ_1of2.csv`)\n  alcEqList: ioReadCsv(`io/integration_b33/vav_tsi.csv`)\n  \n  siteId: read(site and dis==\"33\")->id\n  \n  // Cycle through equips\n  alcEqList.findAll(row => row->controlProgram != \"lbnl33_tsi_8682_rht_bacnet\")\n           .each((eqRow, indexEqRow) => do\n    jobProgress((indexEqRow / alcEqList.size())*100.as(1%), eqRow->supplyVAV)\n    \n    supplyTUId: read(supply and terminalUnit and equip and siteRef->id==siteId\n                 and navName==reGroups(r\"33-(VAV-\\d{3})\",eqRow->supplyVAV)[1])->id\n    zoneId: supplyTUId->equipRef\n    numSupplyTUs: readAll(supply and terminalUnit and equip and equipRef==zoneId).foldCol(\"id\", count)\n    locationId: supplyTUId->locationRef\n    \n    if (numSupplyTUs != 1) throw \"Error, number of VAVs != 1 for \" + readById(zoneId)->navName\n    \n    // Create fume hood and exhaust terminal unit equips if needed\n    // Fume hood\n    if (read(fumeHood and equipRef==zoneId, false) == null) do\n      eqDict1: {navName: \"Fume Hood\",\n               disMacro: \"\\\$equipRef \\\$navName\",\n               equip,\n               equipRef: zoneId,\n               locationRef: locationId,\n               siteRef: siteId,\n               fumeHood,\n               test20180904}\n      commit(diff(null, eqDict1, {add}))\n    end // if no fume hood equip\n    fumeHoodId: read(fumeHood and equipRef==zoneId)->id\n    \n    // Exhaust terminal unit\n    if (read(exhaust and terminalUnit and equipRef==zoneId, false) == null) do\n      eqDict2: {navName: \"Exhaust TU\",\n               disMacro: \"\\\$equipRef \\\$navName\",\n               equip,\n               equipRef: zoneId,\n               locationRef: locationId,\n               siteRef: siteId,\n               exhaust,\n               terminalUnit,\n               test20180904}\n      commit(diff(null, eqDict2, {add}))\n    end // if no exhaust terminal unit equip\n    exhaustTUId: read(exhaust and terminalUnit and equipRef==zoneId)->id\n    \n    // Load needed connector, and TL and AV points list\n    connectorId: parseRef(eqRow->routerRef)\n    \n    bacnetLearn(connectorId)\n    bacnetPtList2: bacnetLearn(connectorId, 2)\n    if (isEmpty(bacnetPtList2)) return \"bacnetLearn failed\"\n    \n    bacnetLearn(connectorId)\n    bacnetTrendList: bacnetLearn(connectorId, 20)\n    if (isEmpty(bacnetTrendList)) return \"bacnetLearn failed\"\n  \n    // Go through list of points of interest for each eq and integrate\n    alcPtList.each ptRow => do\n      // Detect type of point to determine proper equipRef\n      if (ptRow->indexTagStandard.parseNumber() < 179) do equipId: zoneId\n      else if (ptRow->indexTagStandard.parseNumber() < 184) do equipId: supplyTUId\n      else if (ptRow->indexTagStandard.parseNumber() < 187) do equipId: exhaustTUId\n      else do equipId: fumeHoodId end\n      \n      // Find bacnetCur and related info\n      bacnetDis: ptRow->bacnetDis + \"_\" + eqRow->instance\n      bacnetRow: bacnetPtList2.find(row => row[\"dis\"]==bacnetDis)\n      if (bacnetRow == null) return \"next point\"\n      \n      // Find bacnetHis\n      bacnetTrendDis: ptRow->bacnetTrendDis + \"_\" + eqRow->instance\n      bacnetTrendRow: bacnetTrendList.find(row => row[\"dis\"]==bacnetTrendDis)\n      if (bacnetTrendRow == null) return \"next point\"\n      \n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: bacnetRow->bacnetCur,\n               bacnetHis: bacnetTrendRow->bacnetHis,\n               bacnetName: bacnetDis,\n               kind: bacnetRow->kind,\n               unit: bacnetRow->unit,\n               equipRef: equipId,\n               his,\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp20180904,\n               notes: ptRow->pointName}\n                \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==ptRow->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      commit(diff(null, ptDict, {add}))\n      \n    end // alcPtList.each ptRow\n  end) // alcEqList.each eqRow\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Zone Temp Deadband Too Tight",,M,"Effective zone deadband between cooling and heating setpoint was below threshold (default 2°F), or setpoints are reversed",,,,,"ruZoneDeadbandTight",,"terminalUnit or zone","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates, minDb: 2°F, minTime: 1h, mergePeriod: 15min) => do\n  // Get setpoints\n  cool: read(point and zone and air and temp\n             and effective and cooling and sp\n             and equipRef==equip->id, false)\n  heat: read(point and zone and air and temp\n             and effective and heating and sp\n             and equipRef==equip->id, false)\n             \n  // If the zone has only one setpoint, no deadband needed\n  if (cool==null or heat==null) return null\n  \n  // Read history, combine, calculate deadband\n  diff: [cool,heat].hisRead(dates, {limit: null})\n             .hisInterpolate()\n             .addCol(\"diff\", row => do\n               if (row[\"v0\"]==null or row[\"v1\"]==null or row[\"v0\"]==0)\n                 return null\n               else\n                 return (row[\"v0\"] - row[\"v1\"]).as(unit(row[\"v0\"]))\n             end)\n             .keepCols([\"ts\",\"diff\"])\n             .hisFindAll(val => val != null)\n   \n  // Find periods deadband is tighter than parameter (or negative)\n  flagPeriods: diff.hisFindPeriods(val => val.to(\"°F\") < minDb)\n\n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->diff >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip->navName + \" has a tight deadband or reversed setpoints\"\n  return flagPeriods.addColMeta(\"diff\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33VAVConn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with ip, dnet, dadr and vav number,\n  and create corresponding bacnet connector\n*/\n\n() => do\n  ioReadCsv(`io/b33_alc_floor_2_3_vav_bacnet_connectors.csv`)\n  .each row => do\n    loc: row[\"location\"]\n    disText: loc + \" - ZN - VAV-\" + row[\"vav\"]\n    uriText: \"bacnet://\"+row[\"ip\"]+\"/\"+row[\"did\"]\n             +\"?dnet=\"+row[\"dnet\"]\n             +\"&dadr=\"+toHex(parseInt(row[\"dadr\"]))\n    \n    commit(diff(\n      null,\n      {dis: disText,\n       uri: parseUri(uriText),\n       conn,\n       bacnetConn,\n       siteRef: read(site and dis==\"33\")->id,\n       vavZn: \"VAV-\" + row[\"vav\"]},\n      {add}\n    ))\n  end\n  \n  readAll(conn and bacnetConn and b33)\n  .each connector => bacnetPing(connector)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneOverconditioning"],,,,M,,,,,,"viAhuZoneOverconditioning",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, calculate the overcooling or overheating for all\n  TUs served by that AHU (using anAhuZoneOverconditioning) then\n  display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), maxDev: 100, rollup: 15min, zoneIdList:null, filterUnocc:true) => do\n  devs: anAhuZoneOverconditioning(ahuRef, dates, maxDev, rollup, zoneIdList, filterUnocc)\n  maxDev= maxDev.as(\"_%°F\")\n  \n  try do\n    devs= devs\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n                rm: his->dis,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {unit:\"_%°F\",\n                           chartMin: maxDev * -1,\n                           chartMax: maxDev})\n        .addMeta({view: \"chart\", chartType:\"heatMap\",\n                  title: \"Overcooling and overheating, zones served by \"\n                         +readById(ahuRef).dis(),\n                  colors: \"blue, #cccccc, red\"})\n  catch (ex) do\n    devs= null\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recNewTask"],,,,M,,,,,,"recDuplicateTask",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Record duplication action for task\n  \n  Arguments:\n  taskDict       Dict containing only changes to the original\n                 selected record the duplication is based on.\n*/\n\n(taskDict) => do\n  // Normalize action input\n  taskDict= actionNormInput(taskDict, \"dict\")\n  \n  // Load original dictionary based on id, this dict will contain\n  // all fields\n  originalDict: readById(taskDict->id)\n  \n  // Initialize new dictionary for our new record\n  newDict: originalDict\n  \n  // Any record present in taskDict represents a change\n  // from the originalDict. Apply change to newDict.\n  taskDict.each((v,n) => do\n    newDict= newDict.set(n, v)\n  end)\n\n  // This will be a new record, remove \"id\" and \"mod\" fields\n  newDict= newDict\n  .remove(\"id\")\n  .remove(\"mod\")\n  \n  // Submit to recNewTask\n  recNewTask(newDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anHunting"],,"Damper Hunting",,M,"Damper command rate of change exceeded a given threshold (default 5%/min) for longer than a given time period (default 30min)",,,,,"ruDamperHunting",,"terminalUnit","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates, maxChangePerMinute: 5%, mergePeriod: 30min, minTime: 30min) => do\n  // Get damper cmd point, return null if not found\n  damper: read(point and damper and cmd and equipRef==equip->id, false)\n  if (damper == null) return null\n  \n  // Get history data, and use exterior function anHunting\n  data: damper.hisRead(dates, {limit: null})\n  if (isEmpty(data)) return null\n  \n  // Sparks from returned periods\n  sparks: anHunting(data, maxChangePerMinute, mergePeriod, minTime)\n  \n  if (sparks==null or isEmpty(sparks)) return null\n  else return sparks\n\n end\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatGrid","anReadMeterMonthly","toolModelStats"],,,,M,,,,,,"viMeterMonthlyRegression_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display monhtly data graph associated with a regression of \n  monthly consumption data.\n  \n  Arguments: \n  meterRef              Id of a meter with monthly records (checks sblid tag)\n  baseOverride          Str, \"Input\", \"Last 12 Months\", \"Previous 12 Readings\" or \"FY XXXX\"\n  postOverride          Str, \"Input\", \"Last 12 Months\", \"Previous 12 Readings\" or \"FY XXXX\"\n  hddBase               Number, temperature, need either hddBase or cddBase\n  cddBase               Number, temperature, need either hddBase or cddBase\n  baseSpan              DateSpan, baseline period input if not overriden\n  postSpan              DateSpan, post-installation period input if not overriden\n  normSpan              DateSpan, normalization period\n  view                  Str, \"Consumption\", \"Scatter\", \"Stats\", \"Normalized\", \"Savings\"\n  disregardIgrnore      Bool, if true load ignored monthly reads\n*/\n(meterRef, baseOverride:\"\", postOverride:\"\", hddBase:null, cddBase:null,\n baseSpan:null, postSpan:null, normSpan:null,\n view:\"Consumption\", disregardIgnore:false) => do\n  // Parse base and post period overrides\n  baseSpanO: try do bFY: reGroups(r\"FY ?(\\d{4})\", baseOverride)[1].parseInt()\n                    (date(bFY-1,10,1)..date(bFY,9,30))\n             end catch if (baseOverride==\"Last 12 Months\")\n                         (date(today().year-1,today().month,1)..date(today().year,today().month,1))\n                       else if (baseOverride==\"Recent 12 Months\")\n                         ((date(today().year-1,today().month,1)+30day)..today())\n                       else if (baseOverride==\"Previous 12 Readings\")\n                         \"Previous 12 Readings\"\n                       else null\n  postSpanO: try do pFY: reGroups(r\"FY ?(\\d{4})\", postOverride)[1].parseInt()\n                    (date(pFY-1,10,1)..date(pFY,9,30))\n             end catch if (postOverride==\"Last 12 Months\")\n                         (date(today().year-1,today().month,1)..date(today().year,today().month,1))\n                       else if (postOverride==\"Recent 12 Months\")\n                         (date(today().year-1,today().month+1,1)..date(today().year,today().month+1,1))\n                       else if (postOverride==\"Previous 12 Readings\")\n                         \"Previous 12 Readings\"\n                       else null\n  if (baseSpanO != null) baseSpan= baseSpanO\n  if (postSpanO != null) postSpan= postSpanO\n  \n  // Test all required inputs have been provided\n  if (baseSpan==null) return {errorDis:\"Missing baseSpan\"}.toGrid\n  try if(hddBase!=null) hddBase.to(\"°F\")\n  catch return {errorDis:\"hddBase must be a temperature\"}.toGrid\n  try if(cddBase!=null) cddBase.to(\"°F\")\n  catch return {errorDis:\"cddBase must be a temperature\"}.toGrid\n  if (cddBase==null and hddBase==null) return {errorDis:\"hddBase or cddBase required\"}.toGrid\n  meter: if (isRef(meterRef)) readById(meterRef)\n         else meterRef\n  // Meter needs sblid tag to be attributed monthly data\n  if (meter.missing(\"meter\") or meter.missing(\"sblid\"))\n    return {errorDis:\"Not a SBLID meter\", err}.toGrid\n \n  // If cddBase or hddBase are zero, convert to null, else convert to °F\n  hddBase= if (hddBase==0) null else hddBase.to(\"°F\")\n  cddBase= if (cddBase==0) null else cddBase.to(\"°F\")\n \n  // Variables\n  weatherId: meter->siteRef->weatherRef\n  meterId: meter->id\n  \n  // Retrieve data\n  grid: anReadMeterMonthly(meterId,                               // meterRef\n                           if (hddBase==null) 65°F else hddBase,  // hddBase\n                           if (cddBase==null) 55°F else cddBase,  // cddBase\n                           disregardIgnore)                       // disregardIgnore\n        .addMeta({title:meter.dis})\n  \n  // Exit if data is missing\n  if (isEmpty(grid) or grid==null or grid.has(\"err\"))\n    return {errorDis:\"No data\", err}.toGrid\n  \n  // Unit\n  try do\n    tUnit: grid[0][\"cons\"].unit\n    rUnit:grid[0][\"consumptionPerDay\"].unit \n  end catch return {errorDis:\"Could not determine unit of measurement\", err}.toGrid\n  \n  // Keep only relevant columns to run regressions on\n  grid= grid\n  .reorderCols([\"readDate\",\"countDays\",\"consumptionPerDay\",\"cons\",\"heat\",\"cool\"]) \n  \n  // Remove HDD / CDD if unused\n  xCols: []\n  if (hddBase!=null) xCols= xCols.add(\"heat\")\n  if (cddBase!=null) xCols= xCols.add(\"cool\")\n  if (isEmpty(xCols))\n    return {errorDis: \"Missing both HDD base temp and CDD base temp\", err}.toGrid\n\n  // Change spans if \"Previous 12 Readings\"\n  if (baseSpan==\"Previous 12 Readings\")\n    baseSpan= grid[-13][\"readDate\"]-1day..grid[-2][\"readDate\"]\n  if (postSpan==\"Previous 12 Readings\")\n    postSpan= grid[-13][\"readDate\"]-1day..grid[-2][\"readDate\"]\n \n  // Base model results\n  baseRes: grid\n           .findAll(r => baseSpan.toDateSpan.contains(r->readDate -1day))\n           \n  if (isEmpty(baseRes)) return {errorDis:\"No baseline data\", err}.toGrid\n  baseRes= baseRes\n           .toolModelStats([\"consumptionPerDay\"], xCols)\n           .set(\"case\", \"Base\")\n  \n  // If model has a postSpan, create post model\n  if (postSpan != null) do\n    postRes: grid\n             .findAll(r => postSpan.toDateSpan.contains(r->readDate -1day))\n             \n    if (isEmpty(postRes)) return null\n    postRes= postRes\n             .toolModelStats([\"consumptionPerDay\"], xCols)\n             .set(\"case\", \"Post\")\n  end else postRes: null\n\n  // Add adjusted baseline to grid\n  grid= grid.addCol(\"adjustedBase\", row => do\n    // Begin with offset\n    v: baseRes->a\n    // Add coeffs based on HDD, CDD, as needed\n    xCols.each(xCol => v = v + baseRes[\"b\"+capitalize(xCol)] * row[xCol])\n    // Model is for unit/day, multiply by number of days for total consumption\n    v= v * row->countDays\n    // Force unit to original unit\n    v= v.as(tUnit)\n  end)\n\n  // Add adjusted baseline per day\n  grid= grid\n  .addCol(\"adjustedBasePerDay\",\n          row => row[\"adjustedBase\"] / row[\"countDays\"])  \n  \n  // Formatting\n  grid= grid\n  .addCol(\"basePeriod\", r =>\n            if (baseSpan.toDateSpan.contains(r->readDate-1day))\n              true\n            else false)\n  .addColMeta(\"basePeriod\",\n              {dis:\"Baseline Period\",\n               color: \"darkorange\",\n               chartGroup:\"2\",\n               chartType:\"runtime\",\n              })\n  .addColMeta(\"adjustedBasePerDay\",\n              {dis:\" \"+meter.dis+\", Weather-Adjusted Baseline Avg Daily Consumption\",\n               color: \"grey\",\n               chartGroup:\"1\",\n               chartType:\"bar\"\n              })\n              \n  // Add postPeriod if needed\n  if (postSpan != null) do\n    grid= grid\n    .addCol(\"postPeriod\", r =>\n              if (postSpan.toDateSpan.contains(r->readDate-1day))\n                true\n              else false)\n    .addColMeta(\"postPeriod\",\n                {dis:\"Post Period\",\n                 color: \"royalblue\",\n                 chartGroup:\"2\",\n                 chartType:\"runtime\",\n                 hisMode:\"cov\"\n                })\n  end\n\n  // Normalized consumption\n  if (normSpan==null) normSpan= 2012-01-01..2018-12-31\n  normGrid: {}.toGrid\n  normSpan.eachMonth(mo => do\n    normGrid= normGrid.addRow(\n      {readDate: mo.end,\n       heat: if (hddBase != null)\n               readById(weatherId)\n               .degreeDays(mo, hddBase)\n               .foldCol(\"heat\", sum),\n       cool: if (cddBase != null)\n               readById(weatherId)\n               .degreeDays(mo, cddBase)\n               .foldCol(\"cool\", sum),\n       countDays: mo.end - mo.start + 1day \n      })\n  end)\n  // Add normalized baseline\n  normGrid= normGrid.addCol(\"base\", row => do\n    // In normalized grid, heat and cool are total for the period, not /day\n    // Therefore only the intercept needs to be multiplied by countDays\n    v: (baseRes->a * row->countDays).as(1)\n    xCols.each(xCol => v = v + baseRes[\"b\"+capitalize(xCol)] * row[xCol])\n    v= v.as(tUnit)\n  end)\n  // Add normalized post\n  if (postRes!=null)\n    normGrid= normGrid.addCol(\"post\", row => do\n      v: (postRes->a * row->countDays).as(1)\n      xCols.each(xCol => v = v + postRes[\"b\"+capitalize(xCol)] * row[xCol])\n      v= v.as(tUnit)\n    end)\n\n  // Views\n  if (view==\"Consumption\")\n    return grid.keepCols([\"readDate\",\"basePeriod\",\"postPeriod\",\n                          \"consumptionPerDay\",\"adjustedBasePerDay\"])\n               .addColMeta(\"consumptionPerDay\", \n                   {dis:meter.dis+\", Avg Daily Consumption\",\n                    color: if (meter.has(\"gas\")) \"crimson\"\n                           else \"royalblue\",\n                    chartGroup:\"1\",\n                    chartType:\"bar\"})\n  else if (view==\"Scatter\") do\n    xVar: if (meter.has(\"gas\")) \"heat\" else \"cool\"\n    baseGrid: grid\n    .findAll(r => baseSpan.toDateSpan.contains(r->readDate-1day))\n    .keepCols([xVar,\"consumptionPerDay\"])\n    .renameCol(\"consumptionPerDay\",\"consumptionPerDayBase\")\n    .addColMeta(\"consumptionPerDayBase\",\n                {dis:\"Baseline Avg Daily Consumption\",\n                 chartGroup:\"1\",\n                 color:\"darkorange\"})\n    if (postRes!=null) do\n      postGrid: grid\n      .findAll(r => postSpan.toDateSpan.contains(r->readDate-1day))\n      .keepCols([xVar,\"consumptionPerDay\"])\n      .renameCol(\"consumptionPerDay\",\"consumptionPerDayPost\")\n      grid= baseGrid.addRows(postGrid)\n            .addColMeta(\"consumptionPerDayPost\",\n                        {dis:\"Post Avg Daily Consumption\",\n                         color:\"royalblue\",\n                         chartMin:0.as(rUnit),\n                         chartGroup:\"1\"})\n    end else grid= baseGrid\n    return grid.reorderCols(grid.colNames.moveTo(xVar,0))\n               .sort((a,b) => a[xVar] <=> b[xVar])\n               .addMeta({chartType:\"scatter\", title:null})\n  end else if (view==\"Stats\") do\n    results: [baseRes]\n    if (postRes!=null) results= results.add(postRes)\n    return results\n           .toGrid\n           .toolFormatGrid([\"case\",\"mape\",\"cvrmse\",\"n\"])\n  end else if (view==\"Anomaly\") do\n    results: {}\n    baseRes.each((v,k) => results= results.set(\"baseModel\"+k,v))\n    anFirst: baseSpan.end+1day\n    anLast: baseSpan.end+31day\n    anMonth: anFirst..anLast\n    anReading: grid\n               .findAll(r => anMonth.toDateSpan.contains(r->readDate))\n    if (isEmpty(anReading)) \n      return {errorDis:\"No \"+anFirst.format(\"MMM YYYY\")+\" reading\", err}.toGrid\n    anReading.first\n             .each((v,k) => results= results.set(k,v))\n    return results\nend else if (view==\"Normalized\") do\n    return normGrid.toolFormatGrid([\"readDate\",\"base\",\"post\"])\n  end else if (view==\"Savings\") do\n    if (postSpan==null) return null\n    grid= grid\n          .addCol(\"avoided\", row =>\n            // Don't include avoided consumption for periods marked as \"ignore\"\n            if(row.missing(\"consumptionPerDay\")) 0 \n            // Else calculate using total adjsuted minus total consumption read\n            else row[\"adjustedBase\"] - row[\"cons\"])\n          .findAll(r => postSpan.toDateSpan.contains(r->readDate-1day))\n    normGrid= normGrid\n              .addCol(\"savings\", row => row[\"base\"] - row[\"post\"])\n    avoidedConsumption: grid.foldCol(\"avoided\", sum)\n    adjustedBaseline: grid.foldCol(\"adjustedBase\", sum)\n    normalizedSavings: normGrid.foldCol(\"savings\", sum)\n    normalizedBaseline: normGrid.foldCol(\"base\", sum)\n    // Normalizing to 365 days\n    normalizedSavings= normalizedSavings / normGrid.foldCol(\"countDays\", sum).as(1) * 365\n    normalizedBaseline= normalizedBaseline / normGrid.foldCol(\"countDays\", sum).as(1) * 365\n    return [{dis: \"Avoided Consumption\", value: avoidedConsumption},\n            {dis: \"Avoided Consumption (% of Adjusted Baseline)\", value: (avoidedConsumption/adjustedBaseline*100).as(\"%\")},\n            {dis: \"Adjusted Baseline\", value: adjustedBaseline},\n            {dis: \"Normalized Maintained Savings\", value: normalizedSavings},\n            {dis: \"Maintained Savings (% of Normalized Baseline)\", value: (normalizedSavings/normalizedBaseline*100).as(\"%\")},\n            {dis: \"Normalized Baseline\", value: normalizedBaseline},]\n           .toGrid()\n  end else return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"mapHierarchyVavZone",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  site: read(site and dis==\"33\")\n\n  table: ioReadCsv(`io/hierarchies/33_VAV_Zone.csv`)\n         .addCol(\"vav\", row => row->supplyVAV[3..-1])\n  \n  // Combine rooms into zoneList\n  table = table.colToList(\"vav\").unique.map vav => do\n    return {vav: vav,\n            floor: table.find(row => row->vav==vav)->floor,\n            zoneList: table.findAll(row => row->vav==vav)\n                      .colToList(\"room\").concat(\", \")\n           }\n  end\n  \n  table.each row => do\n    match: read(equip and siteRef->id==site->id and navName==row->vav, false)\n    if (match != null) do\n      commit(diff(match, {zoneList: row->zoneList,\n                          floor: row->floor}))\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"viB59PowerBySystem",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the total system power for CW Pumps, TW Pumps,\n  Tower Fans, and CRAY Fans for a given time period\n  \n  find OA Wetbulb for the same time period\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  bldgRef          Ref for site ref for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(bldgRef:null, dates: today, rollup: 15min) => do\n  // Default to B59 if no ref is provided\n  if(bldgRef==null)\n    bldgRef= read(site and dis==\"59\")\n    \n  bldgRefId: bldgRef->id\n    \n  // Get the reference for the TW and CW Plants\n  cwPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and treatedWaterPlant\n                    and navName == \"Plant\")\n  \n  \n  twPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and condenserWaterPlant\n                    and navName == \"Plant\")\n                    \n  computersRef: read(siteRef==bldgRefId\n                    and equip\n                    and superComputer\n                    and navName == \"Computers\")\n                    \n  computersFansRef: read(equipRef==computersRef->id\n                    and fan\n                    and meter\n                    and equip)\n  \n  \n  // Get the power points for the TW pumps, CT Fans, CW Pumps, and CRAY fans\n  twPumpPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n  ctFanPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->fan\n                    and power\n                    and sensor)\n  \n  cwPumpPowers: readAll(locationRef==cwPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n                    \n  compFansPower: read(equipRef==computersFansRef->id\n                    and power)\n                    \n  \n   // Sum the power histories for each system, TW Pumps, CT Fans, and CW Pumps\n   totTWPumpPower: hisRead(twPumpPowers, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)  // rollupF, intervalF, removeMiss, minInterval\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"twPump\")\n   \n   totCTFanPower: hisRead(ctFanPowers, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)  // rollupF, intervalF, removeMiss, minInterval \n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"ctFan\")\n\n   totCWPumpPower: hisRead(cwPumpPowers, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)  // rollupF, intervalF, removeMiss, minInterval\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"cwPump\")\n                   \n   totCrayFanPower: hisRead(compFansPower, dates, {limit:null})\n                   .toolHisAlign(avg, min, true, rollup)  // rollupF, intervalF, removeMiss, minInterval\n                   .renameCol(\"v0\",\"crayFans\")\n                   \n   totSysPower: hisJoin([totTWPumpPower, totCTFanPower, totCWPumpPower, totCrayFanPower])\n                .toolHisAlign(avg, min, true, rollup)  // rollupF, intervalF, removeMiss, minInterval\n                .hisFoldCols(sum)\n                .renameCol(\"v0\",\"totSys\")\n                \n        \n  //Join the histories into a common map\n        combined: hisJoin([totTWPumpPower, totCTFanPower, totCWPumpPower, totCrayFanPower, totSysPower])\n                    .addColMeta(\"twPump\",\n                      {dis: \"Tower Water Pump Power\",\n                      unit: \"kW\", color: \"#4B0082\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"ctFan\",\n                      {dis: \"CT Fan Power\",\n                      unit: \"kW\", color: \"#FF8C00\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"cwPump\",\n                      {dis: \"Cooling Water Pump Power\",\n                      unit: \"kW\", color: \"#008000\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"crayFans\",\n                      {dis: \"Total CRAY Fan Power\",\n                      unit: \"kW\", color: \"#0000CD\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"totSys\",\n                      {dis: \"Total System Power\",\n                      unit: \"kW\", color: \"#000000\",\n                      chartGroup: \"all\"})\n  return combined\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgCreatePoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Review all connPointCache records, and create new points\n  for records with a tagSet and an equipRef that haven't yet\n  been integrated.\n*/\n\n() => do\n  // Retrieve cached records that are ready and not yet integrated\n  newPts: readAll(connPointCache and tagSetRef and equipRef\n                  and not pointRef)\n  \n  // Process each record\n  newPts.each newPt => do\n    // Retrieve equip record\n    eq: readById(newPt->equipRef)\n    \n    // Retrieve tagSet record\n    tagSet: readById(newPt->tagSetRef)\n    \n    // Create new point dict\n    ptDict: {point,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: newPt->connRef,\n             connRef: newPt->connRef,\n             cur: if(newPt.has(\"bacnetCur\")) marker() else null,\n             bacnetCur: newPt[\"bacnetCur\"],\n             bacnetCurName: newPt[\"bacnetCurName\"],\n             his: if(newPt.has(\"bacnetHis\")) marker() else null,\n             hisMode: if(newPt.has(\"bacnetHis\") and newPt[\"bacnetLogInterval\"]==0) \"cov\" else null,\n             bacnetHis: newPt[\"bacnetHis\"],\n             bacnetHisName: newPt[\"bacnetHisName\"],\n             bacnetDesc: newPt[\"bacnetDesc\"],\n             bacnetLogInterval: newPt[\"bacnetLogInterval\"],\n             bacnetLogBufferSize: newPt[\"bacnetLogBufferSize\"],\n             bacnetLogCovIncrement: newPt[\"bacnetLogCovIncrement\"],\n             kind: if (newPt.has(\"unit\") and newPt.missing(\"kind\")) \"Number\"\n                   else newPt[\"kind\"],\n             unit: newPt[\"unit\"],\n             enum: newPt[\"enum\"],\n             equipRef: newPt->equipRef,\n             locationRef: eq->locationRef,\n             siteRef: eq->siteRef,\n             tz: \"Los_Angeles\",\n             tmp: today()}\n    \n    // Add navName and meaningful tags from standard\n    ptDict= ptDict.set(\"navName\", tagSet->dis)\n    tags: tagSet->ptTags.split(\",\")\n    tags.each tag => do\n      ptDict= ptDict.set(tag, marker())\n    end\n    \n    // Commit new point\n    newRec: commit(diff(null, ptDict, {add}))\n    \n    // Initial sync\n    //if (ptDict.has(\"bacnetHis\"))\n    //  bacnetSyncHis(newRec, today()-1mo..today())\n    \n    // Update cached record\n    commit(diff(newPt, {pointRef: newRec->id}))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viTUEAndWetBulb"],,,,M,,,,,,"viB59TUESysScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of 15-minute of the TUE vs OA WB Temp data \n  at B59 (in °F)\n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01),\n dateRangePost: lastWeek().toSpan(),\n minCompPower: null, maxCompPower: null) => do\n  \n  // Load desired data from both date ranges\n  gridPre: viTUEAndWetBulb(dateRangePre, minCompPower, maxCompPower, \"Pre\")\n  gridPost: viTUEAndWetBulb(dateRangePost, minCompPower, maxCompPower, \"Post\")\n\n  // Concatenate both history grids\n  allGrid: addRows(gridPre, gridPost).removeCol(\"ts\")\n  colNames: allGrid.colNames\n  allGrid= allGrid.reorderCols(colNames.moveTo(\"oaWetBulb\", 0))             \n  \n  // Format chart\n  graph: allGrid\n         .addMeta({chartType: \"scatter\",\n                   title: \"CRAY Fan Monitoring - TUE (Baseline vs. Post)\"})\n         .addColMeta(\"oaWetBulb\", {chartMin: 35°F, chartMax: 70°F})\n         .addColMeta(\"tuePre\", \n                     {dis: \"Baseline TUE \"+dateRangePre,\n                      color: \"#7ED7DE\",\n                      chartGroup: \"all\"})\n         .addColMeta(\"tuePost\", \n                     {dis: \"Recent TUE \"+dateRangePost,\n                      color: \"#DE3E30\",\n                      chartGroup: \"all\"})\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viZoneLoadHeatMap",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load zone loads from all terminal units in a location and display\n  on a heat map.\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  locationRef   Ref for location under which to look for zone loads\n  span          Span of dates we want to display\n  clip          Value to clip load at for display (-clip..clip)\n*/\n\n(locationRef, span, clip) => do\n  unit: \"kBTU/h\"\n\n  loads: readAll(locationRef==locationRef and zone and power\n                 and sensor and equipRef->terminalUnit)\n  \n  if (isEmpty(loads)) return null\n  \n  loads= loads.hisRead(span, {limit: null})\n              .hisInterpolate()\n              .hisRollup(avg, 30min)\n  \n  try do\n    loads= loads.hisMap(v => if (v == null) null\n                             else min(max(v.to(unit),-clip),clip))\n        .hisFlatten((val, ts, his) => \n               {ts: ts,\n                rm: his->equipRef->equipRef->navName + \" \"\n                    + his->equipRef->navName,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {chartMin: clip.as(unit) * -1,\n                           chartMax: clip.as(unit)})\n        .addMeta({view: \"chart\", chartType:\"heatMap\", \n                  colors: \"red, orange, white, cyan, blue\"})\n  catch (ex) do\n    loads= null\n  end\nend\n\n    \n  /*times: loads.colToList(\"ts\")\n  ts: times.sort()[0]\n  te: times.sort()[-1]\n  \n  loads= loads.addCol(\"scaleRef\", row => do\n    if (row->ts == ts) clip * -1\n    else if (row->ts == te) clip\n    else null\n  end)\n  .hisInterpolate()*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viPUEScatter",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the PUE points for b59 and construct a scatter \n  chart with respect to outside air wetbulb temperature \n  for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(dates: today, min: null, max: null, pueNavName:null, hisInterval: null, compFilter: null, site: null, wbRef:null) => do\n  // Default to PUE, Some Estimates if no selection is made\n  if(pueNavName==null)\n    pueNavName= \"PUE, Level 1\"\n  else\n    pueNavName= \"PUE, \"+ pueNavName\n  \n  //Default to 15 mins\n  if(hisInterval==null)\n    hisInterval= 15min\n  \n  //Default to B59\n  if(site==null)\n    site= @p:lbnl:r:221f652e-4f67467f\n    \n\n  // Default to B59 TW if no wbRef is provided\n  if(wbRef==null)\n    wbRef= read(equip and siteRef->dis==\"59\" and locationRef->dis==\"B59 TW\" and navName==\"Plant\")->id\n\n  // Default to B59 Computer Compute Meter if none is provided\n  if(compFilter==null)\n    compFilter= read(siteRef==site and equipRef->navName==\"Computers\" and compute and meter and virtual and equip)\n    \n    \n  // Get the PUE trend for this siteRef and hisInterval\n  pue: read(siteRef==site and navName==pueNavName and hisInterval==hisInterval and pue and point)\n  \n  // Get Outside Air Wetbulb from wbRef\n  oaWB: read(equipRef==wbRef and wetBulb)\n  \n  //Get compute power for given comp filter\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n  \n  \n  // Interpolate, filter the pue\n  loopTrend: hisRead(pue,dates,{limit:null})\n                 .findAll(row => row.all(v => v != null))\n  // Renaming the columns directly, to generically rename them later based on equipRefs\n                 .renameCol(\"v0\", \"pue\")\n  if (isEmpty(loopTrend.hisClip)) return null\n  \n  oaWetBulb: hisRead(oaWB, dates, {limit:null})\n                  .renameCol(\"v0\",\"oaWB\")\n\n  powerFilter: hisRead(compPower, dates, {limit:null})\n  //Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))\n\n  //Add OA Wetbulb and filter to PUE\n  metric: hisJoin([oaWetBulb, loopTrend])\n            .hisFindInPeriods(powerFilter)\n            .addColMeta(\"oaWB\",\n              {chartType: \"scatter\",\n               dis: \"OAT WB\",\n               unit: \"_\", color: \"#000000\"})\n            .addColMeta(\"pue\",\n              {chartType: \"scatter\",\n               dis: pueNavName,\n               unit: \"_\", color: \"#3F51B5\",\n               chartGroup: \"all\"})\n            \n  metricScatter: metric.keepCols([\"oaWB\",\"pue\"])\n                       .addMeta({chartType: \"scatter\", \n                               title: \"NERSC PUE vs. Outside Air Wetbulb Temperature\"})\n  \n  return metricScatter\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuZoneDeltaTemps"],,,,M,,,,,,"viAhuZoneDeltaTemps",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, calculate the temperature deviation from zone temp\n  deadband for all TUs served by that AHU (using anAhuZoneDeltaTemps)\n  then display the result on a heat map\n    \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), maxDev: 5°F, rollup: 15min, zoneIdList:null, filterUnocc:true) => do\n  devs: anAhuZoneDeltaTemps(ahuRef, dates, maxDev, rollup, zoneIdList, filterUnocc)\n  \n  try do\n    devs= devs\n        .hisFlatten((val, ts, his) => \n               {ts: ts.format(\"WWW M/DD k\"+(if(rollup<60min) \":mm\" else \"\")+\"a\"),\n                rm: his->dis,\n                v0: val})\n        .reorderCols([\"ts\",\"rm\",\"v0\"])\n        .addColMeta(\"v0\", {unit:\"°F\",\n                           chartMin: maxDev * -1,\n                           chartMax: maxDev})\n        .addMeta({view: \"chart\", chartType:\"heatMap\",\n                  title: \"Deviation from deadband, zones served by \"\n                         +readById(ahuRef).dis(),\n                  colors: \"blue, palegreen, red\"})\n  catch (ex) do\n    devs= null\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualAverage",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  average value of all points which have a virtualRef equal\n  to the id of the virtual point\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap(x => if (x==null) na() else x)\n         .hisFoldCols(avg)\n         .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"calculateVirtualGasMeterUptime",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates history for a virtual meter point based on\n the meter formulas stored in the meterFormula tag in zinc format\n at the meter / equip level\n  \n Limitation: meter formula can only change at midnight local time\n Limitation: global adders LNC1 not properly managed for power vs energy\n  \n Arguments:\n restartDate (optional)   Date to rewrite history from. Must be\n                          a date, not a dateTime.\n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-06-20 //\n*/\n\n(restartDate:null, newOnly:true, interval:15min) => do\n  // Store today's date and points.\n  today: now().date\n  \n  filter: \"virtual and sensor and point \"\n        + \"and (uptime) \"\n        + \"and not hisFunc \"\n        + \"and equipRef->meter and equipRef->virtual \"\n        + \"and equipRef->meterFormula\"\n  if (newOnly) filter= filter+ \" and not hisEnd\"\n  query: parseFilter(filter)\n  \n  ptList: readAll(query)\n  \n  // Check if valid date\n  if (restartDate != null)\n    if (not(isDate(restartDate)) or restartDate > today) do\n      return {written: null, status: \"Invalid restartDate\"}\n    end\n  \n  // Cycle through each point:\n  ptList.each ptInList => do\n    hisEnd: ptInList[\"hisEnd\"]\n    /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    aregument). Assign dates, clear history, and/or assign\n    hisEnd based on which of the 4 cases is presented\n    (noHis/his and noInput/input) */\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input\n        hisClear(ptInList, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd.date..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Calculate.\n    // Determine point type (power or energy delta) and set filter tags and rollup function\n    if (ptInList.has(\"uptime\")) do\n      ptTags: \"uptime and equipRef->link\"\n    end\n    \n    // Load formulas from associated meter, sort so oldest formula comes first\n    formulas: ptInList->equipRef->meterFormula.ioReadZinc()\n                                         .toGrid()\n                                         .sort(\"startInclusive\")\n                                       \n    // Cycle through each formula, starting with the oldest and yield\n    // calculated values for requested dates on which a formula is valid\n    formulas.each formula => do\n    //formula: formulas[1]\n      // Latest formula will not have an end date,\n      // therefore if end date is missing, set end date to tomorrow\n      endExclusive: if (formula->endExclusive == \"\") today+1day\n                    else formula->endExclusive\n      \n      // Check if any of the requested dates fall within the formula's\n      // validity period; if not, skip to next formula\n      if (dates.start < endExclusive and dates.end >= formula->startInclusive) do\n\n        // Determine start and end dates of period for which history\n        // will be calculated using the current formula\n        startPeriod: [dates.start, formula->startInclusive].sort().last\n        endPeriod: [dates.end, endExclusive - 1day].sort().first\n        \n        // Create table of meters and multipliers from formula\n        meterOps: [0,1,2,3,4,5,6,7,8].toGrid.map((row, i) => do\n\n          // Check each meterX column, and parse it if not empty\n          if (formula[\"meter\"+i] != \"\") do\n\n            // Parse using regex\n            parsed: reGroups(\"\"\"(-?)(\\\\d{1,3}.\\\\d{1,2})\"\"\", formula[\"meter\"+i])\n            meterMult: if(parsed[1] == \"-\") -1 else 1\n            meterLink: parsed[2]\n\n            // Find point with the required tags that belongs to meter\n            // with the requested link tag\n            pointRec: parseFilter(ptTags)\n                      .readAll()\n                      .find ptInList => ptInList->equipRef->link == meterLink\n\n            // Store record to linked meter point, and corresponding multiplier\n            {meter: i, pointRec: pointRec, meterMult: meterMult}\n          end\n        end\n        )\n        // meterOps grid is complete, contains point records and multipliers\n        //return meterOps\n        // Get global adder and multiplier from formula, cast unit for adder\n        globalMult: formula->globalMult\n        globalAdder: formula->globalAdder.as(ptInList->unit)\n\n        // Create list of point records that are not null; we will need the\n        // histories from these points to calculate our virtual history\n        points: meterOps.colToList(\"pointRec\").findAll item => item != null\n        \n        // Load history for all required points, clip\n        histGrid: points.hisRead(startPeriod..endPeriod, {limit: null})\n                        .hisClip()\n\n        // For each loaded timestamp, perform calculation of virtual history\n        // point and yield result\n        resultGrid: histGrid.map row => do\n\n          // Apply multiplier of 1/(#meters) to each point, and sum them all up\n          activeMeters: meterOps.colToList(\"meterMult\")\n                                .findAll(v => v != null)\n                                .size\n          val: meterOps.colToList(\"meterMult\")\n                       .map((mult, i) => if(row[\"v\"+i] != null)\n                                           1 / activeMeters * row[\"v\"+i]\n                                         else\n                                           na()\n                           )\n                       .fold(sum)          \n\n          // Return resulting history point\n          {ts: row->ts, v0: val}\n        end\n        \n        // Filter out redundant data and NA (already in history)\n        filteredGrid: resultGrid.findAll(row => row->ts > hisEnd\n                                                and row->v0 != na())\n        // Write calculated data to history.\n        hisWrite(filteredGrid, ptInList)\n        return {written: filteredGrid.size, status: \"OK\"}\n      end\n    end\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74TU",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create terminal units\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b74/vav_equip.csv`)\n  \n  siteDis: \"74\"\n  siteId: read(site and dis==siteDis)->id\n  \n  file.each row => do\n    floorDis: row[\"floor\"]\n    locationDis: \"B74 Floor \" + floorDis    \n    locationId: read(location and siteRef==siteId and\n                  dis==locationDis)->id\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    zoneId: read(zone and locationRef==locationId\n                 and navName==roomDis)->id\n                 \n    vavNum: reGroups(\"74-VAV-(\\\\d\\\\d\\\\d)\",row[\"vav\"])[1]\n    vavDis: \"Supply VAV-\" + vavNum\n    ahuNum: reGroups(\"74-AC-(\\\\d\\\\d\\\\d)\",row[\"ahu\"])[1]\n    ahuId: read(siteRef==siteId and ahu and equip\n                and navName==\"AC-\"+ahuNum)->id\n        \n    uriText: row[\"bacnetAddress\"]\n    uri: parseUri(uriText)\n    connRef: read(conn and bacnetConn and uri==uri)->id\n    \n    exist: readAll(siteRef==siteId and \n                   locationRef==locationId and\n                   equip and supply and terminalUnit\n                   and equipRef==zoneId\n                   and navName==vavDis)\n    \n    // Hot water reheat check\n    hhwReheat: reFind(\"rht\",row[\"controlProg\"]) != null\n    \n    // Exhaust TU check\n    exhaust: reFind(\"ecv\",row[\"controlProg\"]) != null\n   \n    // Create supply TU \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: vavDis,\n         disMacro: \"\\\$equipRef \\\$navName\",\n         ahuRef: ahuId,\n         connRef: connRef,\n         supply,\n         terminalUnit,\n         equip,\n         hotWaterHeat: if(hhwReheat) marker() else null,\n         locationRef: locationId,\n         siteRef: siteId,\n         equipRef: zoneId,\n         tmp:today()\n        },\n        {add}\n      ))\n    end\n    \n    // Create exhaust TU\n    if (exhaust) do\n      exDis: \"Exhaust TU\"\n    \n      existE: readAll(siteRef==siteId and \n                      locationRef==locationId and\n                      equip and exhaust and terminalUnit\n                      and equipRef==zoneId\n                      and navName==exDis)\n                      \n      if (isEmpty(existE)) do\n        commit(diff(\n          null,\n          {navName: exDis,\n           disMacro: \"\\\$equipRef \\\$navName\",\n           equip,\n           equipRef: zoneId,\n           exhaust,\n           connRef: connRef,\n           terminalUnit,\n           locationRef: locationId,\n           siteRef: siteId,\n           tmp:today()\n          },\n          {add}\n        ))\n    end\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisGridShowGaps","gapExists","toolHisAlign","toolHisGridGapsPeriods","benchmarkDataLBT","benchmarkDataLBT_test"],,,,M,,,,,,"benchmarkDataLBT_test",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  //buildRef: @p:lbnl:r:22399b67-d9dcb8b7 // 30\n  //buildRef: @p:lbnl:r:21cd60fc-808d8404 // 33\n  buildRef: @p:lbnl:r:22c912f0-91f6badd // 74\n  //buildRef: @p:lbnl:r:225ffa71-7758e5e3 // 67\n  \n  maxGap:2day\n  \n  //locations: readAll(location and siteRef==building)\n  //location: locations[3]//locations.findAll(loc => \n  //dis: location[\"dis\"]\n  //bool: dis.contains(\"Utility\")\n  \n  //dates: date(2018,1,1)..date(2018,12,31)\n  dates: date(2018,1,1)..date(2018,1,31)\n  //dates: date(2019,1,1)..now().date\n  \n  //location: readAll(location and siteRef==buildRef).find(loc => loc[\"dis\"].contains(\"Utility\")==true)\n  //locRef: location[\"id\"]\n  //meter: readAll(equip and meter and virtual and elec and not submeterOf).find(met => met[\"locationRef\"]==locRef)\n  //metRef: meter[\"id\"]\n  //point: readAll(point and energy and hisSize and virtual and equipRef==metRef)\n  \n  //grid: point.hisRead(dates,{limit:null}).toolHisGridGapsPeriods(15min)\n  \n  //gaps: grid.map row => do\n  //  {gap: row[\"gap\"]}\n  //end\n  //existenceOfGaps: gaps.any row => row->gap==true\n  \n  //equip14: readAll(equip and ahu and not vfd and not virtual).findAll(equip => equip[\"siteRef\"]==buildRef)\n  //acs14: readAll(equip and not vfd and not virtual).findAll(equip => equip[\"navName\"].contains(\"AC-\") and equip[\"siteRef\"]==buildRef)\n  //equip14: addRows(ahus14,acs14)\n  //equipIdsList14: equip14.colToList(\"id\")\n  \n  //points14: readAll(point and his and discharge and air and flow and not virtual)\n            //.findAll(pt => equipIdsList14.contains(pt[\"equipRef\"]))\n  \n  //points14: equip14.map eq => do\n  //  point14: readAll(point and his and flow and not virtual)\n  //           .find(pt => pt[\"equipRef\"]==eq[\"id\"]\n  //                       and pt[\"navName\"].contains(\"Supply\"))\n  //end\n  \n  //airflowHis: points14.hisRead(dates,{limit:null})\n  //airflowHis= airflowHis.toolHisAlign\n  \n  // Find the max of all values in that column.\n    // First store the history in the variable airflowHis.\n    // Then find the max of that history and store it as met5_1.\n    // Finally, remove that max from airflowHis then find the next max.\n    // Repeat to find 3 maximums.\n    //airflowHis= airflowHis.hisFoldCols(sum)\n    //met14_1: airflowHis.foldCol(\"v0\",max)\n    //airflowHis= airflowHis.findAll(row => row->v0 != met14_1)\n    //met14_2: airflowHis.foldCol(\"v0\",max)\n    //airflowHis= airflowHis.findAll(row => row->v0 != met14_1 and row->v0 != met14_2)\n    //met14_3: airflowHis.foldCol(\"v0\",max)\n    //metrics14:[met14_1,met14_2,met14_3]\n    //metric14: metrics14.map m => do\n      //{max: m.to(\"cfm\")} // convert to kWh if not already kWh\n      //end\n  //metric14\n  \n  // to type into shell: benchmarkDataLBT_test().hisFindAll((v,ts,his)=>ts<dateTime(date(2018,01,07),time(0,0,0)))\n  \n  //////////////////////////////////////////\n  // 12. Cooling Plant Peak (kW)          //\n  //////////////////////////////////////////\n  \n  //    We did much of the work in (8).\n  //    Point12 will have almost all the same tags, but instead of energy\n  //    it will have power.\n  //equip12: equip8\n  \n  //if (not isEmpty(equip12)) do\n  //  equipIdsList12: equipIdsList8\n  //  points12: readAll(point and his and power and not accumulator)\n  //            .findAll(pt => equipIdsList12.contains(pt[\"equipRef\"]))\n  //  if (points12!=null and points12.hisRead(dates).size > 0) do\n      // Check if there is a significant data gap.\n  //    if (points12.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n  //      comment12: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n  //    end else do\n  //      comment12: \"No data significant gaps.\"\n  //    end\n      \n  //    coolPlantHisMax: points12.hisRead(dates,{limit:null})\n  //    coolPlantHisMax= coolPlantHisMax.toolHisAlign\n  //    coolPlantHisMax= coolPlantHisMax.hisFoldCols(sum)\n      \n      // Find the max of all values in that column.\n      // First store the history in the variable coolPlantHis.\n      // Then find the max of that history and store it as met12_1.\n      // Finally, remove that max from airflowHis then find the next max.\n      // Repeat to find 3 maximums.\n  //    met12_1: coolPlantHisMax.foldCol(\"v0\",max)\n  //    coolPlantHisMax= coolPlantHisMax.findAll(row => row->v0 != met12_1)\n  //    met12_2: coolPlantHisMax.foldCol(\"v0\",max)\n  //    coolPlantHisMax= coolPlantHisMax.findAll(row => row->v0 != met12_1 and row->v0 != met12_2)\n  //    met12_3: coolPlantHisMax.foldCol(\"v0\",max)\n  //    metrics12:[met12_1,met12_2,met12_3]\n  //    metric12: metrics12.map m => do\n  //      {max: m.to(\"kW\")} // convert to kW if not already kW\n  //      end\n  //    end else do\n  //      metric12: \"Insufficient Data\"\n  //      comment12: \"equip14 not null, but points14 is either null or has hisSize=0\"\n  //    end\n  //end else do\n  //  metric12: \"Insufficient Data\"\n  //  comment12: \"N/A\"\n  //end\n  \n  \n  //////////////////////////////////////////\n  // 8. Cooling Plant Elec (kWh)          //\n  //////////////////////////////////////////\n  \n  // THIS IS TOO INCLUSIVE (DOUBLE COUNTS ENERGY); INSTEAD USE\n  // THE SINGLE BTU METER\n  \n  //equip8: readAll(equip and meter and elec and submeterOf).findAll(equip => equip[\"siteRef\"]==buildRef and equip[\"navName\"].contains(\"HVAC\"))\n  \n  //if (not isEmpty(equip8)) do\n  //  equipIdsList8: equip8.colToList(\"id\")\n  //  points8: readAll(point and his and energy and virtual and not accumulator)\n  //            .findAll(pt => equipIdsList8.contains(pt[\"equipRef\"]))\n  //  if (points8!=null and points8.hisRead(dates).size > 2) do\n  //    // Check if there is a significant data gap.\n  //    if (points8.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n  //      comment8: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n  //    end else do\n  //      comment8: \"No data significant gaps.\"\n  //    end\n  //    \n  //    coolPlantHis: points8.hisRead(dates,{limit:null})\n  //    coolPlantHis= coolPlantHis.toolHisAlign\n  //    coolPlantHis= coolPlantHis.hisFoldCols(sum)\n  //    metric8: coolPlantHis.foldCol(\"v0\",sum)\n  //    metric8= metric8.to(\"kWh\") // convert to kWh if not already\n  //    end else do\n  //      metric8: \"Insufficient Data\"\n  //      comment8: \"equip8 not null, but points8 is either null or has hisSize=0\"\n  //    end\n  //end else do\n  //  metric8: \"Insufficient Data\"\n  //  comment8: \"N/A\"\n  //end\n  \n  //////////////////////////////////////////\n  // 16. Building Water (gal)             //\n  //////////////////////////////////////////\n  \n  //    Check if the water history is empty. If empty say\n  //    \"Insufficient Data.\" If not, sum the water hist\n  location16: readAll(location and siteRef==buildRef)\n               .find(loc => loc[\"dis\"].contains(\"Utility\")==true)\n  locRef16: location16[\"id\"]\n  meter16: readAll(equip and meter and water and not submeterOf)\n            .find(met => met[\"locationRef\"]==locRef16)\n  if (meter16!=null) do\n    metRef16: meter16[\"id\"]\n  end else do\n    metRef16: null\n  end\n  try\n    point16: read(point and volume and his and equipRef==metRef16 and not accumulator)\n    catch\n      point16: null\n  \n  if (point16!=null and point16.hisRead(dates).hisClip.size > 2) do\n    waterHis: point16.hisRead(dates, {limit:null}).hisClip.hisFoldCols(sum)\n    waterHisFiltered: waterHis.toolHisGridShowGaps(15min).findAll(row => row[\"v0\"]!=na())\n    waterHisFilteredRolled: waterHisFiltered.hisRollup(sum,1hr)\n    comment16: toStr(waterHisFilteredRolled.size)+\" hours of 8760 counted.\"\n    metric16: waterHisFilteredRolled.foldCol(\"v0\",sum).to(\"gal\")\n    \n  end else do\n    metric16: \"Insufficient Data\"\n    comment16: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 15. Peak Cooling Load (tons)         //\n  //////////////////////////////////////////\n  \n  meter15: null//read(equip and meter and load and siteRef->id==buildRef and siteMeter and not submeterOf)\n  if (meter15!=null) do\n    metRef15: meter15[\"id\"]\n  end else do\n    metRef15: null\n  end\n  if (metRef15!=null) do\n    point15: read(point and power and his and equipRef==metRef15)\n  end else do\n    point15: null\n  end\n  if (point15!=null and point15.hisRead(dates).hisClip.size > 2) do\n    // Check if there is a significant data gap.\n    if (point15.hisRead(dates,{limit:null}).gapExists(maxGap)) do\n      comment15: \"Gap greater than \" + toStr(maxGap) + \" in data.\"\n    end else do\n      comment15: \"No data significant gaps.\"\n    end\n    \n    coolLoadHis: point15.hisRead(dates,{limit:null})\n\n    // Find the max of all values in that column.\n    // First store the history in the variable coolLoadHis.\n    // Then find the max of that history and store it as met15_1.\n    // Finally, remove that max from coolLoadHis then find the next max.\n    // Repeat to find 3 maximums.\n    met15_1: coolLoadHis.foldCol(\"v0\",max).to(\"tonref\")\n    coolLoadHis= coolLoadHis.findAll(row => row->v0 != met15_1)\n    met15_2: coolLoadHis.foldCol(\"v0\",max).to(\"tonref\")\n    coolLoadHis= coolLoadHis.findAll(row => row->v0 != met15_1 and row->v0 != met15_2)\n    met15_3: coolLoadHis.foldCol(\"v0\",max).to(\"tonref\")\n    metric15:[met15_1,met15_2,met15_3]\n    \n  end else do\n    metric15: \"Insufficient Data\"\n    comment15: \"N/A\"\n  end\n  \n  //////////////////////////////////////////\n  // 7. Ventilation Elec (kWh)            //\n  //////////////////////////////////////////\n  \n  equip7: readAll(fan and (equipRef->ahu or equipRef->exhaustSystem))\n                  .findAll(eq => eq[\"siteRef\"]==buildRef)\n  \n  if (not isEmpty(equip7)) do\n    equipIdsList7: equip7.colToList(\"id\")\n    points7: readAll(point and his and power)\n                    .findAll(pt => equipIdsList7.contains(pt[\"equipRef\"]))\n    //colNames7: points7.colToList(\"id\")\n    if (not isEmpty(points7) and points7.hisRead(dates).hisClip.size > 2) do\n      try do\n        ventPowerHis: points7.hisRead(dates,{limit:null}).hisClip\n        ventPowerHisFiltered: ventPowerHis.toolHisAlign             // for use in (11)\n        ventPowerHisFiltered= ventPowerHisFiltered.hisFoldCols(sum) // for use in (11)\n        ventPowerHisRoll: ventPowerHis.hisRollup(sum,1hr)\n        ventPowerHisRollFiltered: ventPowerHisRoll.toolHisAlign\n        ventPowerHisRollFiltered= ventPowerHisRollFiltered.hisFoldCols(sum)\n        comment7: toStr(ventPowerHisRollFiltered.size)+\" hours of \"+toStr(ventPowerHisRoll.size)+\" counted.\"\n        metric7: ventPowerHisFiltered.toolHisGridShowGaps(15min)\n                                     .hisRollup(avg,1hr)\n                                     .foldCol(\"v0\",sum).as(\"kWh\")\n        if (points7.size!=equip7.size) comment7= \"Point list size does not match equipment list size. \"+comment7\n        if (metric7==null) metric7= \"Some points empty.\"\n        end catch do\n          comment7: \"Probably an NA in His\"\n          metric7: \"Insufficient Data\"\n        end\n    end else do\n      metric7: \"Insufficent Data\"\n      comment7: \"No points\"\n    end\n  end else do\n    metric7: \"Insufficient Data\"\n    comment7: \"N/A\"\n  end\n  \n  metric7\n  \n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viTWCWSysOperations",,,"/*\n  Copyright 2020 Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  find the control points related to CT Fan Power,\n  CW Pump Power, and TW Pump Power\n  \n  find OA Wetbulb for the same time period\n  \n  Return history grid ready for display on a graph\n    \n  Arguments: \n  equipRef         Ref for system equip for which we want to calculate\n                   the metric\n  dates            Span of dates we want to calculate the metric on\n*/\n\n(bldgRef:null, dates: today, rollup: 5min) => do\n  // Default to B59 if no ref is provided\n  if(bldgRef==null)\n    bldgRef= read(site and dis==\"59\")\n    \n  bldgRefId: bldgRef->id\n    \n  // Get the reference for the TW and CW Plants\n  cwPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and treatedWaterPlant\n                    and navName == \"Plant\")\n  \n  \n  twPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and condenserWaterPlant\n                    and navName == \"Plant\")\n  \n  \n  // Get the power points for the TW pumps, CT Fans, and CW Pumps\n  twPumpSP: read(equipRef==cwPlantEquip->id\n                    and temp\n                    and leaving\n                    and water\n                    and sp)\n                    \n  twPump: read(equipRef==cwPlantEquip->id\n                    and temp\n                    and leaving\n                    and water\n                    and sensor)\n  \n  ctFanSP: read(equipRef==twPlantEquip->id\n                    and temp\n                    and water\n                    and sp)\n                    \n  ctFan: read(equipRef==twPlantEquip->id\n                    and temp\n                    and water\n                    and sensor)\n  \n  cwPumpSP: read(equipRef==cwPlantEquip->id\n                    and pressure\n                    and water\n                    and sp)\n\n  cwPump: read(equipRef==cwPlantEquip->id\n                    and pressure\n                    and water\n                    and sensor)\n                    \n   // Graph the setpoint and sensor point for each system, TW Pumps, CT Fans, and CW Pumps\n   twPumpCtrlSP: hisRead(twPumpSP, dates, {limit:null})\n                   .renameCol(\"v0\",\"cwTempSP\")\n                   .hisRollup(avg, rollup)\n \n   twPumpCtrl: hisRead(twPump, dates, {limit:null})\n                   .renameCol(\"v0\",\"cwTemp\")\n                   .hisRollup(avg, rollup)\n                   \n   ctFanCtrlSP: hisRead(ctFanSP, dates, {limit:null}) \n                   .renameCol(\"v0\",\"twTempSP\")\n                   .hisRollup(avg, rollup)\n\n   ctFanCtrl: hisRead(ctFan, dates, {limit:null}) \n                   .renameCol(\"v0\",\"twTemp\")\n                   .hisRollup(avg, rollup)\n                   \n   cwPumpCtrlSP: hisRead(cwPumpSP, dates, {limit:null})\n                   .renameCol(\"v0\",\"dpSP\")\n                   .hisRollup(avg, rollup)\n\n   cwPumpCtrl: hisRead(cwPump, dates, {limit:null})\n                   .renameCol(\"v0\",\"dp\")\n                   .hisRollup(avg, rollup)\n\n   combined: hisJoin([twPumpCtrl, twPumpCtrlSP, ctFanCtrl, ctFanCtrlSP, cwPumpCtrl, cwPumpCtrlSP])\n                    .addColMeta(\"cwTempSP\",\n                      {dis: \"CW Temp Setpoint\",\n                       color: \"#9370DB\",\n                       chartGroup: \"all\"})\n                    .addColMeta(\"cwTemp\",\n                      {dis: \"CW Temperature\",\n                       color: \"#4B0082\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"twTempSP\",\n                      {dis: \"TW Temp Setpoint\",\n                       color: \"#FFA500\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"twTemp\",\n                      {dis: \"TW Temperature\",\n                       color: \"#FF8C00\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"dpSP\",\n                      {dis: \"CW DP Setpoint\",\n                       color: \"#32CD32\",\n                      chartGroup: \"all\"})\n                    .addColMeta(\"dp\",\n                      {dis: \"CW Differential Pressure\",\n                       color: \"#008000\",\n                      chartGroup: \"all\"})\n  return combined\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"googleCalRead",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function queries room booking information through \n  local server for specific timeframe from LBNL Google Calendar,\n  deletes old saved data for that range, and write schedule \n  information in boolean form.\n  \n  Arguments: \n  point        LBNL conference room available for scheduling with point->calendarID variable\n  start_date   dateTime object specifying start of ranged query\n  end_date     dateTime object specifying end of ranged query\n  \n  // LBNL // JBR // Last Update: 2019-02-19 //\n*/\n\n(point, start_date, end_date) => do\n  \n  link: readById(point->id)\n  \n  uri: point->calendarID.toStr() +\"?\"+start_date+\"?\"+end_date+\"?calendar\"\n  \n  // Local Python server is running on port 9000\n  query: \"http://128.3.66.91:9000/?\"+uri\n \n  // Call ioReadJson to Python server for middleman request\n  // Parse returned timeseries string into JSON format\n  data: ioReadJson(``+query)\n  \n  // Iterate on rows, parse and store data\n  result_list: []\n  data[\"value\"].map row => do\n    datum_list: row[1]\n    time_list: row[0]\n    time_list = parseDateTime(time_list+\" Los_Angeles\", \"YYYY-MM-DD hh:mm:ss\", \"Los_Angeles\")\n    result_list = result_list.add({ts: time_list, val: datum_list})\n  end\n  \n  // Convert dates to dateTime and make into DateSpan\n  start_time: start_date.parseDateTime(\"MM/DD/YYYY hh:mm:ss\")\n  end_time: end_date.parseDateTime(\"MM/DD/YYYY hh:mm:ss\")\n  time_span: toDateSpan(start_time..end_time)\n  \n  // Delete old history for given timespan\n  link.hisRemove(time_span)\n  \n  // Write new data to point\n  result_grid: result_list.toGrid\n  hisWrite(result_grid, link)\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptAccumulatorToDelta_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates deltas between accumulator points, and\n assigns the delta 'forward', i.e. delta1 = (acc1 - acc0) at ts1\n \n Virtual point (delta) needs to reference the source point\n (accumulator) as a pointRef.\n  \n Arguments:\n rec           Virtual point record or ID\n dates         Dates to calculate deltas for\n maxGap        Number (time) maximum length of allowed gaps, beyond\n               which N/A value is used\n*/\n\n(rec, dates, maxGap:null) => do\n  // Allow for rec to be a record ID\n  if(isRef(rec)) rec= readById(rec)\n  if (not(rec.has(\"pointRef\"))) return null\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viCopiesBacnetHis",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  bacnetConnRef + bacnetHis combinations are unique, and there should\n  only be one point per such combination. This function finds duplicates,\n  which typically reflect a typo or error during the point creation.\n  Return grid with:\n    id:            point id, for all points with duplicate combinations\n    bacnetConnRef: ref \n    bacnetHis:     text\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  all: readAll(point and bacnetHis and bacnetConnRef)\n  \n  dups: all.findAll(pt =>\n      read(point and bacnetHis == pt->bacnetHis\n           and bacnetConnRef == pt->bacnetConnRef\n           and id != pt->id, false) != null)\n              \n  if (isEmpty(dups))\n    dups= {success: \"No duplicate bacnetConnRef + bacnetHis\"}\n          .toGrid\n  else          \n    dups= dups.map(pt => {id: pt->id,\n                          bacnetConnRef: pt->bacnetConnRef,\n                          bacnetHis: pt->bacnetHis,                        \n                         })\n  \n  return dups\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d6b396-41ed943b "dbHealth",
,["toolFormatTrends"],,,,M,,,,,,"recNewToolFormatTrendsOptions",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(toolFormatTrendsOptionsDict) => do\n  // Normalize action input\n  toolFormatTrendsOptionsDict= actionNormInput(toolFormatTrendsOptionsDict, \"dict\")\n  \n  toolFormatTrendsOptionsDict= toolFormatTrendsOptionsDict\n  .set(\"username\", userCur()->username)\n\n  // If existing record, edit\n  exRec: read(toolFormatTrendsOptions and username==userCur()->username,\n              false)\n  if (exRec != null)\n    commit(diff(exRec, toolFormatTrendsOptionsDict))\n  else \n    commit(diff(null, toolFormatTrendsOptionsDict, {add}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"syncALCSecondary",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Backfill ALC point data starting from 10 days ago\n  and ending either now OR first successful write of\n  data that was pulled via Raph's function. Then recursively\n  calls function to backfill from 10 days ago from previous\n  hisStart so as to avoid data bottlenecking. Function will\n  return either when 2 years have been reached or no more past\n  history data is detected.\n  \n  Arguments: \n  point    ALC Device point with point->alcPath variable\n  \n  // LBNL // JBR // Last Update: 2019-02-01 //\n*/\n\n(point) => do\n\nfirst_write: (point_again, previous_start) => do\n  // If no historical data available, then backfill data from 10 days to now\n  if(point_again[\"hisStart\"] == null) do\n    start_date: now() - 10day // Start query 10 days ago (to avoid any buffer issues)\n    end_date: now()\n    end\n    \n  // Else backfill from 10 days to first successful write date\n  else do\n    start_date: point_again->hisStart  - 10day\n    end_date: point_again->hisStart // End query at history start of trusted data\n    end\n  \n  // Return if reached 2 years from now\n  if(start_date < (now() -2year))\n    return 1\n  // Return if no more data is available past previous history call\n  if(previous_start == start_date)\n    return 1\n  \n  // Set link number to appropriate id for hisWrite\n  link: readById(point_again->id)\n  \n  // Format datetime strings\n  start_string: start_date.format(\"YYYY-MM-DD kk:mm:ss aa\")\n  end_string: end_date.format(\"YYYY-MM-DD kk:mm:ss aa\")\n  \n  // Construct URI from alcPath and previous history timestamps.\n  uri: point_again->alcPath.toStr() + \"?\" + start_string + \"?\" + end_string + \"?alc\"\n \n  // Local Python server is running on port 9000\n  query: \"http://localhost:9000/?\"+uri\n  \n  // Call ioReadJson to Python server for middleman request\n  // Parse returned timeseries string into JSON format\n  data: ioReadJson(``+query)\n\n  resultList: []\n  // Iterate on rows, parse and store/write data\n  data[\"value\"].map row => do\n    datum_list: row[1]\n    time_list: row[0]\n    time_list = parseDateTime(time_list+\" Los_Angeles\", \"YYYY-MM-DD hh:mm:ss\", \"Los_Angeles\")\n    resultList = resultList.add({ts: time_list, val: datum_list})\n  end\n  \n  resultGrid: resultList.toGrid\n  // Will filter out all data AFTER hisEnd\n  filteredGrid: resultGrid.findAll(row => row->ts < end_date - 1s)\n  // Write data BETWEEN hisEnd and hisStart\n  hisWrite(filteredGrid, link)\n  \n  previous_start = start_date\n  hisSync() // block until all writes are complete\n  point_again = readById(point_again->id)\n  first_write(point_again, previous_start)\n  \nend // end first_write\n\nfirst_write(point, null)\n\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["dataQualityToBool","meterFormulaLinks","viMeterFormula"],,,,M,,,,,,"viMeterQuality_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given meterRef, and a given span (optional), return a\n  timeline of data validity.\n  \n  Arguments: \n  meterRef        Target id\n  span            Datespan (optional)\n*/\n\n(meterRef, span:null) => do\n  // Force span to datespan\n  span= span.toDateSpan\n  \n  // If meter has associated dataQuality records, they take\n  // precedence over other source of data\n  qualityRecs: readAll(dataQuality and meterRef==meterRef)\n  if (not(isEmpty(qualityRecs))) do\n    grid: dataQualityToBool(meterRef, span)\n    if (grid==null or isEmpty(grid)) return null\n    else grid= grid.renameCol(\"v0\",\"validity\")\n  end else do\n    // Otherwise, check if it is a meter with formula\n    // In this case, a span is required\n    formulas: viMeterFormula(meterRef)\n    if (formulas==null or span==null) return null\n    \n    // Cycle through formulas and compute validity grid\n    grid: {}.toGrid()\n    formulas.each formula => do\n      // Find start and end dates associated with formula\n      fStart: try formula->startInclusive\n              catch return null\n      fEnd: if(formula[\"endExclusive\"]==null\n               or formula[\"endExclusive\"]==\"\") today()\n            else formula[\"endExclusive\"] - 1day\n      \n      // If there is no overlap with 'span', skip formula\n      if (span.start >= fEnd) return null\n      if (span.end < fStart) return null\n    \n      // Create datespan associated with formula\n      // and overlapping 'span'\n      sStart: if (span.start > fStart) span.start\n              else fStart\n      sEnd: if (span.end < fEnd) span.end\n            else fEnd\n      sSpan: (sStart..sEnd).toDateSpan()\n      \n      // Obtain validity for each meter used in formula,\n      // and combine\n      fGrid: {}.toGrid()\n      missingLinkFlag: false\n      formula.meterFormulaLinks.each((link, i) => do\n        linkRec: read(meter and link==link, false)\n        if (linkRec==null) do\n          missingLinkFlag= true\n          return null\n        end\n        \n        dQ: dataQualityToBool(linkRec->id, sSpan)\n        if (dQ==null) do\n          missingLinkFlag= true\n          return null\n        end\n        dQ= dQ.renameCol(\"v0\",\"v\"+i)\n         \n        if (isEmpty(fGrid)) fGrid= dQ\n        else fGrid= join(fGrid, dQ, \"ts\")\n      end)\n      \n      // Compute resulting validity\n      if (missingLinkFlag)\n        fGrid= fGrid.addCol(\"validity\", row => false)\n      else\n        fGrid= fGrid.addCol(\"validity\",\n                            row => row.remove(\"ts\").all(v=>v))\n      \n      if (not(isEmpty(fGrid)))\n        grid= grid.addRows(fGrid)\n    end\n  end\n  \n  if (isEmpty(grid)) return grid\n  \n  // Convert dates to datetimes and format chart\n  chart: grid\n         .map(row => {ts: dateTime(row->ts,time(0,0,0)),\n                      validity: row->validity})\n         .addMeta({view:\"chart\"})\n         .addColMeta(\"validity\",\n                     {dis: readById(meterRef).dis\n                           + \" - Validated Data\",\n                      spark,\n                      color:\"#009933\"})\n  \n  chart= chart.addMeta({hisStart: chart[0]->ts,\n                        hisEnd: chart[-1]->ts,\n                        chartNoScroll})\n              .addColMeta(\"ts\", {format: \"MMM-YYYY\"})\n  \n  return chart\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolRecursiveSearch"],,,,M,,,,,,"anAhuAirflowsCompare",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Compare sum of supply zone airflows to sum of AHU supply fan airflows.\n  Return null if either are unavailable. Safe rollup using toolHisAlign.\n \n  Arguments: \n  ahuRef     id of ahu to analyze\n  span       dates to analyze\n*/\n\n(ahuRef, span, minRollup:0min) => do\n  ahuId: if (isRef(ahuRef)) ahuRef else ahuRef->id\n  try grid: hisJoin([\n    readAll(air and flow and sensor and equipRef->ahuRef==ahuId)\n      .hisRead(span, {limit:null})\n      .toolHisAlign(avg,       // rollupFunc\n                    min,       // intervalFunc\n                    true,      // removeMissing\n                    minRollup) // minRollup\n      .hisFoldCols(sum)\n      .addColMeta(\"v0\",{dis:\"Sum of Zone Airflows\"}),\n    toolRecursiveSearch(ahuRef,\n                        \"air and flow and sensor and (discharge or equipRef->discharge)\")\n      .hisRead(span, {limit:null})\n      .toolHisAlign(avg,       // rollupFunc\n                    min,       // intervalFunc\n                    true,      // removeMissing\n                    minRollup) // minRollup)\n      .hisFoldCols(sum)\n      .addColMeta(\"v0\",{dis:\"Sum of Supply Fan Airflows\"})])\n  catch return null\n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,"Use MesoWest REST API to import weather data, then parse and write to weatherPoint histories. Can be used for initial import if providing init_start_date or for ongoing imports. TODO: make more generic by linking column names to tags instead of linking to refs; \t\t\t\tmake station name an input.",,M,,M,"syncWeatherLBNL1",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function is used to synchronize recent history of LBNL\n weather station on a regular basis. Intended to run as recurring job.\n \n parseFloat is used by default on all values, script will need to be\n modified if importing strings or other types.\n \n Arguments:\n init_start_date (optional)    date to start sync on\n \n Notes:\n For this function to be used with another weather station,\n new weatherPoints must be created and linked inside the function\n*/\n\n(init_start_date: null) => do\n  // Determine the last datetime at which all weatherPoints\n  //   associated with LBNL station have history records\n  if (init_start_date == null) do\n    earliest_his_end: readAll(weatherPoint and not hisFunc and not virtual\n                              and weatherRef->id==@p:lbnl:r:2194df1f-ebd11fde)\n                      .colToList(\"hisEnd\").sort()[0]\n    start_datetime: earliest_his_end + 1min   // Add 1min in order not to read same record again\n  end else if (isDate(init_start_date)) do\n    start_datetime: dateTime(init_start_date, 00:00)\n  end else return null\n\n    // Set parameters: csv column names of interest, converted to legal tag names,\n  //   and associated weather points of interest, by id\n  datetime_t: toTagName(\"Date_Time\")\n  pt_list: [\n    {tagName: toTagName(\"air_temp_set_1\"), link: readById(@p:lbnl:r:21954442-d84f76af)},\n    {tagName: toTagName(\"air_temp_set_2\"), link: readById(@p:lbnl:r:2194e058-3f3ac56d)},\n    {tagName: toTagName(\"pressure_set_1\"), link: readById(@p:lbnl:r:21954521-a510f570)},\n    {tagName: toTagName(\"relative_humidity_set_1\"), link: readById(@p:lbnl:r:219543f4-55d8f4c0)},\n    {tagName: toTagName(\"dew_point_temperature_set_1d\"), link: readById(@p:lbnl:r:2195488b-f8b89630)},\n    {tagName: toTagName(\"wind_speed_set_1\"), link: readById(@p:lbnl:r:2195460a-3039caf5)},\n    {tagName: toTagName(\"wind_gust_set_1\"), link: readById(@p:lbnl:r:21954730-b9e48c6e)},\n    {tagName: toTagName(\"wind_direction_set_1\"), link: readById(@p:lbnl:r:219546a6-a3325fb6)},\n    {tagName: toTagName(\"precip_accum_fifteen_minute_set_1\"), link: readById(@p:lbnl:r:219547ab-f705db2e)},\n    {tagName: toTagName(\"solar_radiation_set_1\"), link: readById(@p:lbnl:r:21954364-2304a444)}\n  ]\n  \n  // Prepare query\n  start_string: start_datetime.toTimeZone(\"UTC\").format(\"YYYYMMDDhhmm\") // Start query at last record\n  end_string: now().toTimeZone(\"UTC\").format(\"YYYYMMDDhhmm\")            // End query now\n  q_base: \"\"\"https://api.mesowest.net/v2/stations/timeseries?\"\"\"\n  q_station: \"\"\"stid=LBNL1\"\"\"\n  q_start: \"\"\"&start=\"\"\" + start_string\n  q_end: \"\"\"&end=\"\"\" + end_string\n  q_token: \"\"\"&token=ad9d3c454bfc41df91c40d7f8ea6acdd\"\"\"\n  q_output: \"\"\"&output=csv\"\"\"\n  q_units: \"\"\"&units=temp|F,speed|mph,pres|mb,precip|in,ENGLISH\"\"\"\n  q_tz: \"\"\"&obtimezone=local\"\"\"\n  query: q_base + q_station + q_start + q_end + q_token + q_output + q_units + q_tz\n  \n  // Execute query\n  raw: ioReadLines(``+query)\n\n  // Headers are in line 7 (index 6)\n  h_str: raw[6]\n  h_list: h_str.split(\",\")\n  h_list_safe: h_list.map(str => toTagName(str))\n\n  // Iterate on remaining rows, parse and store data\n  raw[8..-1].each line => do\n    v_list: line.split(\",\")\n    rec_dict: {}\n    v_list.each((rec, i) => rec_dict = rec_dict.set(h_list_safe[i],v_list[i]))\n    // Parse date and time: adding Los_Angeles to end of string to properly recognize \"2017-11-05T01:00:00-08:00\" as PST\n    rec_dict = rec_dict.set(datetime_t,\n                            parseDateTime(rec_dict[datetime_t]+\" Los_Angeles\", \"YYYY-MM-DDThh:mm:SSz zzzz\", \"Los_Angeles\"))\n    \n    // Iterate through list of points of interest and write records if value is available\n    pt_list.each pt => do\n      pt_val: parseFloat(rec_dict[pt[\"tagName\"]], checked: false)\n      if (pt_val != null) do\n        // Only write new values that are more recent than latest stored value\n        if (rec_dict[datetime_t] > (pt[\"link\"])->hisEnd) do\n          {ts: rec_dict[datetime_t], val: pt_val}.hisWrite(pt[\"link\"])\n        end\n      end\n    end\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolGridProfiles"],,,,M,,,,,,"viMeterBreakdown",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display a stacked bar chart showing the breakdown of energy usage\n  for a given meter into the usage of its submeters. Data can be rollep\n  up into average / min / max profiles.\n\n  Arguments: \n  meterRef\n  span\n  rollup\n  daytype\n  stacked\n*/\n\n(meterRef:read(siteMeter and elec and meter and siteRef->dis==\"30\")->id,\n span:pastMonth(), rollup:\"Weekly\", stacked: \"Stacked\") => do\n  span= span.toDateSpan\n  \n  // Modify span for weekly display if needed\n  if (rollup==\"Weekly\") do\n    // Align start on previous Sunday, except if span.start is Sunday\n    sStart: span.start - weekday(span.start)\n    \n    // Align end on following Saturday, except is span.end is Saturday\n    sEnd: span.end + 6day - weekday(span.end)\n    if (sEnd > today()) sEnd= sEnd - 7day\n    if (sEnd < sStart) return {empty: \"Span does not include a full week\"}\n                              .toGrid()\n    \n    // New aligned span\n    span= sStart..sEnd\n  end\n  \n  // Determine best date format\n  if (rollup==\"Monthly\") sFormat: \"MMM\"\n  if (rollup==\"Hourly\") sFormat: \"WWW kaa\"\n  else sFormat: \"MMM D\"\n  \n  // Determine display unit\n  dUnit: if (readById(meterRef).has(\"elec\")) \"kWh\"\n         else if (readById(meterRef).has(\"gas\")) \"therm\"\n         else return null\n  \n  // If displaying duplicate dates (more than a year), add year to format\n  if ((span.start.format(\"MM-DD\")+\"-2000\").parseDate(\"MM-DD-YYYY\")\n      + (span.end - span.start + 1day)\n      > 2000-12-31)\n    sFormat= sFormat+\" ''YY\"\n\n  filterStr: \"energy and delta and not hidden\"\n             + \" and (equipRef==@\" + meterRef\n             + \" or equipRef->submeterOf==@\" + meterRef + \")\"\n  energyPts: readAll(parseFilter(filterStr))\n  if (isEmpty(energyPts))\n      return {empty: \"No data\"}\n             .toGrid()\n             \n  grid: energyPts\n  .hisRead(span, {limit:null})\n  .hisClip()\n  \n  // Find meter energy use and move to first column\n  energyColNames: grid.colNames.findAll(v => v != \"ts\")\n  meterEnergy: energyColNames.find(v => grid.col(v).meta->equipRef==meterRef, false)\n  if (meterEnergy==null) return {empty: \"No meter data\"}.toGrid() \n  energyColNames= energyColNames.moveTo(meterEnergy, 0)\n  grid= grid.reorderCols(energyColNames.insert(0,\"ts\"))\n  \n  // Format for trend index\n  iFormat: if (energyColNames.size > 9) \"00\" else \"0\"\n  \n  // Organize data for display\n  grid= grid.hisMap(v => if (v!=null and v!=na()) v.to(dUnit) else v)\n  energyColNames.each((v,i) => do\n    grid= grid.addColMeta(v,\n      {dis: i.format(iFormat) + \" \"\n            + readById(grid.col(v).meta->equipRef)->navName,\n       strokeWidth:2,\n       chartGroup:\"submeters\"})\n  end)\n  \n  title: readById(grid.col(meterEnergy).meta->equipRef).dis()\n         + \" Submeter Energy Breakdown\"\n  \n  // Determine rollupPeriod\n  rollupPeriod: if(rollup==\"Monthly\") 1mo\n                else if(rollup==\"Weekly\") 1wk\n                else if(rollup==\"Daily\") 1day\n                else 1hr\n  \n  // Add error or unmetered column\n  grid= grid\n  .toolHisAlign(sum, min, false, rollupPeriod, [rollupPeriod])\n  //.hisMap((v,ts,his) => if (v==na()) 0.to(if(his.has(\"unit\")) his->unit else 1) else v)\n  .addCol(\"error\", row => do\n    valsDict: row.remove(\"ts\").map(v => if(v==null or v==na()) 0 else v)\n    reference: valsDict[meterEnergy]\n    submetered: valsDict.remove(meterEnergy).vals.fold(sum)\n    // Force NA as error only if all submetered values are NA\n    // (helps force display on same axis)\n    if (row.remove(\"ts\").remove(meterEnergy).vals.all(v=>v==na()))\n      return na()\n    else return reference - submetered\n  end)\n  \n  grid= grid\n  .addColMeta(\"error\", {dis:energyColNames.size.format(iFormat)\n                            +\" Unmetered or Error\",\n                        color:\"grey\",strokeWidth:2,\n                        unit:dUnit,\n                        chartGroup:\"submeters\"})\n  \n  if ([\"Weekly Avg\",\"Weekly Min\",\"Weekly Max\"].contains(rollup)) do\n    rollupFunc: sum\n    profileFunc: if (rollup==\"Weekly Avg\") avg\n                 else if (rollup==\"Weekly Min\") min\n                 else max\n    grid= grid\n    .toolGridProfiles(\"Weekly\", 1hr, rollupFunc, profileFunc, v => v!=na())\n    .removeCols([meterEnergy])\n  end else \n    grid= grid\n    .addCol(\"ts2\",row => row->ts.format(sFormat))\n    .removeCol(\"ts\")\n    .renameCol(\"ts2\",\"ts\")\n  \n  grid= grid\n  .reorderCols(grid.colNames.moveTo(\"ts\",0))\n  .removeCols([meterEnergy])\n  .addMeta({chartType: if(stacked==\"Stacked\") \"stackedBar\" else \"line\",\n            title: title})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"scrapeMetasysBacnetConn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function scrapes points from a metasys BACnet connector, and imports\n them, untagged and without relationships, into SkySpark. equips are created\n as needed based on the contents of the BACnet \"dis\" of each point.\n \n \"dis\" is expected to be structured as follows:\n root.loc.equip.point\n e.g.: Metasys-nie1/LBNL_FMS.NC64.64_133.ZAT\n \n Arguments:\n locationRef  Location where to add new equips and points\n connRef      Connector to scrape from, must be BACnet metasys\n locMatch     String, any point whose dis contains this string will be imported\n objectTypes  List of integers, BACnet point types to import, default [0,1,2,3,4,5]\n*/\n\n(locationRef, connRef, locMatch, objectTypes: [0,1,2,3,4,5]) => do\n  // Initialize parameters\n  siteRef: readById(locationRef)->siteRef\n\n  // Cycle through all object types and load list of available BACnet objects\n  objectTypes.each obj => do\n  \n    // Perform a top-level bacnetLearn to reset, and store list\n    //  of available object types\n    availableList: bacnetLearn(connRef).colToList(\"learn\")\n    \n    // Skip obj if not in top-level bacnetLearn list\n    if (not availableList.contains(obj)) return null\n    \n    // Perform match on \"dis\"\n    bacnetList: bacnetLearn(connRef, obj)\n                .findAll(row => row[\"dis\"].contains(locMatch))\n                  \n    // Cycle through list of all BACnet objects that have matching dis\n    //  and create equips and points with available info\n    bacnetList.each item => do\n      parsedDis: item->dis.split(\".\")\n      \n      // Skip point if dis does not conform to expected format\n      if (parsedDis.size != 4) return null\n      \n      equipDis: parsedDis[2]\n      ptDis: parsedDis[3]\n      \n      // Create equip if not already present in location\n      existingEquips: readAll(equip and locationRef==locationRef)\n      equipsList: if (isEmpty(existingEquips)) []\n                  else existingEquips.colToList(\"navName\")\n      if (not equipsList.contains(equipDis)) do\n        equipDict: {navName: equipDis,\n                   disMacro: \"\\\$locationRef \\\$navName\",\n                   equip,\n                   locationRef: locationRef,\n                   siteRef: siteRef,\n                   untagged}\n        commit(diff(null, equipDict, {add}))\n      end // if (not equipsList.contains(equipDis))\n      \n      // Get equipRef of equip to add point under\n      equipRef: read(equip and locationRef==locationRef\n                     and navName==equipDis)->id\n                     \n      // Create point if not already present in location / equip\n      existingPts: readAll(point and locationRef==locationRef\n                   and equipRef==equipRef)\n      pointsList: if (isEmpty(existingPts)) []\n                  else existingPts.colToList(\"navName\")\n      if (pointsList.contains(ptDis)) return null\n      if (item.has(\"bacnetDesc\")) navName: item->bacnetDesc\n      else navName: ptDis\n      ptDict: {navName: navName,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connRef,\n               bacnetCur: item->bacnetCur,\n               bacnetName: item->dis,\n               connRef: connRef,\n               enum: item[\"enum\"],\n               equipRef: equipRef,\n               his,\n               hisCollectInterval: 15min,\n               kind: item[\"kind\"],\n               locationRef: locationRef,\n               point,\n               sensor,\n               siteRef: siteRef,\n               tz: \"Los_Angeles\",\n               unit: item[\"unit\"],\n               untagged}\n      \n      commit(diff(null, ptDict, {add}))\n    end // bacnetList.each\n  end // objectTypes.each\nend // main\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["anAhuDuctGain","anZoneEnabled"],,,,M,,,,,,"ruReheatLeak",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns a grid of periods an equip has a leaky reheat valve\n  or a miscalibrated discharge air temp sensor. Based on a given threshold,\n  default 5°F, above AHU SAT + estimated duct gain.\n  \n  Arguments:\n  equip           equip record of equip to test\n  span            dateSpan, span of dates to run analysis on\n  threshold       number in °F, allowed temp differential between measured\n                  discharge air temp and estimated entering air temp\n  rhDelay         allowed time delay for residual heat to leave heat coil\n  minTime         duration, filter out periods shorter than minTime\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n  zoneEnabledOnly Bool, if true filter out periods when anZoneEnabled\n                  period is False / Off\n  enMinAirflowSp  Minimum airlfow setpoint to consider zone controls are\n                  enabled. Critical for this rule, because DAT can be high\n                  due to stratification when supply airflow is low.\n*/\n\n(equip:readById(@p:lbnl:r:2324cceb-e30a4c1a), span:pastWeek(),\n threshold: 5°F, rhDelay: 90min, minTime: 30min, mergePeriod: 15min,\n zoneEnabledOnly:true, enMinAirflowSp: 50cfm) => do\n  // Params: syncDelay allows buffer in case reheat valve position\n  // is trended at 15min and DAT is trended at 5min\n  syncDelay: 15min\n  \n  dat: read(discharge and air and temp and sensor and equipRef==equip->id,\n            false)\n  rh: read(heat and valve and cmd and equipRef==equip->id, false)\n    \n  // Retrieve occupied command if occOnly is true\n  zone: if(equip.has(\"zone\")) equip\n        else if(equip.has(\"equipRef\")) readById(equip->equipRef)\n        else null\n  zoneEn: if (zone!= null and zoneEnabledOnly)\n            anZoneEnabled(zone->id, span, enMinAirflowSp)\n          else null\n  \n  // If DAT is missing, return null\n  if (dat==null) return null\n  \n  // If terminal unit has reheat coil but valve cmd is missing,\n  // cannot test so return null\n  if (rh==null and equip.has(\"hotWaterHeat\")) return null\n  \n  // If terminal unit has no reheat, then entire period is valid\n  if (rh==null) norh: dat.hisRead(span, {limit: null})\n                         .hisFindPeriods(v => true)  \n\n  // Otherwise, period is valid only when reheat valve has been closed\n  // for at least rhDelay\n  else do\n    extSpan: span.toDateSpan().start-1day..span.toDateSpan().end+1day\n    norh: rh.hisRead(extSpan, {limit: null})\n            .hisFindPeriods(v => v < 0.5%)\n            .hisPeriodShift(rhDelay, -syncDelay)\n  end\n  \n  // Estimate duct heat gain for related AHU\n  if (not(readById(equip->id).has(\"ahuRef\"))) return null\n  ahuId: equip->ahuRef\n  heatGain: anAhuDuctGain(ahuId, span, rhDelay)\n  if (heatGain==null) return null\n\n  // Load AHU SAT and TU DAT history, and flag when DAT > SAT + DHG\n  // and reheat valve has been closed (norh period)\n  sat: read(discharge and air and temp and sensor and equipRef==ahuId,\n            false)\n  // If AHU SAT is missing, return null\n  if (sat==null) return null \n  \n  datHis: dat.hisRead(span, {limit: null}).renameCol(\"v0\",\"dat\")\n  eatHis: sat.hisRead(span, {limit: null})\n             .addCol(\"eat\", row => row->v0 + heatGain)\n             .keepCols([\"ts\",\"eat\"])\n  \n  // Join trends, interpolate, filter out reheat periods\n  flagPeriods: hisJoin([datHis, eatHis])\n      .hisInterpolate()\n      .hisFindInPeriods(norh)\n\n  // Filter out unoccupied periods if occ is avilable\n  if (zoneEn != null)\n    flagPeriods= flagPeriods.hisFindInPeriods(zoneEn)\n\n  // Detect DAT > EAT + threshold\n  flagPeriods= flagPeriods\n      .addCol(\"flag\", row => if (row.has(\"dat\") and row.has(\"eat\"))\n                               row->dat > row->eat + threshold\n                             else\n                               null)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindPeriods(flag => if (flag != null) flag else false)\n  \n  // Re-filter to avoid last TRUE lasting until midnight\n  flagPeriods= hisPeriodIntersection([flagPeriods, norh])\n  \n  // Filter out unoccupied periods again, if occ is avilable\n  if (zoneEn != null)\n    flagPeriods= hisPeriodIntersection([flagPeriods, zoneEn])\n\n  // Rename cols after hisPeriodIntersection\n  flagPeriods= flagPeriods.renameCol(\"v0\",\"flag\")\n  \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip.dis() + \" has leaky reheat valve or miscalibrated DAT sensor\"\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-03  Raphael Vitti\n    Changed closed valve threshold from \"== 0%\" to \"< 0.5%\" because some valve\n    positions at B67 show 0.2xx% when the valve is closed.\n*/",,
,["anFumeHoodSash"],,,,M,,,,,,"viFumeHoodTrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given fume hood, display trends of airflow and sash height\n  \n  Arguments: \n  fhRef             Reference for site or location to search under\n  dates             Span, dates to run analysis on\n  options           String, \"Airflow and damper position\"\n                            \"Airflow and face velocity\"\n                            \"Airflow and sash height\"\n                            \"Sash height and damper position\"\n*/\n\n(fhRef, dates, options:\"Airflow and damper position\") => do\n  fh: readById(fhRef)\n  \n  if(options==\"Airflow and damper position\"\n     or options==\"Airflow and face velocity\"\n     or options==\"Airflow and sash height\") do\n     \n    airflow: read(air and flow and sensor and equipRef==fhRef, false)\n    if (airflow==null) return null\n    t1: airflow.hisRead(dates).addColMeta(\"v0\", {chartGroup: \"1\",\n                                                 color: \"blue\"})\n  end\n    \n  if(options==\"Airflow and damper position\"\n     or options==\"Sash height and damper position\") do\n    damper: read(damper and cmd and equipRef==fhRef, false)\n    if (damper==null) return null\n    \n    t2: damper.hisRead(dates).addColMeta(\"v0\", {chartGroup: \"1\",\n                                                color: \"black\"})\n  end\n  \n  if(options==\"Airflow and face velocity\") do\n    velocity: read(face and air and speed and sensor and equipRef==fhRef, false)\n    if (velocity==null) return null\n    t2: velocity.hisRead(dates).addColMeta(\"v0\", {chartGroup: \"1\",\n                                                  color: \"green\"})\n  end\n  \n  if(options==\"Airflow and sash height\"\n     or options==\"Sash height and damper position\") do\n    \n    sash: anFumeHoodSash(fhRef,dates)\n    if (sash==null or isEmpty(sash)) return null\n    \n    sash= sash.addColMeta(\"height\", {chartGroup: \"1\",\n                                     color:\"orange\"})\n    \n    if (options==\"Airflow and sash height\")\n      t2: sash\n    else\n      t1: sash\n  end\n  \n  grid: hisJoin([t1, t2])\n        .addMeta({title: fh.dis() + \" trend details\"})\n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Elec Usage Norm (kWh/ft²)",,M,"Site electrical consumption normalized by ft².",,,"site",,"kpiElecUsageNorm",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(energy and delta and sensor and not hidden and equipRef->elec\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n           \n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisClip\n                                       .energyNormByArea\n\n  if (his.isEmpty or\n      his.meta[\"hisEnd\"] < pt[\"hisStart\"] or\n      his.missing(\"v0\")) return null\n\n  kpiSum: his.foldCol(\"v0\", sum)\n  if (na() == kpiSum) null else {sum: kpiSum.as(1)}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viMissingRecentHistory",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Points in the database should have trends associated with them and the\n  trends should get synchronized automatically. If no recent history is \n  available, there may be a communication issue or other configuration\n  issue that needs to be resolved.\n  Return grid with:\n    idMissingRecentHis:   point id\n    connRef:              ref, connector, if any \n    virtual:              marker, if any\n    hisEnd:               date and time of most recent history point\n  \n  Arguments: \n  sinceDate        date used in threshold (midnight of that day is used)\n*/\n\n(sinceDate: yesterday()) => do\n  try\n    threshold: dateTime(sinceDate, time(0,0,0), \"Los_Angeles\")\n  catch\n    threshold: dateTime(yesterday(), time(0,0,0), \"Los_Angeles\")\n\n  oldHis: readAll(point and hisEnd)\n          .findAll(row => row->hisEnd < threshold and\n                          (not row.has(\"connRef\")\n                          or not readById(row->connRef).has(\"disabled\")))\n          .map(row =>\n            {idMissingRecentHis: row->id,\n             connRef: row[\"connRef\"],\n             virtual: row[\"virtual\"],\n             hisEnd: row[\"hisEnd\"]\n            }\n          )\n   \n  if (isEmpty(oldHis))\n    oldHis = {success: \"All points have recent history data\"}\n             .toGrid\n  \n  return oldHis\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",@p:lbnl:r:22d9bce9-061451a1 "dbHisHealth",
,["fandocDeficiency"],,,,M,,,,,,"viDeficienciesOverview",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Create a fandoc of deficiencies titles and description only.\n  \n  Arguments: \n  siteRef             Ref<site>, siteRef filter\n  deficiencyGroupRef  Ref<deficiencyGroup>, group filter\n  state               Str, state filter, can be \"Any\", \"Active\", \"Not Closed\"\n                      or any specific deficiency state string\n  sprintRefs          Ref<sprint>[], sprintRef filter\n  assignedTo          Str, assignedTo filter, can be \"\"\n  filter              Str, filter on deficiency dis and group dis, case insensitive\n*/\n\n(siteRef, deficiencyGroupRef:null, state:\"Any\", sprintRefs:null, assignedTo:\"\", filter:\"\", limit:2000) => do\n  // Determine current and previous sprints\n  sortedSpr: readAll(sprint)\n             .sortr((a,b) => a->sprint <=> b->sprint)\n  currentSpr: sortedSpr[0]\n  previousSpr: sortedSpr[1]\n  // Process sprintRefs\n  if (sprintRefs != null)\n    sprintRefs= sprintRefs\n    .map(sId => if (readById(sId)->sprint==-1) previousSpr->id\n                else if (readById(sId)->sprint==0) currentSpr->id\n                else sId)\n\n  // Initialize grid\n  grid: if(siteRef==null)\n          readAll(deficiency)\n        else\n          readAll(deficiency and siteRef==siteRef)\n  \n  // Escape if no deficiencies are found, to avoid grid manipulation errors\n  if(isEmpty(grid)) return null\n  \n  // Apply deficiency group filter\n  grid= grid.findAll(row => if(deficiencyGroupRef==null) true\n                            else row[\"deficiencyGroupRef\"]==deficiencyGroupRef)\n  \n  // Apply deficiency state filter\n  grid= grid.findAll(row => if(state==\"Any\") true\n                            else if(state==\"Active\")\n                              [\"To Do\",\"In Progress\"].contains(row->state)\n                            else if(state==\"Not Closed\")\n                              not([\"Closed\",\"Abandoned\"].contains(row->state))\n                            else row->state==state)\n  \n  // Apply deficiency sprint filter\n  grid= grid.findAll(row => if(sprintRefs==null) true\n                            else sprintRefs.contains(row[\"sprintRef\"]))\n  \n  // Apply deficiency assignment filter\n  grid= grid.findAll(row =>\n      if (assignedTo==\"\") return true\n      else if (row[\"assignedTo\"]==null) false\n           // regex with ?i flag is NOT case sensitive\n           else reMatches(\"(?i).*\"+assignedTo+\".*\", row[\"assignedTo\"]))\n  \n  // Apply deficiency display name + group display name filter\n  grid= grid.findAll(row => do\n    groupDis: if(row[\"deficiencyGroupRef\"]!=null)\n                readById(row[\"deficiencyGroupRef\"]).dis()\n              else \"\"\n    // regex with ?i flag is NOT case sensitive\n    return reMatches(\"(?i).*\"+filter+\".*\", row.dis() + groupDis)\n  end)\n                \n  if(isEmpty(grid)) return null\n  \n  // Compile summary fandoc\n  grid= grid.sort((a,b) => a.dis() <=> b.dis())\n            .addCol(\"fandocCol\", r => fandocDeficiency(r->id, limit))\n  return grid.colToList(\"fandocCol\").concat(\"\\n\")\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualRollupPUE",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Makes use of pre-calculated numerator and denominators at 15-minute intervals\n  to calculate a PUE at other desired, longer intervals.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n\n  Tags:\n  - virtual\n  --- hisFunc\n  --- hisInterval\n  --- computeL1 OR computeL2\n*/\n\n(rec, dates, opts, yield) => do\n  // Normalize to absolute ref (for old Historian)\n  rec= rec->id.readById\n  \n  // Retrieve and process parameters from point\n  hisInterval: rec->hisInterval\n  if (hisInterval < 15min) do\n    commit(diff(rec,\n                {hisErr: \"hisRollup for PUE cannot be less than 15min\"},\n                {transient}))\n    return null\n  end\n  \n  // Retrieve denominator and numerator points from same equip\n  if (rec.has(\"computeL1\")) do\n    denominator: read(denominator and computeL1 and hisInterval==15min\n                      and equipRef==rec->equipRef, false)\n    if (denominator==null) do\n      commit(diff(rec,\n                  {hisErr: \"Denominator L1 not found in same equip as virtual PUE point\"},\n                  {transient}))\n      return null\n    end\n  end else if (rec.has(\"computeL2\")) do\n    denominator: read(denominator and computeL2 and hisInterval==15min\n                      and equipRef==rec->equipRef, false)\n    if (denominator==null) do\n      commit(diff(rec,\n                  {hisErr: \"Denominator L2 not found in same equip as virtual PUE point\"},\n                  {transient}))\n      return null\n    end\n  end else do\n    commit(diff(rec,\n                {hisErr: \"Virtual PUE point is missing computeL1 or computeL2 tag\"},\n                {transient}))\n    return null\n  end\n  \n  numerator: read(numerator and hisInterval==15min and equipRef==rec->equipRef, false)\n  if (numerator==null) do\n    commit(diff(rec,\n                {hisErr: \"Numerator not found in same equip as virtual PUE point\"},\n                {transient}))\n    return null\n  end\n  \n  // Read and rollup numerator and denominator\n  grid: [numerator, denominator].hisRead(dates, {limint:null})\n                                .hisRollup(avg, hisInterval)\n\n  // Yield PUE\n  grid.each row => do\n    if (row.any v => v == null or v == na()) yield(row->ts, na())\n    else if (row->v1==0) yield(row->ts, na())\n    else yield(row->ts, (row->v0/row->v1).as(rec->unit)) \n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateDataQuality",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Record validation for meter data quality records\n  \n  Arguments:\n  rec               Dict to validate\n*/\n\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  // Check for presence of startDate\n  if (not(rec.has(\"startDate\")))\n    throw \"startDate is required\"\n  \n  // Check that start date is not in the future\n  if (rec[\"startDate\"] > today())\n    throw \"startDate cannot be in the future\"\n  \n  // Check for conflicting records\n  prevRec: read(dataQuality\n                and meterRef==rec->meterRef\n                and startDate==rec->startDate,false)\n  if (prevRec!=null and prevRec->id!=rec[\"id\"])\n    throw \"A data quality record already exists for \"\n          +readById(rec->meterRef).dis()\n          +\" on \"+rec->startDate.format(\"YYYY-MM-DD\")\n  \n  // Validation complete\n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpIntgCacheB67Zones",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  readAll(supply and terminalUnit and siteRef->dis==\"67\")\n  .addCol(\"controller\", row => if(row->equipRef!=@p:lbnl:r:2288e637-faf6fc68)\n                                 readById(row->equipRef)[\"controller\"]\n                                 else null)\n  .each(supplyTU => if (supplyTU.has(\"controller\")) do\n      cacheRecs: readAll(connPointCache and connRef->siteRef->dis==\"67\")\n      .findAll(row => if(row.has(\"bacnetCurName\"))\n                        row[\"bacnetCurName\"].contains(supplyTU->controller)\n                      else if(row.has(\"bacnetHisName\"))\n                        row[\"bacnetHisName\"].contains(supplyTU->controller)\n                      else false)\n      \n      if (isEmpty(cacheRecs)) return null\n      else cacheRecs\n           .each(rec => commit(diff(rec, {tmpEquipRef:supplyTU->id})))\n  end)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolSplitTrends"],,,,M,,,,,,"viSystemPrePostScatter",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Given a specific date, give the baseline and last week (or selected range) data for\n  CT Fan Power, CW Pump Power and TW Pump Power. Present the data\n  as a scatter chart of combined power vs OA WB Temp data at B59 (in °F). \n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01), dateRangePost: lastWeek().toSpan(), min: null, max: null, rollup:15min) => do\n  //Reference B59 for siteRef\n    bldgRefId: @p:lbnl:r:221f652e-4f67467f\n    \n  // Define full range from pre and post date ranges\n  rangeStart: dateRangePre.start().date()\n    rangeEnd: dateRangePost.end().date()\n  \n   fullRange: toDateSpan(rangeStart..rangeEnd)\n\n  // Look up B59 Data Center Computers for compute power filter\n  compRef: read(siteRef==bldgRefId and locationRef->dis==\"B59 Data Center\" and navName==\"Computers\")->id  \n\n  // Get compute power for given computers filter\n  compFilter: read(equipRef==compRef and compute and meter and virtual and equip)\n  compPower: read(equipRef==compFilter->id and power and sensor and point)\n\n  // Get the reference for the TW and CW Plants\n  cwPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and treatedWaterPlant\n                    and navName == \"Plant\")\n  \n  twPlantEquip: read(siteRef==bldgRefId\n                    and equip\n                    and condenserWaterPlant\n                    and navName == \"Plant\")\n\n  // Get the power points for the TW pumps, CT Fans, and CW Pumps\n  twPumpPowers: readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n  ctFanPowers:  readAll(locationRef==twPlantEquip->locationRef\n                    and equipRef->fan\n                    and power\n                    and sensor)\n  \n  cwPumpPowers: readAll(locationRef==cwPlantEquip->locationRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n\n   // For the full date range sum the power histories \n   // for each system, TW Pumps, CT Fans, and CW Pumps\n   totalTWPumpPower: hisRead(twPumpPowers, fullRange, {limit:null})\n                   .hisRollup(avg, rollup)\n                   .hisFoldCols(sum)\n   \n   totalCTFanPower: hisRead(ctFanPowers, fullRange, {limit:null})\n                   .hisRollup(avg, rollup)  \n                   .hisFoldCols(sum)\n\n   totalCWPumpPower: hisRead(cwPumpPowers, fullRange, {limit:null})\n                   .hisRollup(avg, rollup) \n                   .hisFoldCols(sum)\n   \n   totalSysPower:    hisJoin([totalTWPumpPower, totalCTFanPower, totalCWPumpPower])\n                   .hisFoldCols(sum)\n                   .renameCol(\"v0\",\"totalSysPower\")\n\n  //wBulb is the wetbulb temperature (defaulting to the same location as the default site)\n   wBulb:       read(equipRef==twPlantEquip->id and outside and point and sensor and wetBulb)\n                   .hisRead(fullRange, {limit:null})\n                   .hisRollup(avg, rollup)\n                   .renameCol(\"v0\",\"oaWetbulb\")\n  \n  // use toolSplitTrends to highlight the post range\n   totalSysPost:   toolSplitTrends(totalSysPower, dateRangePost, \"orange\")\n                   .renameCol(\"totalSysPower0\",\"postSysPower\")\n                   .removeCol(\"totalSysPower\")\n                   \n  // use toolSplitTrends to highlight the pre range\n   totalSysPre:   toolSplitTrends(totalSysPower, dateRangePre, \"orange\")\n                  .renameCol(\"totalSysPower0\",\"preSysPower\")\n                  .removeCol(\"totalSysPower\")\n   \n   totalSysPower = hisJoin([totalSysPost,totalSysPre])\n  \n  //select columns to be used in graph\n   selectCols:  totalSysPower.colNames().findAll(v => v != \"ts\")\n                   .insert(0, \"oaWetbulb\")\n\n  //define compute power filter\n  powerFilter: hisRead(compPower, fullRange, {limit:null})\n  // Find times when filter is true\n                  .hisFindPeriods(v => (v > min and v < max))\n  \n  // join wetbulb and total power pre trend to prep for the scatter chart\n  // add title and meta to graph\n   graphPre: hisJoin([wBulb, totalSysPower])\n                 .hisFindInPeriods(powerFilter)\n                 .keepCols(selectCols)\n                 .addMeta({chartType: \"scatter\",\n                          title: \"Cooling Plant Total Power (Baseline vs. Post)\"})\n                 .addColMeta(\"oaWetbulb\", {chartMin: 40°F, chartMax: 70°F}) \n                 .addColMeta(\"postSysPower\", {dis: \"Total Power Present \"+dateRangePost,\n                              color: \"#DE3E30\"}) \n                 .addColMeta(\"preSysPower\", {dis: \"Total Power Baseline \"+dateRangePre,\n                              color: \"#7ED7DE\",\n                              chartMin: 0kW})\n                                 \n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anStale",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze a history grid and find if the history value was stale (the same)\n  throughout the entire period. Function works only for Bool and Number types.\n  Return grid with periods of stale value. In effect, either the entire\n  period is returned, or null.\n  \n  Arguments: \n  hisGrid            Grid of history data, with ts and v0 cols (others ignored)\n  minReadings        Numeric, minimum number of readings to be present to run\n                     analysis, default 3\n*/\n\n(hisGrid, minReadings: 3) => do\n  // Check that \"v0\" column exists and has enough readings\n  if (not hisGrid.has(\"v0\") or hisGrid.foldCol(\"v0\",count) < minReadings)\n    return null\n\n  // Check that history is either Bool or Number, otherwise return null\n  if (not([\"Number\",\"Bool\"].contains(hisGrid.col(\"v0\").meta->kind)))\n    return null\n  \n  // Convert Bool values for analysis\n  if (hisGrid.col(\"v0\").meta->kind == \"Bool\")\n      hisGrid= hisGrid.hisMap v => if(v) 1 else 0\n\n  // If point is not stale, return null\n  if (hisGrid.foldCol(\"v0\",max) != hisGrid.foldCol(\"v0\",min))\n    return null\n  \n  // Otherwise return entire period\n  period: hisGrid.hisFindPeriods(v => true)\n  dis: period.col(\"v0\").meta->navName + \" is stale\"\n  return period.addColMeta(\"v0\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldAny",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  if (val == foldStart()) return {status:false}\n  if (val == foldEnd()) return acc[\"status\"]\n  if (val == na() or acc[\"status\"]==na()) return {status:na()}\n  if (val == null) return acc\n  return {status: acc->status or val}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ruDamperControl",,"terminalUnit or zone","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns a period that an equip with a damper cmd is in a\n  given range more than a given percentage of the time during the given\n  period. In effect, either the entire period is returned, or null.\n  \n  Arguments:\n  equip           equip record of equip to test airflow on\n  span            dateSpan, span of dates to run analysis on\n  pbRange         list of min and max position, defining a range\n                  that the damper cmd shouldn't stay in for too long\n  timeTolerance   number, between 0 and 1 (0% and 100%). Issue is flagged\n                  if total issue time covers at least this percentage of\n                  the total analysis span duration.\n  occOnly         boolean, if true and if there is an occupied zone cmd point\n                  on the equip, filter out periods when the occupied cmd\n                  is OFF\n*/\n\n(equip:readById(@p:lbnl:r:2324cceb-a74e8cdc), span:pastWeek(),\n pbRange: [99%,100%], timeTolerance: 0.9, occOnly:false) => do\n  // Params\n  minVals: 3\n \n  // Check inputs, prepare filters\n  if (timeTolerance > 1) timeTolerance= 1\n  if (timeTolerance <0) timeTolerance= 0\n  timeTolerance= timeTolerance.as(1) // Remove unit if any\n  \n  rangeMin: max(min(pbRange[0].as(\"%\"),100%),0%)\n  rangeMax: max(min(pbRange[1].as(\"%\"),100%),rangeMin)\n  \n  // Retrieve occupied command if occOnly is true\n  if (occOnly)\n    occ: read(point and occupied and zone and cmd\n              and equipRef==equip->id, false)\n  else occ: null\n  \n  if (occ != null) occ= occ.hisRead(span, {limit:null})\n                           .hisFindPeriods(v => v)\n  \n  // Calculate timeThreshold\n  span= span.toDateSpan\n  if (occ != null)\n    timeThreshold: occ.foldCol(\"v0\",sum)\n                   * timeTolerance\n  else\n    timeThreshold: (span.end - span.start + 1day) * timeTolerance\n  \n  // If equip does not have a damper cmd, return null\n  damper: read(point and damper and cmd and unit==\"%\"\n               and equipRef==equip->id, false)\n  if (damper == null) return null\n  \n  // Read history, return null if not enough data points\n  data: damper.hisRead(span, {limit: null})\n  if (occ != null) data= data.hisFindInPeriods(occ)\n  if (data.foldCol(\"v0\",count) < minVals) return null\n  \n  // Find periods where damper cmd is in given range\n  flagPeriods: data.hisFindPeriods(p => (p >= rangeMin) and\n                                        (p <= rangeMax))\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  // If cumulative flagged time is less than threshold, return null\n  if (flagPeriods.foldCol(\"v0\", sum) <= timeThreshold) return null\n  \n  // Otherwise return entire period\n  period: data.hisFindPeriods(v => true)\n  dis: period.col(\"v0\").meta->navName + \" is too often in range \"\n    + rangeMin + \" - \" + rangeMax\n  return period.addColMeta(\"v0\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06Floor2Terminals",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point stored in `io/integration_b6/b6_floor2_tus.csv`\n to add these points to zone and tu equips that already exist.\n Add new exhaust terminal unit equip if needed.\n \n The file includes a match to the 2018-09-25 tagging standard\n to associate the proper tags and navName to each point.\n*/\n\n(file: `io/integration_b6/b6_floor2_tus.csv`,\ntypes: [0,1,2,5,20], finalize: false) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(file)\n  \n  siteId: read(site and dis==\"06\")->id\n  locationId: read(location and dis==\"B6 Floor 2\")->id\n  \n  // Cycle through existing terminal units\n  tus: readAll(supply and terminalUnit and equip\n               and locationRef==locationId)\n  tus.each((tu, i) => do\n    jobProgress(round(i/tus.size()*100).as(\"%\"), tu.dis())\n    zoneId: tu->equipRef\n    connectorId: tu->connRef\n    \n    bacnetPtList: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\n    bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"TL\"]\n    \n    types.each type => do\n      bacnetLearn(connectorId)\n      learn: bacnetLearn(connectorId, type)\n      bacnetPtList= bacnetPtList.set(type, learn)\n    end\n\n    // Cycle through given points of interest, find and integrate\n    alcPtList.each pt => do\n      curType: parseNumber(pt->curType)\n      tagRow: tagStd.find(tag => tag->index==pt->indexTagStandard)\n      \n      // Find available BACnet point info\n      bacnetGrid: bacnetPtList[curType]\n      if (bacnetGrid == null) bacnetGrid= [].toGrid()\n      bacnetRow: bacnetGrid.find(row => row[\"dis\"]==pt->bacnetDis)\n      \n      // If point not found in BACnet, it does not exist for this zone, skip\n      if (bacnetRow == null) return null\n      \n      // Depending on type of point, determine equip to place point under\n      indexTag: parseNumber(pt->indexTagStandard)\n      if (indexTag >= 163 and indexTag <=197) equipId: zoneId\n      else if (indexTag >= 198 and indexTag <=229) equipId: tu->id\n      else if (indexTag >= 230 and indexTag <=232) do\n        // If exhaust TU does not exist, create it\n        exh: read(exhaust and terminalUnit and equip\n                    and equipRef==zoneId, false)\n        if (exh == null) do\n          eqDict: {navName: \"Exhaust TU\",\n                   disMacro: \"\\\$equipRef \\\$navName\",\n                   equip,\n                   equipRef: zoneId,\n                   locationRef: locationId,\n                   siteRef: siteId,\n                   exhaust,\n                   terminalUnit,\n                   tmp: today()}\n          commit(diff(null, eqDict, {add}))\n          exh= read(exhaust and terminalUnit and equip\n                         and equipRef==zoneId)\n        end\n        equipId: exh->id\n      end else return null\n      \n      // If point already exists, skip\n      ptFilter: \"point and equipRef==@\" + equipId + \" and \"\n                + tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n      if (read(parseFilter(ptFilter),false) != null) return null\n      \n      // Check units, save both if mismatch\n      if (bacnetRow[\"unit\"] == null) do\n        unit: pt[\"curUnit\"]\n        bacnetUnit: null\n      end else if (bacnetRow[\"unit\"] != pt->curUnit) do\n        unit: pt[\"curUnit\"]\n        bacnetUnit: bacnetRow[\"unit\"]\n      end else do\n        unit: bacnetRow[\"unit\"]\n        bacnetUnit: null\n      end\n      \n      // Find bacnetHis\n      if (pt.has(\"bacnetTrendDis\")) do\n        bacnetTrendDis: pt->bacnetTrendDis\n        bacnetTrendRow: bacnetPtList[20].find(row => row[\"dis\"]==bacnetTrendDis)\n        if (bacnetTrendRow == null) bacnetHis: null\n        else bacnetHis: bacnetTrendRow->bacnetHis\n      end else bacnetHis: null\n      \n      // Prepare polling variables as needed (null if bacnetHis)\n      hisCollectCov: if (pt[\"hisCollectCov\"]==null) null else marker()\n      hisCollectInterval: if (pt[\"hisCollectCov\"]==null) null else 12h\n      \n      // Prepare new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               cur,\n               bacnetCur: bacnetRow->bacnetCur,\n               bacnetHis: bacnetHis,\n               bacnetCurFile: pt[\"bacnetAdrs\"],\n               bacnetHisFile: pt[\"bacnetTrendAdrs\"],\n               bacnetName: bacnetRow->dis,\n               kind: bacnetRow[\"kind\"], //optional\n               unit: unit,\n               bacnetUnit: bacnetUnit,\n               enum: bacnetRow[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               hisCollectCov: hisCollectCov,\n               hisCollectInterval: hisCollectInterval,\n               notes: bacnetRow[\"bacnetDesc\"], //optional\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\",\n               tmp: today()}\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n    end  // alcPtList.each pt\n  end)  // each tu\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateTask"],,,,M,,,,,,"recNewTask",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(taskDict) => do\n  // Normalize action input\n  taskDict= actionNormInput(taskDict, \"dict\")\n  \n  taskDict= taskDict\n    .set(\"siteRef\", if (readById(taskDict[\"modRef\"]).has(\"site\"))\n                      taskDict[\"modRef\"] \n                    else readById(taskDict[\"modRef\"])->siteRef)\n    .set(\"createdBy\", userCur()->dis)\n\n  // Validate record\n  taskDict= recValidateTask(taskDict)\n\n  rec: commit(diff(null,taskDict,{add}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptAccumulatorToRate",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates history for a virtual rate of change\n  point using an accumualtor point history\n  \n Accumulator point should be tagged as pointRef in virtual\n  rate of change point\n  \n Arguments:\n *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  // Initialize previous value and previous timestamp trackers\n  prevVal: null\n  prevTs: null\n\n  rec->pointRef  // Accumulator point\n    .hisRead(dates, {limit: null})\n    .each row => do\n      // All rows that are not first row\n      if (prevVal != null) do\n        deltaTs: (row->ts - prevTs).to(1h)  // Use time in hours for rates (BTU/h)\n        deltaVal: row->v0 - prevVal\n        avgTs: prevTs + (deltaTs / 2)\n        rate: deltaVal / deltaTs\n        if (unit(rate) == unit(1kWh / 1h)) rate = rate.as(1kW)\n        if (unit(rate) == unit(1gal / 1h)) rate = (rate/60).as(1gal/min)\n        yield(avgTs, rate)\n      end\n      // Update values\n      prevTs = row->ts\n      prevVal = row->v0\n    end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch"],,,,M,,,,,,"facZoneClgReqIgnoresNow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given zone calculate if and how many cooling requests should be ignored \n  by the AHU now based on recent data (~15min) and recent sparks (~5h).\n  See:\n  https://docs.google.com/document/d/1EcpD29I3uUZ1yK3yEJIvjYmN98pfZvoBjyk6F8sol5M/edit#\n  \n  Arguments: \n  zoneRef      Id of a zone equip\n  reqTime      Time, duration a zone request is valid\n  disqualTime  Time, duration a spark disqualifies the zone requests\n  reqInput     Number (optional), current number of requests generated by zone,\n               used in place of zone-level requests trend if provided\n*/\n(zoneRef, reqTime: 30min, disqualTime: 24h, reqInput:null) => do\n  // Normalization\n  zoneId: if (isRef(zoneRef)) zoneRef else zoneRef->id\n  zone: readById(zoneId)\n  \n  // List disqualifying spark rules\n  disqualSparks: readAll(sparkRule and (\n    id==@p:lbnl:r:233c485e-e5f94381     // Leaky reheat\n    or id==@p:lbnl:r:23349ae7-9e15f6d0  // Airflow SP not met\n    or id==@p:lbnl:r:254ccbf0-8e27e989  // Zone clg SP too low\n  ))\n  \n  // Load sparks\n  ruHis: ruleSparks(\n           toolRecursiveSearch(zoneId, \"equip and supply\")\n           .addRow(zone),\n           now()-disqualTime..now(),\n           disqualSparks)\n         .ruleSparkHis()\n  \n  // Combine periods\n  disqualPeriods: hisPeriodUnion(\n    // List of columns other than ts\n    ruHis.colNames.remove(0)\n    // Map from list creates a list, here a list of sub-grids\n    .map(colN => ruHis.keepCols([\"ts\", colN])\n                      .findAll(row => row[colN] != null)))\n  // Extend period by disqualTime\n  .hisPeriodShift(0min, disqualTime)\n  \n  // Determine cooling requests\n  if (reqInput==null) do\n    // Identify and use trend of zone requests\n    reqPt: toolRecursiveSearch(zoneId, \"cool and air and request and cmd\")\n           .first  // Only one per zone for now\n  \n    // Exit with zero if no cooling request\n    if (reqPt==null) return 0\n    \n    // Load history of cooling requests\n    req: reqPt.hisRead(now()-reqTime..now(), {limit:null})\n    // Clip if not COV to only look at reqTime interval\n    if (reqPt[\"hisMode\"]!=\"cov\")\n      req= req.hisClip\n  \n    // Only keep last valid reading\n    if (isEmpty(req)) return null\n    else try req= req.find(r => r->ts==req.col(\"v0\").meta->hisEnd)\n         catch req= null\n\n    if (req==null) return null\n  end else do\n    // Use provided value directly\n    req: {ts:now(), v0:reqInput}\n    reqPt: {}\n  end\n  \n  // Check overlap between disqualifying conditions and last request\n  if (hisInWindows(if(reqPt[\"hisMode\"]!=\"cov\") req->ts else now(), disqualPeriods)) do\n    // Store terminal unit level value if corresponding point exists and this runs\n    // as a job. This is optional.\n    writePt: toolRecursiveSearch(zoneId, \"cool and air and ignore and cmd\").first\n    if (writePt!=null and jobIsRunning())\n      hisWrite({ts:now(), val:req->v0.as(1)}, writePt)\n    // Return value to main function\n    return req->v0.as(1)\n  end else do\n    // Store terminal unit level value if corresponding point exists and this runs\n    // as a job. This is optional.\n    writePt: toolRecursiveSearch(zoneId, \"cool and air and ignore and cmd\").first\n    if (writePt!=null and jobIsRunning())\n      hisWrite({ts:now(), val:0}, writePt)\n    // Return value to main function\n    return 0\n  end\nend\n\n/*\n  Updates\n  2020-02-28   Added reqInput parameter and modified function to make use of it instead of\n               zone request trends if provided. Goal is to make use of this function\n               when generating requests in SkySpark, e.g. for B67.\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Gas Usage vs Prev Year (therm)",,M,"Delta of gas consumption between selected time range and previous year.",,,"site",,"kpiGasUsageVsPrevYear",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(energy and delta and sensor and not hidden and equipRef->gas\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n           \n  if (pt == null) return null\n\n  try do\n    cur: hisRead(pt, dates, {limit:null}).hisClip()\n                                         .hisMap(val => val.to(1therm))\n                                         .foldCol(\"v0\", sum)\n    base: hisRead(pt, dates - 364day, {limit:null}).hisClip()\n                                                   .hisMap(val => val.to(1therm))\n                                                   .foldCol(\"v0\", sum)\n    {delta: (cur - base).as(1)}\n  end catch null\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolRecTags"],,,,M,,,,,,"toolHisFoldColsByTags",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Simplifies a history grid by folding together all the histories\n  that share the exact same set of identifying tags and which\n  corresponding equips also share the exact same set of tags. Only\n  the columns that also match the provided tags filter get folded.\n  Returns a new grid with the new folded column and all \n  other unmatched columns.\n  \n  Arguments: \n  hisGrid        Grid with ts column and value columns\n  tagsFilter     String, process only the points that match filter\n  foldFunc       Func, function to use for folding columns\n  rollupFunc     Func, function to use for rollup\n  minRollup      Number (time), pass to hisAlign to specify minimum\n                 desired rollup interval\n  removeMissing  Bool, if true, remove rows with any null values,\n                 else replace all null values with NA\n*/\n\n(hisGrid, tagsFilter:\"flow\", foldFunc:sum,\n rollupFunc:avg, minRollup:0s, removeMissing:true) => do\n  // Iterate on column names\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    // his is similar to the point record\n    try do\n      his: hisGrid.col(colName).meta\n      eq: readById(his->equipRef)\n    end catch\n      return null\n      \n    // If \"hide\" tag is detected, skip to next column\n    if (his.has(\"hide\") or his.has(\"foldedByTags\")) return null\n    filterFunc: filterToFunc(tagsFilter.parseFilter)\n    if (not(filterFunc(his))) return null\n    \n    // tagSet is a list of identifying tags for the point\n    tagSet: toolRecTags(his)\n            .addAll(toolRecTags(eq))\n            .sort\n    \n    // Find all other columns with the same set of tags\n    groupCols: hisGrid.colNames.findAll(colName2 => do\n      try do\n        his2: hisGrid.col(colName2).meta\n        eq2: readById(his2->equipRef)\n      catch\n        return false\n      \n      // Retrieve point and equip tags and test equality\n      tagSet2: toolRecTags(his2)\n               .addAll(toolRecTags(eq2))\n               .sort\n      return (tagSet == tagSet2)\n    end)\n    \n    // Skip if there is only one history\n    if (groupCols.size < 2) return null\n    \n    // Create temporary grid with only ts and selected cols\n    tGrid: hisGrid.keepCols([\"ts\"].addAll(groupCols))\n    totCount: groupCols.size\n    \n    // Remove empty rows\n    tGrid= tGrid.findAll(row => row.remove(\"ts\").any(v => v != null))\n    \n    interpolateDis: false\n    // Check hisMode for COV\n    if (his[\"hisMode\"]==\"cov\" and his[\"kind\"]==\"Bool\")\n      // Typical COV data, interpolate instead of rolling up\n      tGrid= tGrid.hisInterpolate()\n    else if (his[\"hisMode\"]==\"cov\" and his[\"kind\"]!=\"Bool\") do\n      // Atypical COV data, interpolate and flag\n      tGrid= tGrid.hisInterpolate()\n      interpolateDis= true\n    end else\n      // Else align timestamps / rollup with rollupFunc\n      tGrid= tGrid.toolHisAlign(rollupFunc,     // rollupFunc\n                                min,            // intervalFunc\n                                removeMissing,  // removeMissing\n                                minRollup)      // minRollup\n          \n    // Fold using foldFunc\n    tGrid= tGrid\n           .hisFoldCols(foldFunc)\n           \n    // Add relevant metadata: display name and identifying tags\n    foldFuncStr: reGroups(r\"(fold)?(.*)\\(.*\\).*\", foldFunc.toStr)[2]\n    eqType: try reGroups(r\"([A-Za-z0-9 ,]*?)((,| |-)+\\d+[[:alpha:]]?)+\", eq->navName)[1] + \" \"\n            catch \"\"\n    ptName: try reGroups(r\"(( ?[A-Za-z])+)( \\\\(.*\\\\))?\", his->navName)[1]\n            catch his->navName\n    dis: capitalize(foldFuncStr) + \" of \" + totCount + \" \"\n         + eqType + ptName + \"(s)\" \n    if (tGrid.meta[\"hisRollupInterval\"] > 0)\n      dis= dis + \", \" + tGrid.meta[\"hisRollupInterval\"] + \" Rollup\"\n    if (interpolateDis)\n      dis= dis + \", interpolated\"\n    colMetaDict: {dis: dis}\n    tGrid= tGrid.addColMeta(\"v0\",\n      {dis: dis,\n      kind: his[\"kind\"],\n      unit: his[\"unit\"],\n      enum: his[\"enum\"],\n      foldedByTags: marker(),\n      hisMode: his[\"hisMode\"],\n      hisRollupInterval: tGrid.meta[\"hisRollupInterval\"],\n      hisRollupDis: tGrid.meta[\"hisRollupDis\"]})\n    // Add point and equip tags\n    tagSet.each tag =>\n      tGrid= tGrid.addColMeta(\"v0\", {}.set(tag, marker()))\n      \n    // Join with main grid\n    hisGrid= hisJoin([hisGrid, tGrid])\n    \n    // Mark all original column with \"hide\" tag\n    groupCols.each colName2 => do\n      hisGrid= hisGrid.addColMeta(colName2, {hide})\n    end\n  end\n  \n  // Remove all columns with \"hide\" tag\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    // his is similar to the point record\n    his: hisGrid.col(colName).meta\n    \n    // Remove column if it has \"hide\" tag\n    if (his.has(\"hide\")) hisGrid= hisGrid.removeCol(colName)\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toAhuCool"],,,,M,,,,,,"ruAhu33dehumidfying",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/**************************************************************************************\nFind all AHUs with cooling & heating coils and a dehumidifying system. \nFind periods when dehumdifying is active but not needed\nAuthor: LCH - kW Engineering\n**************************************************************************************/\n(ahu, dates, minTime: 30min)=> do\n\n  // normalize minTime to hours\n  minTime = minTime.to(1h)\n  \n  //create empty array where heating/cooling periods will be stored\n  coolingPeriods: []\n  heatingPeriods: []\n  \n  //find all stages of cooling/heating for ahu\n  coolPts: toAhuCool(ahu, false)\n  heatPts: read(reheat and valve and command and equipRef == ahu->id, false)\n \n   //collect heating/cooling periods for all stages when valves is open \n if (coolPts == null) return null\n else if (coolPts.size < 2) coolingPeriods = coolingPeriods.add(coolPts.hisRead(dates).hisFindPeriods(v=> v>5%))\n else if (coolPts.size > 1) coolPts.each rec => do\n    coolingPeriods = coolingPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v>5%))\n   end\n if (heatPts == null) return null\n else if (heatPts.size < 2) heatingPeriods = heatingPeriods.add(heatPts.hisRead(dates).hisFindPeriods(v=> v>5%))\n else if (heatPts.size > 1) heatPts.each rec => do\n    heatingPeriods = heatingPeriods.add(rec.hisRead(dates).hisFindPeriods(v=> v>5%))\n  end\n  \n  //combine multiple stages of cooling and heating\n  coolingOn: hisPeriodMatrix(coolingPeriods)\n  heatingOn: hisPeriodMatrix(heatingPeriods)\n  \n  //collect all periods when any cooling or heating valves are active\n  spark1: hisPeriodMatrix(coolingPeriods).findAll r => r->numTrue != 0\n  spark2: hisPeriodMatrix(heatingPeriods).findAll r => r->numTrue != 0\n  \n  //collect dehumid sp and value for selected dates\n  dehumSp: read(humidity and sp and equipRef == ahu->id, false)\n  if (dehumSp == null) return null\n  else\n  dehumSp = dehumSp.hisRead(dates)\n  \n  humSens: read(humidity and outside and sensor and equipRef == @p:lbnl:r:212cbbaa-2ba8d0da, false).hisRead(dates)\n  if (humSens == null) humSens = read(humidity and zone and sensor and equipRef == ahu->id, false).hisRead(dates)\n  if (humSens == null) return null\n  else\n  \n  //join sp and value histories\n  joined: hisJoin([dehumSp, oatHum]).hisInterpolate()\n  \n  //mapped for difference between sp and value\n  mapped: joined.map row => do\n            {\n            ts: row->ts,\n            val: row.get(\"v0\") - row.get(\"v1\")\n            }\n          end\n\n  //Finds periods when sp is greater than value (no dehumifing necessary)\n  spark3: mapped.hisFindPeriods(x => x > 2%)\n  \n  //Final spark is when heating is on, cooling is on, and dehumidifying is not needed\n  sparkFinal: hisPeriodIntersection([spark1, spark2, spark3]).findAll(r => r->v0 >= minTime)\n\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ztrash_toolHisAlign_v2",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Process a history grid to align timestamps of contained histories,\n  for example in preparation for a foldCols. Determine average interval\n  for each history, then select a target interval for hisRollup. Rollup\n  using given rollupFunc. Process missing (null) values based on selected\n  option. NA values are propagated. Options for null values:\n  - Show missing values with NA\n  - Remove rows with any missing values\n  \n  Arguments:\n  hisGrid          History grid to process\n  rollupFunc       Func, function used for rollup\n  intervalFunc     Func, (x,y) function used to select rollup interval\n  removeMissing    Bool, if true, remove rows with any null values,\n                   else replace all null values with NA\n  minRollup        Number (time), specify minimum rollup time\n  validIntervals   List of Numbers (time), valid rollup intervals rollup\n*/\n\n(hisGrid, rollupFunc:avg, intervalFunc:min,\n removeMissing:true, minRollup:0min,\n validIntervals:[1s, 2s, 5s, 10s, 15s, 30s,\n                 1min, 2min, 3min, 5min, 10min, 15min, 30min,\n                 1hr, 2hr, 6hr, 12hr, 24hr]) => do\n  // Initialize\n  interval: null\n  covFlag: false\n  minRollup= try minRollup.to(\"s\") catch 0s\n  \n  // Cycle through each column and determine corresponding\n  // average interval\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    subHisGrid: hisGrid.keepCols([\"ts\"].add(colName))\n                       .hisClip\n                       .findAll(row => row[colName] != null)\n    if (isEmpty(subHisGrid)) return null\n    prevTs: null\n    prevVal: null\n    subHisGrid= subHisGrid.addCol(\"dT\", row => do\n      ts: row[\"ts\"]\n      val: row[colName]\n      dT: if (prevTs==null or prevVal==null or prevVal==na() or val==null or val==na())\n            null\n          else\n            ts - prevTs\n\n      prevVal= val\n      prevTs= ts\n      return dT\n    end)\n    avgInterval: subHisGrid.foldCol(\"dT\", avg)\n    avgInterval= avgInterval.to(\"s\")\n    // Check metadata for hisMode==cov\n    if (subHisGrid.col(colName).meta[\"hisMode\"]==\"cov\")\n      covFlag= true\n    // Apply intervalFunc selection function\n    interval= if (interval==null) avgInterval\n              else intervalFunc(interval,\n                                avgInterval)\n  end\n  // If minRollup > 0, apply to interval\n  if (minRollup > 0) interval= max(interval, minRollup)\n  \n  // If any history is COV or no interval was found,\n  // exit without changes\n  if (covFlag or interval==null) return hisGrid\n \n  // Select closest valid from validIntervals\n  distF: (x,y) => abs(x.to(\"s\") - y.to(\"s\")).as(1)\n  finalInterval: validIntervals\n    .sort((a,b) => distF(a,interval) <=> distF(b,interval))\n    .first\n\n  // Perform rollup\n  hisGrid= hisGrid.hisRollup(rollupFunc, finalInterval)\n  \n  // Process missing data\n  if (removeMissing)\n    hisGrid= hisGrid.findAll(row => row.all(v => v != null))\n  else // Show missing values with NA\n    hisGrid= hisGrid.hisMap(v => if (v==null) na() else v)\n\n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["transferRoomPressureReport"],,,,M,,,,,,"rprValidityChecker",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\nValidity checker to check that the building, room and equipment inputted\nin the spreadsheet matches with the building inputted in the 'Input Google \nSheets URL' tab in the app.\n*/\n\n(rpr, bldg_num, zone, equip) => do\n  building = bldg_num.padl(2, \"0\")  \n  if (read(siteRef and dis==building, false) != null) do\n    return transferRoomPressureReport(rpr, zoneId, equipId)\n  end\n  else do\n    return \"Building does not exist in SkySpark\"\n  end\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualSum",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  summed value of all points which have a virtualRef equal\n  to the id of the virtual point\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap(x => if (x==null) na() else x)\n         .hisFoldCols(sum)\n         .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap67VAVZoneTemp",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  siteId: read(site and dis==\"67\")->id\n\n  readAll(conn and bacnetConn and siteRef==siteId)\n  .each co => do\n    // Read all the bacnet points that match the following conditions\n    objList: bacnetLearn(co->id,0)\n            .findAll(row => (row.has(\"dis\") and (row->dis.endsWith(\".ZN-T\") or\n                     row->dis.endsWith(\".ZA1T\") or row->dis.endsWith(\".ZA1-T\") or\n                     row->dis.endsWith(\".ZA2T\"))))\n    \n                     \n    // For each point, determine the controller name. If a vav is found in skyspark\n    // associated with that controller, then integrate the point.\n    objList.each obj => do\n      controllerStr: reGroups(r\"\\.([^.]*)\\.\", obj->dis)[1]\n      zoneGroups: reGroups(r\"\\.ZA([12])-?T\", obj->dis)\n      if (zoneGroups == null) do\n        vav: read(siteRef==siteId and equip and vav and \n                  controller==controllerStr, false)\n      else do\n        zoneStr: zoneGroups[1]\n        vav: read(siteRef==siteId and equip and vav and \n                  untController==controllerStr and\n                  untZone==zoneStr, false)\n      end\n\n      if (vav != null) do\n        vavId: vav->id\n        \n        // Check if Zone Temperature point already exists for this vav\n        pt: read(equipRef==vavId and zone and air and temp and sensor, false)\n        if (pt == null) do    // Create new point\n          commit(diff(\n            null,\n            {navName: \"Zone Temperature\",\n             air,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: co->id,\n             bacnetCur: obj->bacnetCur,\n             bacnetName: obj->dis,\n             connRef: co->id,\n             equipRef: vavId,\n             his,\n             hisCollectInterval: 15min,\n             kind: obj->kind,\n             point,\n             locationRef: vav->locationRef->id,\n             sensor,\n             siteRef: siteId,\n             tmp: today(),\n             tmpTest201805112,\n             tz: \"Los_Angeles\",\n             unit: obj->unit,\n             zone\n            },\n            {add}\n          ))\n        end\n        \n        // Add bacnetHis if available\n        if (obj.has(\"bacnetHis\")) do\n          pt= read(equipRef==vavId and zone and air and temp and sensor, true)\n          commit(diff(\n            pt,\n            {bacnetHis: obj->bacnetHis, -hisCollectInterval}\n          ))\n          // Synchronize with trend if history has never been collected,\n          // If history exists, then the recurring sync job will take care of it.\n          if (not(pt.has(hisEnd))) bacnetSyncHis(pt, pastMonth)\n        end\n      end\n    end\n  end\nend\n\n/*\nTest if any existing equip vav does not have Zone Temperature:\nreadAll(siteRef->dis==\"Building 67\" and equip and vav)\n  .findAll(eq => isEmpty(readAll(point and zone and air and temp \n                         and sensor and equipRef==eq->id)))\n*/\n\n/*\nCheck the connectors to see if bacnetHis appears:\nbacnetLearn(read(conn and dis==\"67 NAE4\"),`ANALOG_INPUT`)\n  .findAll(row => (row->dis.contains(\"ZN-T\") or row->dis.contains(\"ZA1T\")\n           or row->dis.contains(\"ZA2T\")))\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["bacnetObjType"],,,,M,,,,,,"map67ZonePoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(bacnetObjType: 0, validEndsList: [\".SUPFLOW\", \".TOTSUP-FLOW\", \".SUP-FLOW\"],\n indexTagStandard: \"195\", finalize: false) => do\n  // Initialize variables\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  siteId: read(site and dis==\"67\")->id\n  printObjList: [].toGrid()\n\n  // Get tagging standard row from index\n  tagRow: tagStd.find(tag => tag->index==indexTagStandard)\n  eqTagsFilterStr: tagRow->tagsEqOnly.split(\",\").concat(\" and \")\n  ptTagsFilterStr: tagRow->tagsPtOnly.split(\",\").concat(\" and \")\n\n  // Run through all connectors associated with site\n  readAll(conn and bacnetConn and siteRef==siteId)\n  .each co => do[]\n    // Initiate bacnetLearn\n    bacnetLearn(co->id)\n    \n    // Read all the bacnet points that match the following conditions\n    objList: bacnetLearn(co->id, bacnetObjType)\n             .findAll(row => row.has(\"dis\") and\n                             (validEndsList.map(v => row->dis.endsWith(v))\n                                           .any(v => v)))\n                     \n    // For each point, determine the controller name. If a zone is found in skyspark\n    // associated with that controller, then integrate the point.\n    objList= objList.addCol(\"newPt\", obj => do\n      controllerStr: reGroups(r\"\\.([^.]*)\\.\", obj->dis)[1]\n      zoneGroups: reGroups(r\"\\.UNT.+\\..*([12])\", obj->dis)\n      if (zoneGroups == null) do\n        zone: read(siteRef==siteId and equip and zone and \n                  controller==controllerStr, false)\n      else do\n        zoneStr: zoneGroups[1]\n        zone: read(siteRef==siteId and equip and \n                  untController==controllerStr and\n                  untZone==zoneStr, false)\n      end\n\n      // Skip point if no matching zone was found\n      if (zone == null) return \"matching zone not found\"\n      \n      // Determine if point needs to be added to zone or subequip\n      if (tagRow->tagsEqOnly == \"zone\" or not zone.has(\"zone\")) equipId: zone->id\n      else do\n        filterStr: eqTagsFilterStr+\" and equip and equipRef==@\"+zone->id\n        eq: read(parseFilter(filterStr), false)\n        if (eq != null) equipId: eq->id else equipId: null\n      end\n      \n      // Skip point if no matching equip was found\n      if (equipId == null) return \"matching equip not found\"\n        \n      // Check if point already exists for this equip, skip if it does\n      ptFilterStr: ptTagsFilterStr+\" and point and equipRef==@\"+equipId\n      pt: read(parseFilter(ptFilterStr), false)\n      if (pt != null) return \"existing point found\"\n      \n      // Create new point dict\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: co->id,\n               connRef: co->id,\n               cur,\n               bacnetCur: obj->bacnetCur,\n               bacnetHis: obj[\"bacnetHis\"], //optional\n               bacnetName: obj->dis,\n               kind: obj[\"kind\"], //optional\n               unit: obj[\"unit\"], //optional\n               enum: obj[\"enum\"], //optional\n               equipRef: equipId,\n               his,\n               notes: obj[\"bacnetDesc\"], //optional\n               locationRef: zone->locationRef->id,\n               siteRef: zone->siteRef->id,\n               tz: \"Los_Angeles\",\n               tmp: today()}\n               \n      // Set collection interval / cov if no bacnetHis\n      if (obj[\"bacnetHis\"] == null)\n        if (obj[\"kind\"] == \"Bool\") do\n          ptDict= ptDict.set(\"hisCollectCov\", marker())\n          ptDict= ptDict.set(\"hisCollectInterval\", 12h)\n        end else do\n          ptDict= ptDict.set(\"hisCollectInterval\", 15min)\n        end\n               \n      // Add navName and meaningful tags from standard\n      ptDict= ptDict.set(\"navName\", tagRow->dis)\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      // Commit if finalize == true\n      if (finalize) do\n        commit(diff(null, ptDict, {add}))\n      end\n      \n      return ptDict\n    end)  // objList.addCol(\"zone\", obj...\n    \n    // Add to global list for display\n    if (isEmpty(objList) and isEmpty(printObjList))\n      printObjList=[\"Empty Row\"].toGrid()\n    printObjList= printObjList.addRows(objList)\n  end  // .each co\n\n  return printObjList \nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06RHC",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  x: readLink(@p:lbnl:r:218d7f54-59d4b8ae).ioReadCsv\n  // skip column 0 which is ts\n  x.each row => do\n     pointDis: row[\"rhczat\"]\n     commit(\n       diff(\n         (readAll(point and zone and air and temp).find t => t.dis.contains(pointDis)),\n         {connRef: parseRef(row[\"connector\"]),\n          bacnetConnRef: parseRef(row[\"connector\"]),\n          bacnetCur: row[\"bacnetCur\"],\n          bacnetHis: row[\"bacnetHis\"],\n          importRGVrhc\n         }\n       )\n     )\n  end\n  //\"RHC-\"+readLink(@p:lbnl:r:218c1890-17ab0854).ioReadLines[0..3].concat(\"\\n\").ioReadCsv.colNames[1][3..4]+\" ZAT\"\n  //readAll(point and zone and air and temp).findAll t => t.dis.contains((\"RHC-\"+readLink(@p:lbnl:r:218c1890-17ab0854).ioReadLines[0..3].concat(\"\\n\").ioReadCsv.colNames[1][3..4]+\" ZAT\"))\n  //readAll(point and zone and air and temp).find t => t.dis.contains((\"RHC-\"+readLink(@p:lbnl:r:218c1890-17ab0854).ioReadLines[0..3].concat(\"\\n\").ioReadCsv.colNames[1][3..4]+\" ZAT\"))\n  //p:lbnl:r:218c24c5-f879025c\n  //readLink(@p:lbnl:r:218c24c5-f879025c).ioReadCsv.map(row => {ts: parseDateTime(row[\"timestamp\"], \"YYYY-MM-DD hh:mm:SS\", \"Los_Angeles\"), val: parseFloat(row[\"rhc01ZAT\"])})\n  //readAll(disable).each pt => commit(diff(pt, {disable: pt->hisCollectInterval, -hisCollectInterval}))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["syncModhopper"],,,,M,,,,,,"updateModhopper",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Checks the last backfilled timestamp, and syncs data starting from that last \n  backfilled timestamp, or defaultStart, to the time currently.\n  \n  Arguments: \n  point             point with a modhopperDevAddr and modhopperPointAddr\n  defaultStart      Datetime to use for first-time synchronization of points\n  \n  // LBNL // JS // Last Update: 2020-03-02 //\n*/\n\n(point, defaultStart:dateTime(date(2018,01,01),time(0,0,0))) => do\n  if (isGrid(point)) do\n    point.each row => do\n      last_reading: if (row.has(\"hisEnd\")) row->hisEnd else defaultStart\n      // If chunk is less than 20day, OK, else do just 20day\n      if (now() - last_reading < 20day)\n        syncModhopper(row, last_reading, \"now\")\n      else\n        syncModhopper(row, last_reading, last_reading+20day)\n    end\n  end\n  \n  else do\n    last_reading: if (point.has(\"hisEnd\")) point->hisEnd else defaultStart\n    if (now() - last_reading < 20day)\n      syncModhopper(point, last_reading, \"now\")\n    else\n      syncModhopper(point, last_reading, last_reading+20day)\n  end\nend\n\n/*\n  Updates\n  2020-03-02   Added defaultStart input variable and proper management for points that \n               don't yet have a history in SkySpark.\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"sqlTestScript4",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  sql: \"SELECT CONVERT(varchar, D.TimestampUTC, 120) as ts, D.Value as val, D.QuantityID as quantityId\" +\n       \" FROM ION_Data.dbo.DataLog2 D\" +\n       \" INNER JOIN ION_Data.dbo.Source S\" +\n       \" ON S.ID = D.SourceID\" +\n       \" AND D.QuantityID = '129'\" +\n       \" AND S.Name = '\" + \"LBL_ION_01.34_309A\" + \"'\" +\n       \" AND D.TimestampUTC >= '\" + \"2019-11-12 15:00:00\" + \"'\" +\n       \" AND D.TimestampUTC < '\" + now().toTimeZone(\"UTC\").format(\"YYYY-MM-DD hh:mm:ss\") + \"'\"\n\n  data: read(sqlConn and dis==\"ionDB2019\").sqlQuery(sql)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["scrapeConvertStrToNum"],,,,M,,,,,,"scrapeDentMeterPlayground",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function scrapes data from a DENT meter by accessing the\n website, finding the name of the csv that contains the data,\n and parsing through that csv for relevant values. It then writes\n voltage, current, and energy to the respective points on the\n meter.\n \n ***Requires that \"Avg\" is checked in logger. If not, some\n columns will not be able to be scraped.\n\n Arguments:\n restartDate:             Date to scrape history from. Must be\n (optional)               a dateTime, not a date. If no date is\n                          given, default will be the last time\n                          data was scraped. If there is no hisEnd,\n                          the default will be pastWeek.\n \n device:                  The rec of the device; used for finding\n                          the csv file name.\n \n channel:                 The channel we want to write to point\n                          history. Must be entered as a string.\n                          Must be 1 of 5 options:\n                          chan1,chan2,chan3,chan4,chan5\n                          \n \n // Sustainable Berkeley Lab // AMP // Last Update: 2018-08-13 //\n*/\n\n(restartDate:null,device:\"C1607024-\",channel:\"chan1\") => do\n  // Initialize the device name. Get the csv file's name by using\n  // regular expressions to match the expected format of the name\n  // (a sample csv file name is C1607024-2018-07-26-18-01-21.csv).\n  try website_text_grid: ioReadLines(`http://dentmeter-test.lbl.gov/download_logged_data.html?password=SBL_2018`) // ioReadLines(`198.128.219.57//download_logged_data.html?password=SBL_2018`)\n  catch return {suggestion1: \"Disconnect logger from meter.\", suggestion2: \"Check that meter is connected via ethernet.\"}\n  csv_name_row: website_text_grid.find row => row.contains(device)\n  try csv_name: reGroups(\"\"\"[A-Z]{1}\\\\d{7}-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}.csv\"\"\",csv_name_row)[0]\n  catch return \"Try Again\"\n  \n  // Read lines of the csv.\n  csv_grid: ioReadLines(`http://dentmeter-test.lbl.gov/` + csv_name)\n  csv_grid= csv_grid[0..-2] // Patch-up: The last row almost always seems to cause an error\n  \n  // Find how many inputs are in each channel.\n  chan_names: csv_grid.find row => row.contains(\"Record\")\n  chan_names= split(chan_names, \",\")\n  chan1: chan_names.findAll (row => row.contains(\"Chan 1\")).size\n  chan2: chan_names.findAll (row => row.contains(\"Chan 2\")).size\n  chan3: chan_names.findAll (row => row.contains(\"Chan 3\")).size\n  chan4: chan_names.findAll (row => row.contains(\"Chan 4\")).size\n  chan5: chan_names.findAll (row => row.contains(\"Chan 5\")).size\n  \n  // Get the headers of each column. (May have repeats of headers).\n  col_names: csv_grid.find row => row.contains(\"Date\")\n  col_names= split(col_names, \",\")\n  \n  // Divide the headers by channel. (Will NOT have repeats of\n  // headers).\n  chan1_names: col_names[3..(3+chan1-1)]\n  chan2_names: col_names[(3+chan1)..(3+chan1+chan2-1)]\n  chan3_names: col_names[(3+chan1+chan2)..(3+chan1+chan2+chan3-1)]\n  chan4_names: col_names[(3+chan1+chan2+chan3)..(3+chan1+chan2+chan3+chan4-1)]\n  chan5_names: col_names[(3+chan1+chan2+chan3+chan4)..(3+chan1+chan2+chan3+chan4+chan5-1)]\n  \n  // Parse the csv for timestamp and data. For each row, if it is\n  // a meaningful row (if it has a timestamp), assign values.\n  data_grid: csv_grid.map row => do\n    date_string: reGroups(\"\"\"\\\\d{2}/\\\\d{2}/\\\\d{2}\"\"\",row)\n    time_string: reGroups(\"\"\"\\\\d{2}:\\\\d{2}:\\\\d{2}\"\"\",row)\n    // If a meaningful row\n    if (date_string!=null and time_string!=null) do\n      // First assign dateTime. The csv is always in UTC so convert\n      // to Los Angeles time. Then make a list of data.\n      dateTime: dateTime(parseDate(date_string[0],\"MM/DD/YY\"),parseTime(time_string[0],\"hh:mm:ss\"),\"GMT\")\n      .toTimeZone(\"Los_Angeles\")\n      data: split(row,\",\")\n      data= data[3..-1]\n      data= data.map val => do\n        value: scrapeConvertStrToNum(val)\n      end\n      // If chan1 has values, check to see if its header is in the\n      // header list for Channel 1. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan1 > 0) do\n        if (chan1_names.any name => name.contains(\"Volt\")) do\n          chan1_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_volt: null\n        end\n        if (chan1_names.any name => name.contains(\"Amp\")) do\n          chan1_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_amps: null\n        end\n        if (chan1_names.any name => name.contains(\"KW Hours\")) do\n          chan1_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_KWH: null\n        end\n        if (chan1_names.any name => name.contains(\"Avg. KW\")) do\n          chan1_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_avgKW: null\n        end\n        if (chan1_names.any name => name.contains(\"Avg. KVA\")) do\n          chan1_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_avgKVA: null\n        end\n        if (chan1_names.any name => name.contains(\"PF\")) do\n          chan1_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_PF: null\n        end\n        if (chan1_names.any name => name.contains(\"KVAR\")) do\n          chan1_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan1_KVAR: null\n        end\n      end else do\n        chan1_volt: null\n        chan1_amps: null\n        chan1_KWH: null\n        chan1_avgKW: null\n        chan1_avgKVA: null\n        chan1_PF: null\n        chan1_KVAR: null\n      end\n      // If chan2 has values, check to see if its header is in the\n      // header list for Channel 2. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan2 > 0) do\n        if (chan2_names.any name => name.contains(\"Volt\")) do\n          chan2_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_volt: null\n        end\n        if (chan2_names.any name => name.contains(\"Amp\")) do\n          chan2_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_amps: null\n        end\n        if (chan2_names.any name => name.contains(\"KW Hours\")) do\n          chan2_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_KWH: null\n        end\n        if (chan2_names.any name => name.contains(\"Avg. KW\")) do\n          chan2_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_avgKW: null\n        end\n        if (chan2_names.any name => name.contains(\"Avg. KVA\")) do\n          chan2_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_avgKVA: null\n        end\n        if (chan2_names.any name => name.contains(\"PF\")) do\n          chan2_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_PF: null\n        end\n        if (chan2_names.any name => name.contains(\"KVAR\")) do\n          chan2_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan2_KVAR: null\n        end\n      end else do\n        chan2_volt: null\n        chan2_amps: null\n        chan2_KWH: null\n        chan2_avgKW: null\n        chan2_avgKVA: null\n        chan2_PF: null\n        chan2_KVAR: null\n      end\n      // If chan3 has values, check to see if its header is in the\n      // header list for Channel 3. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan3 > 0) do\n        if (chan3_names.any name => name.contains(\"Volt\")) do\n          chan3_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_volt: null\n        end\n        if (chan3_names.any name => name.contains(\"Amp\")) do\n          chan3_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_amps: null\n        end\n        if (chan3_names.any name => name.contains(\"KW Hours\")) do\n          chan3_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_KWH: null\n        end\n        if (chan3_names.any name => name.contains(\"Avg. KW\")) do\n          chan3_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_avgKW: null\n        end\n        if (chan3_names.any name => name.contains(\"Avg. KVA\")) do\n          chan3_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_avgKVA: null\n        end\n        if (chan3_names.any name => name.contains(\"PF\")) do\n          chan3_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_PF: null\n        end\n        if (chan3_names.any name => name.contains(\"KVAR\")) do\n          chan3_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan3_KVAR: null\n        end\n      end else do\n        chan3_volt: null\n        chan3_amps: null\n        chan3_KWH: null\n        chan3_avgKW: null\n        chan3_avgKVA: null\n        chan3_PF: null\n        chan3_KVAR: null\n      end\n      // If chan4 has values, check to see if its header is in the\n      // header list for Channel 4. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan4 > 0) do\n        if (chan4_names.any name => name.contains(\"Volt\")) do\n          chan4_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_volt: null\n        end\n        if (chan4_names.any name => name.contains(\"Amp\")) do\n          chan4_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_amps: null\n        end\n        if (chan4_names.any name => name.contains(\"KW Hours\")) do\n          chan4_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_KWH: null\n        end\n        if (chan4_names.any name => name.contains(\"Avg. KW\")) do\n          chan4_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_avgKW: null\n        end\n        if (chan4_names.any name => name.contains(\"Avg. KVA\")) do\n          chan4_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_avgKVA: null\n        end\n        if (chan4_names.any name => name.contains(\"PF\")) do\n          chan4_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_PF: null\n        end\n        if (chan4_names.any name => name.contains(\"KVAR\")) do\n          chan4_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan4_KVAR: null\n        end\n      end else do\n        chan4_volt: null\n        chan4_amps: null\n        chan4_KWH: null\n        chan4_avgKW: null\n        chan4_avgKVA: null\n        chan4_PF: null\n        chan4_KVAR: null\n      end\n      // If chan5 has values, check to see if its header is in the\n      // header list for Channel 5. If it is, assign the first value\n      // of the data list to that column; otherwise assign null. If\n      // data was written, remove that row from the data list.\n      if (chan5 > 0) do\n        if (chan5_names.any name => name.contains(\"Volt\")) do\n          chan5_volt: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_volt: null\n        end\n        if (chan5_names.any name => name.contains(\"Amp\")) do\n          chan5_amps: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_amps: null\n        end\n        if (chan5_names.any name => name.contains(\"KW Hours\")) do\n          chan5_KWH: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_KWH: null\n        end\n        if (chan5_names.any name => name.contains(\"Avg. KW\")) do\n          chan5_avgKW: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_avgKW: null\n        end\n        if (chan5_names.any name => name.contains(\"Avg. KVA\")) do\n          chan5_avgKVA: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_avgKVA: null\n        end\n        if (chan5_names.any name => name.contains(\"PF\")) do\n          chan5_PF: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_PF: null\n        end\n        if (chan5_names.any name => name.contains(\"KVAR\")) do\n          chan5_KVAR: data[0]\n          data= remove(data,0)\n        end else do\n          chan5_KVAR: null\n        end\n      end else do\n        chan5_volt: null\n        chan5_amps: null\n        chan5_KWH: null\n        chan5_avgKW: null\n        chan5_avgKVA: null\n        chan5_PF: null\n        chan5_KVAR: null\n      end\n    // If not a meaningful row, assign all values \"false\"\n    end else do\n      dateTime: false\n      chan1_volt: false\n      chan1_amps: false\n      chan1_KWH: false\n      chan1_avgKW: false\n      chan1_avgKVA: false\n      chan1_PF: false\n      chan1_KVAR: false\n      chan2_volt: false\n      chan2_amps: false\n      chan2_KWH: false\n      chan2_avgKW: false\n      chan2_avgKVA: false\n      chan2_PF: false\n      chan2_KVAR: false\n      chan3_volt: false\n      chan3_amps: false\n      chan3_KWH: false\n      chan3_avgKW: false\n      chan3_avgKVA: false\n      chan3_PF: false\n      chan3_KVAR: false\n      chan4_volt: false\n      chan4_amps: false\n      chan4_KWH: false\n      chan4_avgKW: false\n      chan4_avgKVA: false\n      chan4_PF: false\n      chan4_KVAR: false\n      chan5_volt: false\n      chan5_amps: false\n      chan5_KWH: false\n      chan5_avgKW: false\n      chan5_avgKVA: false\n      chan5_PF: false\n      chan5_KVAR: false\n    end\n    {ts:dateTime,chan1Volt:chan1_volt,chan1Amps:chan1_amps,chan1KWH:chan1_KWH,chan1AvgKW:chan1_avgKW,chan1AvgKVA:chan1_avgKVA,chan1PF:chan1_PF,chan1KVAR:chan1_KVAR,chan2Volt:chan2_volt,chan2Amps:chan2_amps,chan2KWH:chan2_KWH,chan2AvgKW:chan2_avgKW,chan2AvgKVA:chan2_avgKVA,chan2PF:chan2_PF,chan2KVAR:chan2_KVAR,chan3Volt:chan3_volt,chan3Amps:chan3_amps,chan3KWH:chan3_KWH,chan3AvgKW:chan3_avgKW,chan3AvgKVA:chan3_avgKVA,chan3PF:chan3_PF,chan3KVAR:chan3_KVAR,chan4Volt:chan4_volt,chan4Amps:chan4_amps,chan4KWH:chan4_KWH,chan4AvgKW:chan4_avgKW,chan4AvgKVA:chan4_avgKVA,chan4PF:chan4_PF,chan4KVAR:chan4_KVAR,chan5Volt:chan5_volt,chan5Amps:chan5_amps,chan5KWH:chan5_KWH,chan5AvgKW:chan5_avgKW,chan5AvgKVA:chan5_avgKVA,chan5PF:chan5_PF,chan5KVAR:chan5_KVAR}\n  end\n  \n  // Filter out unmeaningful rows of data to which we assigned false.\n  // Then turn it into a grid (above, the type was actually a list,\n  // even though the variable name was \"grid.\" This was because using\n  // list was easier to parse strings than grid.\n  data_grid_filtered: data_grid.findAll row => row->ts!=false\n  data_grid_filtered= toGrid(data_grid_filtered)\n  \n  // Filter out unused/irrelevant columns.\n  nullColNames: data_grid_filtered.colNames.findAll colName => do\n    data_grid_filtered.all row => row[colName] == null\n  end\n  polished_grid: data_grid_filtered.removeCols(nullColNames)\n  \n  // To avoid redundant history, (once new points are available) add\n  // the usual block of code that gets the hisEnd and filters out\n  // rows based on ts. Then write to points.\n  points: readAll(tonyTMP and point)\n  points.each pt => do\n  /* First \"if\" statement checks if there is already a\n    history associated with the point. The second checks\n    if there is a desired start date (from the input\n    aregument). Assign dates, clear history, and/or assign\n    hisEnd based on which of the 4 cases is presented\n    (noHis/his and noInput/input) */\n    hisEnd: pt[\"hisEnd\"]\n    today: now().date\n    if (hisEnd != null) do\n      if (restartDate != null) do\n        // his, input\n        hisClear(pt, restartDate..today)\n        hisEnd = dateTime(restartDate, time(0,0,0))\n        dates: restartDate..today\n      end else if (restartDate == null) do\n        // his, no input\n        dates: hisEnd.date..today\n      end\n    end else if (hisEnd == null) do\n      if (restartDate == null) do\n        // no his, no input\n        dates: pastWeek()\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end else if (restartDate != null) do\n        // no his, input\n        dates: restartDate..today\n        hisEnd = dateTime(dates.start,time(0,0,0))\n      end\n    end\n    \n    // Based on the results above, filter the grid.\n    date_filtered_grid: polished_grid.findAll row => row->ts > hisEnd\n    \n    // Write to voltage point.\n    if (pt->unit==\"V\") do\n      column_name: concat([channel,\"Volt\"])\n      voltage_grid: date_filtered_grid.keepCols([\"ts\",column_name])\n      voltage_grid= voltage_grid.reorderCols([\"ts\",column_name])\n      hisWrite(voltage_grid,pt)\n    end\n    // Write to current point.\n    if (pt->unit==\"A\") do\n      column_name: concat([channel,\"Amps\"])\n      current_grid: date_filtered_grid.keepCols([\"ts\",column_name])\n      current_grid= current_grid.reorderCols([\"ts\",column_name])\n      hisWrite(current_grid,pt)\n    end\n    // Write to energy point.\n    if (pt->unit==\"kWh\") do\n      column_name: concat([channel,\"KWH\"])\n      energy_grid: date_filtered_grid.keepCols([\"ts\",column_name])\n      energy_grid= energy_grid.reorderCols([\"ts\",column_name])\n      hisWrite(energy_grid,pt)\n    end\n  end\nend\n\n\n\n\n\n// ***If we want to replace C1607024- with some code to make it\n// more generalized, we can use:\n//     website_text_grid: ioReadLines(`http://dentmeter-test.lbl.gov/download_logged_data.html`)\n//     website_text_filtered:  website_text_grid.find row => reGroups(\"\"\"[A-Z]{1}\\\\d{7}\"\"\",row)!=null\n//     device_name: reGroups(\"\"\"[A-Z]{1}\\\\d{7}\"\"\",website_text_filtered)\n// and use device_name to replace C1607024. Alternatively, we could\n// make an input called device_name. It could be a point, and the\n// argument is a rec, and we would have to turn it into a string.\n\n\n// ioReadLines(`http://dentmeter-test.lbl.gov/` + reGroups(\"\"\"(above RegEx)\"\"\",ioReadLines(`http://dentmeter-test.lbl.gov/download_logged_data.html`).find row => row.contains(\"C1607024-\"))[0])\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldRequest",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Rolls up a time series in % to determine a final request value of 0 or 1.\n  Request is generated if values are greater than 95% and don't subsequently\n  go below 85% (release value for hysteresis). Typically used for damper\n  positions and other PID loop outputs to generate request for ASHRAE\n  Guideline 36 style trim-and-respond resets.\n*/\n\n(val, acc) => do\n  if (val == foldStart()) return {request:na(), trigger:95%, release:85%}\n  if (val == foldEnd()) return acc->request\n  // Skip invalid values, only if all values are na will the result be na\n  if (val == na() or val == null) return acc\n  \n  // Trigger\n  if (val >= acc->trigger) return {request:1,\n                                  trigger:acc->trigger,\n                                  release:acc->release}\n  // Release\n  if (val < acc->release) return {request:0,\n                                  trigger:acc->trigger,\n                                  release:acc->release}\n  // Hysteresis: pass through current value\n  return acc\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Gas Usage Norm (Btu/ft²)",,M,"Site gas consumption normalized by ft².",,,"site",,"kpiGasUsageNorm",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(site, dates) => do\n  pt: read(energy and delta and sensor and not hidden and equipRef->gas\n           and equipRef->siteMeter and siteRef==site->id\n           and not equipRef->duplicate, false)\n           \n  if (pt == null) return null\n\n  his: hisRead(pt, dates, {limit:null}).hisClip\n                         .energyNormByArea\n\n  if (his.isEmpty or\n      his.meta[\"hisEnd\"] < pt[\"hisStart\"] or\n      his.missing(\"v0\")) return null\n\n  kpiSum: his.foldCol(\"v0\", sum)\n  if (na() == kpiSum) null else {sum: kpiSum.as(1)}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["ruMeterAccDecreaseNotRollover"],,"Accumulator Zeroed",,M,"Accumulator was zeroed and zeroing did not meet rollover conditions",,,,,"ruMeterAccZeroNotRollover",,"meter","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(equip, dates, defaultMaxStep: 100) => do\n  // Get all accumulator points\n  accs: readAll(point and accumulator and sensor\n                and not virtual\n                and equipRef==equip->id)\n  if (isEmpty(accs)) return null\n  \n  nearZero: accs.hisRead(dates, {limit:null})\n      .hisRollup(min, 24hr)\n      .hisFindPeriods((val, ts, his) => do\n        rollover: his[\"rollover\"]\n        maxStep: his[\"maxAccStep\"]\n        if (rollover != null and maxStep == null)\n          maxStep= rollover / 10\n        if (maxStep == null)\n          maxStep= defaultMaxStep\n        \n        return (val >= 0) and (val <= maxStep)\n      end)\n  \n  decreaseNotRo: ruMeterAccDecreaseNotRollover(equip, dates)\n  \n  if (isEmpty(nearZero) or isEmpty(decreaseNotRo)) return null\n  return hisPeriodIntersection([nearZero, decreaseNotRo])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viZoneSummaryOverTime",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  reports: ioDir(`io/Reports/`).findAll(row => row->name.startsWith(\"B67_zone_report\"))\n  \n  reports= reports.map(file => do\n  \n    report: ioReadZinc(file->uri)\n    report= report.addCol(\n    colName: \"score_\"+reGroups(r\"B67_zone_report_(\\d{4}-\\d{2}-\\d{2}).zinc\", file->name)[1].split(\"-\").concat(\"\"),\n    z => do\n        g: if (z[\"airflowIssues\"] != null) z[\"airflowIssues\"] else 0\n        h: if (z[\"damperClosed\"] != null) z[\"damperClosed\"] else 0\n        i: if (z[\"damperFullOpen\"] != null) z[\"damperFullOpen\"] else 0\n        k: if (z[\"reheatLeak_orSensorCalib\"] != null) z[\"reheatLeak_orSensorCalib\"] else 0\n        l: if (z[\"sensorOutofRange\"] != null) z[\"sensorOutofRange\"] else 0\n        m: if (z[\"staleCommands\"] != null) z[\"staleCommands\"] else 0\n        n: if (z[\"staleSensors\"] != null) z[\"staleSensors\"] else 0\n        \n        s: g + max(h+i,m) + n + l + k\n    end)\n\n    {report: report.keepCols([\"id\",colName])}\n  end)\n  \n  summary: null\n  reports.each(r =>\n    if (summary == null) summary= r->report\n    else summary= join(summary, r->report, \"id\"))\n  \n  summary= summary.findAll(row => row.remove(\"id\").any(v => v > 0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"anAhuZoneDeltaTemps",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze terminal unit trends for all terminal units related to\n  given AHU and return historical trends of deviation from zone\n  deadband for all zones served by AHU.\n  \n  Can zero out value based on zone run cmd\n  Can specify max deviation (e.g. 10°F)\n  \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), maxDev: 5°F, rollup: 15min, zoneIdList: null, filterUnocc:true) => do\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve a grid of all supply terminal units associated with AHU\n  tus: readAll(supply and terminalUnit and ahuRef==ahuRef)\n  \n  // Optional filter by zone ID\n  if (zoneIdList != null)\n    tus= tus.findAll(row => zoneIdList.contains(row->equipRef))\n  \n  // Return null if no associated terminal units are found\n  if (isEmpty(tus)) return null\n  \n  // Cycle through zones and create history of cooling needs\n  devs: {}.toGrid()\n  tus.each(tu => do\n    // Find ZAT and ZAT cooling setpoint\n    coolSp: read(point and zone and air and temp\n                 and effective and cooling and sp\n                 and equipRef==tu->id, false)\n\n    heatSp: read(point and zone and air and temp\n                 and effective and heating and sp\n                 and equipRef==tu->id, false)\n\n    zat: read(point and zone and air and temp\n              and sensor\n              and equipRef==tu->id, false)\n              \n    occ: read(point and occupied\n              and cmd\n              and equipRef==tu->id, false)\n              \n    // If ZAT is missing, skip terminal unit\n    if (zat==null) return null\n    \n    // If any setpoint is missing, replace with ZAT (zero deviation)\n    if (coolSp==null) do\n      coolSp= zat\n      cool: \"-&\"\n    end else cool: \"C&\"\n    if (heatSp==null) do\n      heatSp= zat\n      heat: \"-\"\n    end else heat: \"H\"\n     \n    dis: if (tu.has(\"equipRef\"))\n           if (readAll(supply and terminalUnit and equipRef==tu->equipRef).size >= 2)\n             tu->equipRef->navName + \" \" + reGroups(\"\"\"(Supply )?(.*)\"\"\",tu->navName)[2]\n           else tu->equipRef->navName\n         else tu->navName\n    dis= dis + \" dT (\" + cool + heat + \")\"\n    \n    // Col name based on zone name\n    if (tu.has(\"equipRef\"))\n      colName: tu->equipRef->navName.toTagName()\n    else\n      colName: tu->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    hisGrid: [heatSp, zat, coolSp]\n             .hisRead(dates, {limit: null})\n\n    if (rollup > 0)\n      hisGrid= hisGrid.toolHisAlign(avg, max, true, rollup)\n    else\n      hisGrid= hisGrid.toolHisAlign(avg, max)\n    rollupTU: hisGrid.meta[\"hisRollupInterval\"]\n        \n    hisGrid= hisGrid\n    .renameCol(\"v0\",\"htg\")\n    .renameCol(\"v1\",\"zat\")\n    .renameCol(\"v2\",\"clg\")\n    .addCol(colName, row => do\n          if (row.remove(\"ts\").any(v => v==null or v==na()))\n            return null\n          else if (row[\"zat\"]==0)\n            return null\n          else do\n            zat: row[\"zat\"].to(\"°F\")\n            clg: row[\"clg\"].to(\"°F\")\n            htg: row[\"htg\"].to(\"°F\")\n            dev: min(maxDev,max(0, zat-clg).as(\"°F\"))\n                 + max(-maxDev,min(0, zat-htg).as(\"°F\"))\n            return dev\n          end\n        end)\n        .keepCols([\"ts\",colName])\n        .hisFindAll(val => val != null)\n        .addColMeta(colName, {dis: dis})\n        \n    // If occupancy is available and filterUnocc is true, remove zeros from deviations\n    // during unoccupied periods\n    if (occ != null and filterUnocc) do\n      occHis: occ.hisRead(dates, {limit: null})\n                 .hisMap(v => if (v==null) null else if(v) 1 else 0)\n                 .hisRollup(covAvg, rollupTU)\n      \n      if (occHis.has(\"v0\")) do                 \n        hisGrid= hisJoin([hisGrid, occHis])\n            .findAll(row => row[colName] != 0 or (row[\"v0\"] != null and row[\"v0\"]>0))\n            .keepCols([\"ts\",colName])\n      end\n    end\n        \n    // Add to devs summary array\n    if (isEmpty(hisGrid)) return null\n    if (isEmpty(devs)) devs=hisGrid\n    else devs= hisJoin([hisGrid, devs])\n  end)\n  \n  if (rollup==0)\n    devs= devs.toolHisAlign(avg, max)\n  return devs\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap34ARUNetworkPoints",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point (if any) stored in `io/integration_b34/b34_aru_3_4_integration.csv`\n to add these points to existing CH-2 and CH-3 equips.\n \n This file includes a match to the 2018-08-29 tagging standard for the\n purpose of associating the proper tags and navName to each point.\n*/\n\n() => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(`io/integration_b34/b34_aru_3_4_integration.csv`)\n  \n  siteId: @p:lbnl:r:22c3f305-88d0e22e\n  locationId: @p:lbnl:r:2319c0bc-f94a93c1\n  connectorId: @p:lbnl:r:23185140-3868cb8c\n  \n  bacnetLearn(connectorId)\n  bacnetTrendList: bacnetLearn(connectorId, 20)\n  if (isEmpty(bacnetTrendList)) return \"bacnetLearn failed\"\n  \n  bacnetLearn(connectorId)\n  bacnetPtList2: bacnetLearn(connectorId, 2)\n  if (isEmpty(bacnetPtList2)) return \"bacnetLearn failed\"\n  \n  bacnetLearn(connectorId)\n  bacnetPtList5: bacnetLearn(connectorId, 5)\n  if (isEmpty(bacnetPtList5)) return \"bacnetLearn failed\"\n  \n  // Two equips to fill out: CH-2 (ARU-3) & CH-3 (ARU-4)\n  [2,3].each aru => do\n    chillerEq: read(equip and chiller and \n                    locationRef->id==locationId and\n                    navName==\"CH-\"+aru)\n    \n    // Go through list of points of interest for each chiller\n    // and integrate\n    alcPtList.each row => do\n      ptDict: {point,\n               disMacro: \"\\\$equipRef \\\$navName\",\n               bacnetConnRef: connectorId,\n               connRef: connectorId,\n               equipRef: chillerEq->id,\n               his,\n               locationRef: locationId,\n               siteRef: siteId,\n               tz: \"Los_Angeles\"}\n      \n      if (row.has(\"bacnetCur\")) do\n        ptDict= ptDict.set(\"cur\", marker())\n        ptDict= ptDict.set(\"bacnetCur\", row->bacnetCur)\n        ptDict= ptDict.set(\"bacnetName\", row->bacnetDis)\n        \n        // If type is AV, add kind and unit\n        if (row->bacnetCur[0..1] == \"AV\") do\n          curInfo: bacnetPtList2.find(cur => cur[\"bacnetCur\"] == row->bacnetCur)\n          ptDict= ptDict.set(\"kind\", curInfo[\"kind\"])\n          ptDict= ptDict.set(\"unit\", curInfo[\"unit\"])\n        end\n        \n        // If type is BV, add kind and enum\n        if (row->bacnetCur[0..1] == \"BV\") do\n          curInfo: bacnetPtList5.find(cur => cur[\"bacnetCur\"] == row->bacnetCur)\n          ptDict= ptDict.set(\"kind\", curInfo[\"kind\"])\n          ptDict= ptDict.set(\"enum\", curInfo[\"enum\"])        \n        end\n\n      end\n      \n      disTarget: row->bacnetTrendDis + \"_\" + aru\n      bacnetHis: bacnetTrendList.find(row => row[\"dis\"] == disTarget)->bacnetHis\n      ptDict= ptDict.set(\"bacnetHis\", bacnetHis)\n      \n      ptDict= ptDict.set(\"tmp20180829\", marker())\n      \n      // Add tags and navName\n      tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n      ptDict = ptDict.set(\"navName\", tagRow->dis)\n      \n      // Get string with list of tags, iterate through it\n      tagSet: tagRow->tagsPtOnly.split(\",\")\n      tagSet.each tag => do\n        ptDict= ptDict.set(tag, marker())\n      end\n      \n      commit(diff(null, ptDict, {add}))\n    end\n  end\nend\n\n/*\nioReadCsv(`io/taggingStandard.csv`).findAll(row => row->index==\"1\")\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualReverse",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a Number virtual point of unit %\n  which equals 100% minus the value of the point which has a virtualRef equal\n  to the id of the virtual point. If several points have that virtualRef, only\n  one is used.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  pt: read(virtualRef==rec->id)\n  \n  if (pt.has(\"unit\") and pt->unit==\"%\") do\n    pt.hisRead(dates, {limit: null})\n      .hisMap(x => if (x==null) na() else 100% - x)\n      .each(row => if(row[\"v0\"] != null) yield(row->ts, row->v0))\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap33AHU",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n Use previously created list of trends of interest and associated\n point stored in `io/integration_b33/b33_ahu04.csv`\n to add these points to existing equips.\n \n This file includes a match to the 2018-12-07 (?) tagging standard for the\n purpose of associating the proper tags and navName to each point.\n Also includes equip id.\n*/\n\n(filePath: `io/integration_b33/b33_ahu04.csv`, connectorId: @p:lbnl:r:23a5737f-2c20758d,\n finalize: true) => do\n  tagStd: ioReadCsv(`io/taggingStandard.csv`)\n  alcPtList: ioReadCsv(filePath)\n  \n  siteId: @p:lbnl:r:21cd60fc-808d8404\n  \n  bacnetPtList: [null, null, null, null, null, null]\n  bacnetObjMap: [\"AI\", \"AO\", \"AV\", \"BI\", \"BO\", \"BV\"]\n  \n  [0,1,2,3,4,5].each type => do\n    bacnetLearn(connectorId)\n    learn: bacnetLearn(connectorId, type)\n    bacnetPtList= bacnetPtList.set(type, learn)\n  end\n  \n  alcPtList= alcPtList.addCol(\"newPt\", row => do\n    equip: readById(parseRef(row->eq))\n    equipId: equip->id\n    locationId: equip->locationRef->id\n    \n    // Get info from bacnetPtList by matching bacnetCur\n    curType: row->bacnetCur[0..1]\n    bacnetGrid: bacnetPtList[bacnetObjMap.index(curType)]\n    if (bacnetGrid == null) bacnetGrid= [].toGrid()\n    ptRowMatch: bacnetGrid.find(pt => pt[\"bacnetCur\"] == row->bacnetCur)\n    if (ptRowMatch == null)\n      ptRowMatch= {\"kind\": if (bacnetObjMap.index(curType) < 3) \"Number\" else \"Bool\"}\n    \n    // Prepare new point dict\n    ptDict: {point,\n             disMacro: \"\\\$equipRef \\\$navName\",\n             bacnetConnRef: connectorId,\n             connRef: connectorId,\n             cur,\n             bacnetCur: row->bacnetCur,\n             bacnetHis: row[\"bacnetHis\"], //optional\n             bacnetCurName: row->bacnetCurName,\n             bacnetHisName: row[\"bacnetHisName\"],\n             kind: ptRowMatch[\"kind\"], //optional\n             unit: ptRowMatch[\"unit\"], //optional\n             enum: ptRowMatch[\"enum\"], //optional\n             equipRef: equipId,\n             his,\n             notes: row[\"alcDisplay\"], //optional\n             locationRef: locationId,\n             siteRef: siteId,\n             tz: \"Los_Angeles\",\n             tmp: today()}\n               \n    // Set collection interval / cov if no bacnetHis\n    if (row[\"bacnetHis\"] == null)\n      if (ptRowMatch[\"kind\"] == \"Bool\") do\n        ptDict= ptDict.set(\"hisCollectCov\", marker())\n        ptDict= ptDict.set(\"hisCollectInterval\", 12h)\n      end else do\n        ptDict= ptDict.set(\"hisCollectInterval\", 15min)\n      end\n\n    // Add navName and meaningful tags from standard\n    tagRow: tagStd.find(tag => tag->index==row->indexTagStandard)\n    ptDict= ptDict.set(\"navName\", tagRow->dis)\n    tagSet: tagRow->tagsPtOnly.split(\",\")\n    tagSet.each tag => do\n      ptDict= ptDict.set(tag, marker())\n    end\n\n    // Commit if finalize == true\n    if (finalize) do\n      commit(diff(null, ptDict, {add}))\n    end\n\n    return ptDict\n  end) \n  \n  return alcPtList\nend\n \n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateDeficiencyNote",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  // Normalize action input\n  rec= actionNormInput(rec, \"dict\")\n  \n  if (not(rec.has(\"deficiencyRef\")) or rec[\"deficiencyRef\"]==\"\")\n    throw \"Reference to associated deficiency is required\"\n    \n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["viSystemPowerAndWetBulb"],,,,M,,,,,,"viSystemPowerWetBulbScatter_v2",,,"/*\n  Copyright 2020 Raphael Vitti, Sadie Joy\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Return scatter chart of 15-minute CT Fan Power, CW Pump Power \n  and TW Pump Power vs OA WB Temp data at B59 (in °F)\n*/\n\n(dateRangePre: toDateSpan(2019-06-01..2019-09-01),\n dateRangePost: lastWeek().toSpan(),\n minCompPower: null, maxCompPower: null,\n selectTrend: \"All\", rollup:15min) => do\n  // Load desired data from both date ranges\n  gridPre: viSystemPowerAndWetBulb(dateRangePre, minCompPower, maxCompPower,\n                                   rollup, \"Pre\")\n  gridPost: viSystemPowerAndWetBulb(dateRangePost, minCompPower, maxCompPower,\n                                    rollup, \"Post\")\n  \n  // Concatenate both history grids\n  allGrid: addRows(gridPre, gridPost).removeCol(\"ts\")\n  colNames: allGrid.colNames\n  allGrid= allGrid.reorderCols(colNames.moveTo(\"oaWetBulb\", 0))             \n  \n  // Format chart\n  graph: allGrid\n         .addMeta({chartType: \"scatter\",\n                   title: \"Components of Total System Power (Pre or Post)\"})\n         .addColMeta(\"oaWetBulb\", {chartMin: 35°F, chartMax: 70°F})\n         .addColMeta(\"twPumpPre\", \n                     {dis: \"Baseline TW Pump Power\",\n                      color: \"#B482D2\",\n                      chartMin: 0kW,\n                      chartMax: 300kW,\n                      chartGroup: \"all\"})\n         .addColMeta(\"ctFanPre\", \n                     {dis: \"Baseline CT Fan Power\",\n                      color: \"#F3D085\",\n                      chartGroup: \"all\"})\n         .addColMeta(\"trwPumpPre\",\n                     {dis: \"Baseline CW Pump Power\",\n                      color: \"#87B880\",\n                      chartGroup: \"all\"}) \n         .addColMeta(\"twPumpPost\", \n                     {dis: \"Recent TW Pump Power\",\n                      color: \"#6A04A5\",\n                      chartGroup: \"all\"})\n         .addColMeta(\"ctFanPost\", \n                     {dis: \"Recent CT Fan Power\",\n                      color: \"#E8A10B\",\n                      chartGroup: \"all\"})\n         .addColMeta(\"trwPumpPost\",\n                     {dis: \"Recent CW Pump Power\",\n                      color: \"#0E7101\",\n                      chartGroup: \"all\"}) \n  \n  //Select columns to include in graph based on filter\n  if(selectTrend == \"Tower Water Pump\")\n  graph = graph.keepCols([\"oaWetBulb\",\"twPumpPre\",\"twPumpPost\"])\n  \n  if(selectTrend == \"Cooling Water Pump\")\n  graph = graph.keepCols([\"oaWetBulb\",\"trwPumpPre\",\"trwPumpPost\"])\n  \n  if(selectTrend == \"Cooling Tower Fan\")\n  graph = graph.keepCols([\"oaWetBulb\",\"ctFanPre\",\"ctFanPost\"])\n  \n  return graph\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"suUpdateNavMeta",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  list: \"06,15,30,33,43,46,50s,54,62,66,67,77,84,90\"\n        .split(\",\")\n        \n  listIds: list.map(item =>\n             read(site and dis==item)->id.toStr\n           )\n  \n  strTarget: \"@\"+ listIds.concat(\",@\")\n  \n  commit(diff(read(navMeta),\n    {kpiTargetFilterDefault: strTarget\n    }\n  ))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptMetricsCoolingLoopPpue",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This virtual point function (hisFunc) calculated the cooling system\n  pPUE of the CRAY computers at B59, comparing the cooling systems (including \n  CRAY fan kW) with the CRAY compute kW.\n  \n  Arguments:\n  *** Typical arguments for hisFunc\n \n  // kW Engineering // RGV + SRJ // Last Update: 2019-04-22 //\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n\n  computerRef: rec->equipRef\n  computeMeter: read(meter and compute and equipRef==computerRef, false)\n  computePowerPt: read(power and sensor and equipRef==computeMeter->id, false)\n  fanMeter: read(meter and fan and equipRef==computerRef, false)\n  fanPowerPt: read(power and sensor and equipRef==fanMeter->id, false)  \n  \n  interval: rec->hisVirtualInterval\n  \n  //Name the locations for additional power trends needed\n  cwLocRef: @p:lbnl:r:2322ff61-f91a05fc\n  \n  \n  //Grab specific power trends for B59\n  cwPumpPowerPts:readAll(locationRef==cwLocRef\n                    and equipRef->pump\n                    and power\n                    and sensor)\n  \n  //hisRead and rollups for these histories\n  cwPumpPower: cwPumpPowerPts.hisRead(dates, {limit:null})\n                             .hisRollup(avg, interval)\n                             .hisFoldCols(sum)\n                             .renameCol(\"v0\",\"cwPump\")\n  \n  computePower: computePowerPt.hisRead(dates, {limit:null})\n                              .hisRollup(avg, interval)\n                              .renameCol(\"v0\",\"compute\")\n  \n  fanPower: fanPowerPt.hisRead(dates, {limit:null})\n                      .hisRollup(avg, interval)\n                      .renameCol(\"v0\",\"fan\")\n  \n  grid: hisJoin([cwPumpPower, computePower, fanPower])\n        .addCol(\"coolingppue\", row => do\n          if (row.any(v => v==null or v==na() or v==0)) return na()\n          else return ((row->compute + row->fan + row->cwPump) / row->compute).as(1)\n        end)\n        .each(row => yield(row->ts, row->coolingppue))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recEditConnPointCache",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(connPointCacheDict) => do\n  // Normalize\n  //dicts: actionNormInput(connPointCacheDict, \"dicts\")\n  \n  // Only allow for equipRef and tagSetRef to be set\n  //connPointCacheDict= connPointCacheDict.findAll(\n  //  (val,name) => [\"id\",\n  //                 \"equipRef\",\n  //                 \"tagSetRef\",\n  //                 \"connPointCache\"].contains(name)\n  //)\n    \n  // Validate record\n  //connPointCacheDict= recValidateConnPointCache(connPointCacheDict)\n\n  recEdit(connPointCacheDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anFumeHoodSash",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given fume hood, retrieve info regarding measured airflow, fume hood width,\n  and sash air velocity, and calculate corresponding sash opening height.\n  \n  Arguments: \n  fhRef              Reference of fume hood equip\n  dates              Span, dates to run analysis on\n  minAfTolerance     Number, relative tolerance around min airflow setpoint to\n                     consider sash is closed\n  airVelocityDefault Number in fpm, optional, fixed velocity to use\n                     (overrides measured velocity if available)\n*/\n\n(fhRef: @p:lbnl:r:239d9c78-7b679bce, dates: pastWeek(),\n minAfTolerance: 0.1, airVelocityDefault:null, minAirflow:null,\n commErrorsAsNaN: true) => do\n  // Retrieve fumeHood record\n  fumeHood: readById(fhRef)\n  \n  // Check that provided reference is for a fumeHood equip\n  if (not(fumeHood.has(\"fumeHood\") and fumeHood.has(\"size\")))\n    return null\n  \n  if (minAirflow==null)\n   minAirflow= if (fumeHood.has(\"minAirflow\")) fumeHood->minAirflow\n               else 0cfm\n  \n  // Retrieve needed values and points\n  width: fumeHood->size\n  velocity: read(face and air and speed and sensor and equipRef==fhRef, false)\n  airflow: read(air and flow and sensor and equipRef==fhRef, false)\n  \n  // If any is missing, return null\n  if (width==null) return null\n  if (airflow==null) return null\n  if (velocity==null) do\n    if (airVelocityDefault==null) return null\n    else pts: airflow\n  end else pts: [airflow, velocity]\n  \n  // Load history, create new column with sash height\n  his: pts.hisRead(dates, {limit:null})\n          .hisInterpolate()\n          .addCol(\"height\", row =>\n              do\n                if(row[\"v0\"] == null) return null else flow: row->v0\n                if(airVelocityDefault != null) airVelocity: airVelocityDefault\n                else if(row[\"v1\"] == null) return null\n                else airVelocity: row[\"v1\"]\n                if(airVelocity == na() or flow==na()\n                   or round(airVelocity)==0 or round(flow)==0)\n                  return if(commErrorsAsNaN) na() else null\n                area: (flow.to(\"cfm\") / airVelocity.to(\"ft/min\")).as(\"ft²\")\n                height: (area / width.as(\"ft\")).as(\"ft\").to(\"in\")\n                return if (flow < (minAirflow * (1 + minAfTolerance))) 0in\n                       else height\n              end\n                 )\n  \n  his= his.keepCols([\"ts\",\"height\"])\n          .addColMeta(\"height\", {dis: fumeHood.dis() + \" Sash Height\",\n                                 equipRef: fumeHood->id,\n                                 sash, height, virtual, sensor,\n                                 kind:\"Number\",unit:\"in\",\n                                 chartMin:0})\n  return his\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06VAVConnRefs",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/* After already establishing terminalUnit equips and their respective\nconnectors, create connRefs between the two. */\n\n() => do\n vavs: readAll(siteRef->dis==\"06\" and equip and terminalUnit)\n    .map(row => {id: row->id,\n                 vav: reGroups(r\"Supply (VAV-\\d\\d.-\\d\\d)\",row[\"navName\"])[1]})\n    .map(row => {id: row->id,\n                 connRef: readAll(conn and bacnetConn and siteRef->dis==\"06\")\n                            .find(co => co->dis.contains(row->vav))->id\n                })\n\n    vavs.each row => commit(diff(readById(row->id), \n                                 {connRef: row->connRef\n                                 }\n                                )\n                            )\n       \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgCacheCurHisMatches",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given BACnet connector, review previously cached objects. Attempt\n  to associate trend log objects with the corresponding object they are\n  logging, either using available BACnet \"LOG_DEVICE_OBJECT_PROPERTY\"\n  information, or by using matching criterias in\n  `io/config/curName_hisName.csv`\n  \n  When an association is made, store all trend log object info into the\n  corresponding bacnetCur cached object.\n*/\n\n(connRef) => do\n  // If record is passed instead of id, retrieve id\n  if (not(isRef(connRef)))\n    try connRef= connRef->id\n    catch return {error: \"Incorrect input argument. \"\n                  + \"Expected ID of a connector object.\"}\n                 .toGrid()\n  msg:\"\"               \n  // Load dependencies\n  try curNameTohisName: ioReadCsv(`io/config/curName_hisName.csv`)\n                        .colToList(\"regex\")\n  catch\n    return {error: \"io/config/curName_hisName.csv could not be loaded\"}.toGrid()\n  \n  // Obtain list of cached TL objects for connector\n  tls: readAll(connPointCache and connRef==connRef\n               and bacnetHis and not bacnetCur)\n               \n  // Obtain list of cached non-TL objects for connector\n  curs: readAll(connPointCache and connRef==connRef\n                and bacnetCur)\n  \n  // Cycle through nonTL objects and search for matches\n  curs.each cur => do\n    // Attempt match on bacnetCur or bacnetCurName\n    trendMatches: tls.findAll(tl => do\n      if ((tl[\"bacnetCurLog\"] != null) and (tl[\"bacnetCurLog\"]==cur[\"bacnetCur\"]))\n        return true\n      regexMatch: false\n      // bacnetCurName matches use a config file where regular expressions\n      // are defined to run on \"bacnetCurName:bacnetHisName\"\n      curNameTohisName.each(regex =>\n          if (regex.reMatches(cur[\"bacnetCurName\"]+\":\"+tl[\"bacnetHisName\"]))\n            regexMatch= true\n      )\n      return regexMatch\n    end)\n    \n    // If empty, skip, else sort by logging interval\n    if (not(isEmpty(trendMatches))) do\n      trendMatches= trendMatches\n      .sort((a,b) => do\n        aInt: if(a[\"bacnetLogInterval\"]==null or a[\"bacnetLogInterval\"]==0) 10day\n              else a[\"bacnetLogInterval\"]\n        bInt: if(b[\"bacnetLogInterval\"]==null or b[\"bacnetLogInterval\"]==0) 10day\n              else b[\"bacnetLogInterval\"]\n        return aInt <=> bInt\n      end) // sort\n      \n      // Select first TL object, shortest bacnetLogInterval\n      tl: trendMatches.first\n      tlR: tl.set(\"id\",null)\n             .set(\"mod\",null)\n             .set(\"dis\",null)\n             .set(\"bacnetCurLog\",null)\n      \n      // Combine with bacnetCur, and update matched TL\n      try do\n        commit(diff(cur, tlR))\n        commit(diff(tl, {bacnetCurLog:cur->bacnetCur}))\n      end catch\n        // If commit failed, OK, just skip\n        null\n    end\n  end\n  return msg\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ruAhuRunContinuously",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ahu, dates, maxTime: 22hr) => do\n  // get unit status (typically will be virtual, doesn't matter)\n  op: read(point and run and sensor and equipRef==ahu->id, false)\n\n  // get periods when ahu status is on for longer than maxTime\n  // (for spark rule: dates is one day only, so don't use a \n  // threshold >24hr)\n  if (op!=null) do\n    opDuration: op.hisRead(dates)\n      .hisFindPeriods(v0 => v0)\n      .foldCol(\"v0\",sum) // Join periods together\n      \n    if (opDuration >= maxTime) do\n      // Return all periods of operation\n      return(op.hisRead(dates).hisFindPeriods(v0 => v0))\n    else do\n      return(null)\n    end\n  end\n end\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign","toolRecursiveSearch","toolRecTags"],,,,M,,,,,,"ptVirtualByTags",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Determine identifying tags of virtual point, then search for\n  points with the same tags downstream of the equip tree with\n  toolRecursiveSearch. Use hisRollup and hisFold functions\n  specified by name (attached to virtual point) to align histories\n  then fold them.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n  \n  Tags:\n  - virtual\n  --- hisFunc\n  --- hisRollup function with (val, acc) arguments\n  --- hisFold function with (val, acc) arguments\n  - downstream points\n  --- N/A\n  [toolRecTags,toolRecursiveSearch,toolHisAlign]\n*/\n\n(rec, dates, opts, yield) => do\n  // Normalize to absolute ref (for old Historian)\n  rec= rec->id.readById\n  \n  // Determine identifying tags and create tags filter string\n  tagsSet: toolRecTags(rec)\n  tagsStr: tagsSet.concat(\" and \")\n  \n  // Determine rollup and fold functions\n  rollupFunc: eval(\"(val,acc)=>\"+rec->hisRollup+\"(val,acc)\")\n  foldFunc: eval(\"(val,acc)=>\"+rec->hisFold+\"(val,acc)\")\n  \n  // Look for non-virtual points with the same tags in equip tree\n  pts: toolRecursiveSearch(\n           rec->equipRef->id,                        // trunkRef\n           \"point and \"+tagsStr+\" and not virtual\",  // filterStr\n           [\"equipRef\"],                             // refTypes\n           5)                                        // maxDepth\n       // Ensure no infinite loop\n       .findAll(pt => pt->id != rec->id)\n  \n  // Read available history, align, fold, yield\n  hisGrid: pts.hisRead(dates, {limit:null})\n  hisGrid.toolHisAlign(rollupFunc, min,  // rollupFunc, intervalFunc\n                       true)             // removeMissing\n         .hisFoldCols(foldFunc)\n         .each(row => yield(row->ts, row->v0))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["calculateVirtualMeter"],,,,M,,,,,,"ptVirtualMeter",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n///\n///  ABANDONNED, see calculateVirtualMeter\n///\n\n/*\n\n This function calculates history for a virtual meter point based on\n the meter formulas stored in the meterFormula tag in zinc format\n at the meter / equip level\n  \n Limitation: meter formula can only change at midnight local time\n Limitation: global adders LNC1 not properly managed for power vs energy\n  \n Arguments:\n *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  // Determine point type (power or energy delta) and set filter tags and rollup function\n  if (rec.has(\"power\")) do\n    ptTags: \"power and not hidden and equipRef->link\"\n    rollupFunc: avg\n  end\n  if (rec.has(\"energy\")) do\n    ptTags: \"energy and delta and not hidden and equipRef->link\"\n    rollupFunc: sum\n  end\n  if (rec.has(\"uptime\")) do\n    ptTags: \"uptime and not hidden and equipRef->link\"\n    rollupFunc: sum\n  end\n\n  // Load formulas from associated meter, sort so oldest formula comes first\n  formulas: rec->equipRef->meterFormula.ioReadZinc()\n                                       .toGrid()\n                                       .sort(\"startInclusive\")\n  \n  // Convert dates object to dateSpan,\n  // so that start and end can be compared with date objects\n  dates=dates.toDateSpan\n\n  // Cycle through each formula, starting with the oldest and yield\n  // calculated values for requested dates on which a formula is valid\n  formulas.each formula => do\n  \n    // Latest formula will not have an end date,\n    // therefore if end date is missing, set end date to tomorrow\n    endExclusive: if (formula->endExclusive == \"\") today()+1day\n                  else formula->endExclusive\n    \n    // Check if any of the requested dates fall within the formula's\n    // validity period; if not, skip to next formula\n    if (dates.start < endExclusive and dates.end >= formula->startInclusive) do\n    \n      // Determine start and end dates of period for which history\n      // will be calculated using the current formula\n      startPeriod: [dates.start, formula->startInclusive].sort().last\n      endPeriod: [dates.end, endExclusive - 1day].sort().first\n      \n      // Create table of meters and multipliers from formula\n      meterOps: [0,1,2,3,4,5,6,7,8].toGrid.map((row, i) => do\n      \n        // Check each meterX column, and parse it if not empty\n        if (formula[\"meter\"+i] != \"\") do\n        \n          // Parse using regex\n          parsed: reGroups(\"\"\"(-?)(\\\\d{1,3}.\\\\d{1,2})\"\"\", formula[\"meter\"+i])\n          meterMult: if(parsed[1] == \"-\") -1 else 1\n          meterLink: parsed[2]\n          \n          // Find point with the required tags that belongs to meter\n          // with the requested link tag\n          pointRec: parseFilter(ptTags)\n                    .readAll()\n                    .find rec => rec->equipRef->link == meterLink\n                    \n          // Store record to linked meter point, and corresponding multiplier\n          {meter: i, pointRec: pointRec, meterMult: meterMult}\n        end\n      end\n      )\n      // meterOps grid is complete, contains point records and multipliers\n      \n      // Get global adder and multiplier from formula, cast unit for adder\n      globalMult: formula->globalMult\n      globalAdder: formula->globalAdder.as(rec->unit)\n      \n      // Create list of point records that are not null; we will need the\n      // histories from these points to calculate our virtual history\n      points: meterOps.colToList(\"pointRec\").findAll item => item != null\n      \n      // Load history for all required points, align timestamps and clip\n      histGrid: points.hisRead(startPeriod..endPeriod, {limit: null})\n                      .hisRollup(rollupFunc, interval)\n                      .hisClip()\n                      \n      // For each loaded timestamp, perform calculation of virtual history\n      // point and yield result\n      histGrid.each row => do\n      \n        // Apply required multiplier to each point, and sum them all up\n        val: meterOps.colToList(\"meterMult\")\n                     .map((mult, i) => mult * row[\"v\"+i])\n                     .fold(sum)\n                     \n        // Apply global multiplier and adder\n        val = val*globalMult + globalAdder\n        \n        // Yield resulting history point\n        yield(row->ts,val)\n      end\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06VAVEquip",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm #, VAV, and floor to create zones\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b6/b6_zone_equip.csv`)\n  siteId: read(site and dis==\"06\")->id\n  \n  file.each row => do\n    floor: \"B6 Floor \" + row->floor\n    floorId: read(location and siteRef->dis==\"06\" and\n                  dis==floor)->id\n    vav: \"Supply \" + row->vav\n    equip: \"Rm \" + row->equip\n    equipId: read(equip and siteRef->dis==\"06\" and \n                  locationRef->dis==floor and \n                  navName==equip)->id\n    exist: readAll(siteRef==siteId and \n                  locationRef==floorId and\n                  equip and\n                  navName==vav)\n                   \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: vav,\n         disMacro: \"\\\$equipRef \\\$navName\",\n         supply,\n         terminalUnit,\n         zone,\n         equip,\n         locationRef: floorId,\n         siteRef: siteId,\n         equipRef: equipId,\n         sadieTemp\n        },\n        {add}\n      ))\n    end\n  end\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tempBackfillModhopper",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Parses through the CSV filled with old data, \n  backfill on old data into SkySpark.\n  \n  2-3 min runtime, must run in Job, not Shell\n  \n  // LBNL // JS // Last Update: 2019-08-09 //\n*/\n\n(csv) => do\n\n\tfile: ioReadCsv(`` + \"io/modhopperBacklog/\" + csv)\n\tmeter: file.colNames[1]\n\t\n  grid: readAll(point and his and modhopperDevAddr and \n  equipRef==@p:lbnl:r:239c2df6-df69fec7)\n  \n  grid.each point => do\n    if (toTagName(point->navName)==meter) do  \n      list: []\n      file.each row => do\n        time: parseDateTime(row->timestamp, pattern: \"YYYY-MM-DD hh:mm\")\n        value: row.vals[1].parseFloat()\n        list = add(list, {ts: time, val: value})\n        end\n      hisWrite(list, point)\n      return \"Successful backlog for\" + point-> navName + \"!\"\n      end\n    end\n  return \"Can't find point in SkySpark builder / Name mismatch between CSV file and SkySpark point\"\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","toolRecTags"],,,,M,,,,,,"ptVirtualCombineSources",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Determine identifying tags of virtual point, then search for\n  points with the same tags downstream of the equip tree with\n  toolRecursiveSearch. Load historical data from all these points\n  and yield all available data.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n  \n  Tags:\n  - virtual\n  --- hisFunc\n  - downstream points\n  --- N/A\n*/\n\n(rec, dates, opts, yield) => do\n  // Normalize to absolute ref (for old Historian)\n  rec= rec->id.readById\n  \n  // Determine identifying tags and create tags filter string\n  tagsSet: toolRecTags(rec)\n  tagsStr: tagsSet.concat(\" and \")\n    \n  // Look for non-virtual points with the same tags in equip tree\n  pts: toolRecursiveSearch(\n           rec->equipRef->id,                        // trunkRef\n           \"point and \"+tagsStr,                     // filterStr\n           [\"equipRef\"],                             // refTypes\n           5)                                        // maxDepth\n       // Ensure no infinite loop\n       .findAll(pt => pt->id != rec->id)\n  \n  // Read available history\n  hisGrid: pts.hisRead(dates, {limit:null})\n  \n  // Create sorted grid of colNames and sourcePriority if it exists\n  sourceCols: hisGrid.removeCol(\"ts\").colNames\n  sourceGrid: sourceCols.map(colName => do\n    colMeta: hisGrid.col(colName).meta\n    return {\n      colName: colName,\n      priority: if (colMeta.has(\"sourcePriority\")) colMeta[\"sourcePriority\"]\n               else 100\n    }\n  end)\n  sourceGrid= sourceGrid.sort((a,b) => a->priority <=> b->priority)\n  \n  // Add an output column with values from highest-priority column for each row\n  hisGrid= hisGrid.addCol(\"output\", row => do\n    out: null\n    sourceGrid.each(s => if (row[s->colName]!=null and out==null) out=row[s->colName])\n    return out\n  end)\n  \n  // Yield output\n  hisGrid.each(row => if (row[\"output\"] != null) yield(row->ts, row->output))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"anAhuZoneOverconditioning",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Analyze terminal unit trends for all terminal units related to\n  given AHU and return historical trends of overcooling and overheating\n  based on deviation from setpoint, cooling PID loop and reheat valve\n  command.\n  \n  Can zero out value based on zone run cmd\n  Can specify max deviation (e.g. 10°F)\n  \n  Arguments: \n  ahuRef       ref, ID of the AHU\n  dates        dateSpan, dates of data to display\n  maxDev       number, cap deviation at this number\n  rollup       duration, interval for rollup of ZAT\n*/\n\n(ahuRef, dates: yesterday(), maxDev: 100, rollup: 15min, zoneIdList: null, filterUnocc:true) => do\n  // Input checks\n  maxDev= maxDev.as(\"_%°F\")\n\n  // Confirm ahuRef points to an AHU, otherwise exit\n  ahu:readById(ahuRef)\n  if (not(ahu.has(\"ahu\")))\n    return {error: \"No corresponding AHU found\"}\n           .toGrid()\n  \n  // Retrieve a grid of all supply terminal units associated with AHU\n  tus: readAll(supply and terminalUnit and ahuRef==ahuRef)\n  \n  // Optional filter by zone ID\n  if (zoneIdList != null)\n    tus= tus.findAll(row => zoneIdList.contains(row->equipRef))\n  \n  // Return null if no associated terminal units are found\n  if (isEmpty(tus)) return null\n  \n  // Cycle through zones and create history of cooling needs\n  devs: {}.toGrid()\n  tus.each(tu => do\n    // Find ZAT and ZAT cooling setpoint\n    coolSp: read(point and zone and air and temp\n                 and effective and cooling and sp\n                 and equipRef==tu->id, false)\n                 \n    coolPID: read(point and cool and pid and cmd\n                  and equipRef==tu->id, false)\n\n    heatSp: read(point and zone and air and temp\n                 and effective and heating and sp\n                 and equipRef==tu->id, false)\n    \n    rhvCmd: read(point and heat and valve and cmd\n                 and equipRef==tu->id, false)\n                \n    zat: read(point and zone and air and temp\n              and sensor\n              and equipRef==tu->id, false)\n              \n    occ: read(point and occupied\n              and cmd\n              and equipRef==tu->id, false)\n              \n    // If ZAT is missing, skip terminal unit\n    if (zat==null) return null\n    \n    // If any setpoint is missing, replace with ZAT (zero deviation)\n    coolCap: true\n    heatCap: true\n    if (coolSp==null or coolPID==null) do\n      coolSp= zat\n      coolPID= zat\n      coolCap= false\n      cool: \"-&\"\n    end else cool: \"C&\"\n    if (heatSp==null or rhvCmd==null) do\n      heatSp= zat\n      rhvCmd= zat\n      heatCap= false\n      heat: \"-\"\n    end else heat: \"H\"\n    \n    room: if (tu.has(\"equipRef\")) readById(tu->equipRef)\n          else tu\n    dis: if (readAll(supply and terminalUnit and equipRef==room->id).size >= 2)\n           room->navName + \" \" + reGroups(\"\"\"(Supply,? )?(.*)\"\"\",tu->navName)[2]\n         else room->navName\n    dis= dis + \" dT (\" + cool + heat + \")\"\n    \n    // Col name based on zone name\n    if (tu.has(\"equipRef\"))\n      colName: tu->equipRef->navName.toTagName()\n    else\n      colName: tu->navName.toTagName()\n    \n    // Read histories, combine, analyze\n    flags: [heatSp, rhvCmd, zat, coolSp, coolPID]\n        .hisRead(dates, {limit: null})\n        .renameCol(\"v0\",\"htgSp\")\n        .renameCol(\"v1\",\"htgOut\")\n        .renameCol(\"v2\",\"zat\")\n        .renameCol(\"v3\",\"clgSp\")\n        .renameCol(\"v4\",\"clgOut\")\n        .hisInterpolate()\n        .hisRollup(avg, rollup)\n        .addCol(colName, row => do\n          if (row.any(v => v==null) or row.any(v => v==na()))\n            return na()\n          else if (row[\"zat\"]==0)\n            return na()\n          else do\n            zat: row[\"zat\"].to(\"°F\")\n            clgSp: row[\"clgSp\"].to(\"°F\")\n            htgSp: row[\"htgSp\"].to(\"°F\")\n            clgOut: if(coolCap) row[\"clgOut\"].to(\"%\") else 0%\n            htgOut: if(heatCap) row[\"htgOut\"].to(\"%\") else 0%\n            dev: min(maxDev,max(0, (zat-htgSp)*htgOut).as(\"_%°F\"))\n                 + max(-maxDev,min(0, (zat-clgSp)*clgOut).as(\"_%°F\"))\n            return dev\n          end\n        end)\n        .keepCols([\"ts\",colName])\n        .hisFindAll(val => val != null)\n        .addColMeta(colName, {dis: dis})\n        \n    // If occupancy is available and filterUnocc is true, remove zeros from deviations\n    // during unoccupied periods\n    if (occ != null and filterUnocc) do\n      occHis: occ.hisRead(dates, {limit: null})\n                 .hisMap(v => if (v==null) null else if(v) 1 else 0)\n                 .hisRollup(covAvg, rollup)\n      \n      if (occHis.has(\"v0\")) do                 \n        flags= hisJoin([flags, occHis])\n            .findAll(row => row[colName] != 0 or (row[\"v0\"] != null and row[\"v0\"]>0))\n            .keepCols([\"ts\",colName])\n      end\n    end\n        \n    // Add to devs summary array\n    if (isEmpty(flags)) return null\n    if (isEmpty(devs)) devs=flags\n    else devs= hisJoin([flags,devs])\n  end)\n  \n  return devs\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"foldHisRequest",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Rolls up a time series in % to determine a final request value of 0 or 1.\n  Request is generated if values are greater than 95% and don't subsequently\n  go below 85% (release value for hysteresis). Typically used for damper\n  positions and other PID loop outputs to generate request for ASHRAE\n  Guideline 36 style trim-and-respond resets.\n*/\n\n(val, ts, acc) => do\n  if (val == foldStart()) return {request:na(), trigger:95%, release:85%}\n  if (val == foldEnd()) return acc->request\n  // Skip invalid values, only if all values are na will the result be na\n  if (val == na() or val == null) return acc\n  \n  // Trigger\n  if (val >= acc->trigger) return {request:1,\n                                  trigger:acc->trigger,\n                                  release:acc->release}\n  // Release\n  if (val < acc->release) return {request:0,\n                                  trigger:acc->trigger,\n                                  release:acc->release}\n  // Hysteresis: pass through current value\n  return acc\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viAhuOat",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given site, find all AHU OAT points.\n  Load and display historical data for all these points across\n  the given date span, plus the weather station OAT, plus\n  optional selected OAT points from other sites.\n  \n  Arguments: \n  siteRef       ref, id of the site\n  dates         dateSpan, dates of data to display\n  pointRef      (optional), ref, id of another OAT point\n*/\n\n(siteRef: read(site and dis==\"06\")->id,\n dates:yesterday()-2day..yesterday(),\n pointRef:null) => do\n  // Prepare parameters\n  if (pointRef==null or not(isRef(pointRef))) pointRef= 0\n  hideStation: pointRef!=0\n  if (isRef(siteRef)) site: readById(siteRef)\n  else return null\n  weatherRef: site->weatherRef\n  \n  grid: readAll((air and temp and sensor and weatherRef==weatherRef)\n                or (siteRef==siteRef and outside and air and temp and sensor and equipRef->ahu)\n                or id==pointRef)\n  .hisRead(dates, {limit:null})\n  \n  grid.colNames.each colName => do\n    if (grid.col(colName).meta.has(\"weatherRef\")\n        or grid.col(colName).meta[\"id\"]==pointRef) do\n      grid= grid.addColMeta(colName, {weatherPoint: null,\n                                      color: \"black\",\n                                      strokeWidth: 2})\n    if (grid.col(colName).meta.has(\"weatherRef\") and hideStation)\n      grid= grid.removeCol(colName)\n    end\n  end\n\n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolFindOrphans",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Browse all tags that end with \"Ref\" (regex \".*Ref\$\"), and check\n  that each value associated with those tags points to a valid object.\n  Return list of records with one or more invalid \"Ref\" tag.\n  \n  Arguments: \n  N/A\n*/\n\n() => do\n  // Initialize results grid\n  orphans: {}.toGrid()\n  \n  // Load all tags used in database, and filter based on regex\n  readAllTagNames(id)\n  .findAll(row => \".*Ref\\\$\".reMatches(row->name))\n  .colToList(\"name\")\n  .each refTag => do\n    readAll(parseFilter(refTag)).each rec => do\n      try readById(rec[refTag])\n      catch orphans= orphans.addRow({id:rec->id, failedRefName: refTag, failedRef: rec[refTag]})\n    end\n  end\n  \n  return orphans\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolFormatTrends","toolHisGridShowGaps","toolRecursiveSearch"],,,,M,,,,,,"viPUETrends",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays PUE trends with formatting.\n  \n  Arguments:\n  equipRef       Ref to an equip\n  pointsRefs     list of point IDs, display history for those points\n  span           period to display\n  hisInterval    PUE interval used for calculation (specific to points)\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n  deficiencies   Bool, whether to show deficiencies on graph\n  rules          Bool, whether to display results of sparkrules\n*/\n\n(equipRef:null, pointsRefs:[], span:today()-3day..today()-1day, hisInterval:15min,\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null, rules:true) => do\n  if (pointsRefs==null) pointsRefs=[]\n  \n  gridE: try toolRecursiveSearch(equipRef,\n               \"(pue and sensor and his and hisInterval==\"+hisInterval+\")\"+\n               \"or ((denominator or numerator) and sensor and his)\")\n         catch {}.toGrid()\n  \n  gridP: try readByIds(pointsRefs)\n         catch {}.toGrid()\n         \n  gridA: if(isEmpty(gridP)) gridE else gridE.addRows(gridP)\n  try grid: gridA.hisRead(span, {limit:limit})\n                 .hisRollup(avg, hisInterval)\n                 .toolHisGridShowGaps(hisInterval*1.01)\n  catch return null\n\n  // Format trends\n  grid= grid.toolFormatTrends(group, tagGroups, colorFilters, [], width)\n \n  // Display active sparkRules results\n  if (rules) do\n    targets: [equipRef]\n    pointsRefs.each ptRef =>\n      targets= targets.add(readById(ptRef)[\"equipRef\"])\n    targets= targets.findAll(v => v!= null).unique()\n    \n    ruHis: ruleSparks(targets, span, readAll(sparkRule))\n           .ruleSparkHis()\n    \n    grid= hisJoin([grid, ruHis])\n  end\n\n  return grid.addMeta({title:\"NERSC PUE trends. Gaps greater than 15 min in any of the inputs are shown.\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolGridProfiles"],,,,M,,,,,,"viHillLargePRBreakdown",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(span, rollup, stacked) => do\n  span= span.toDateSpan\n  \n  // Modify span for weekly display if needed\n  if (rollup==\"Weekly\") do\n    // Align start on previous Sunday, except if span.start is Sunday\n    sStart: span.start - weekday(span.start)\n    \n    // Align end on following Saturday, except is span.end is Saturday\n    sEnd: span.end + 6day - weekday(span.end)\n    \n    // New aligned span\n    span= sStart..sEnd\n  end\n  \n  // Determine best date format\n  if (rollup==\"Monthly\") sFormat: \"MMM\"\n  else sFormat: \"MMM D\"\n  \n  // If displaying duplicate dates (more than a year), add year to format\n  if ((span.start.format(\"MM-DD\")+\"-2000\").parseDate(\"MM-DD-YYYY\")\n      + (span.end - span.start + 1day)\n      > 2000-12-31)\n    sFormat= sFormat+\" ''YY\"\n\n  grid: readByIds([@p:lbnl:r:23ca88e1-a1ef4598,\n                   @p:lbnl:r:2365022e-e104e8ff,\n                   @p:lbnl:r:23f8b5ff-1a41cd80,\n                   @p:lbnl:r:23f8b6e9-bb73bddd])\n  .hisRead(span, {limit:null})\n  .hisRollup(sum, 1h)\n  .hisMap(v=>v.to(\"MWh\"))\n  .addCol(\"error\",row=>if(row[\"v0\"]==null or row[\"v1\"]==null) null else row[\"v0\"]-row[\"v1\"])\n  .addCol(\"other\",row=>if(row[\"v1\"]==null or row[\"v2\"]==null or row[\"v3\"]==null) null else row[\"v1\"]-row[\"v2\"]-row[\"v3\"])\n  .addColMeta(\"other\",{dis:\"3 Other Energy (MWh)\",color:\"green\",strokeWidth:2,chartGroup:\"submeters\"})\n  .addColMeta(\"error\",{dis:\"4 WAPA - ION Error (MWh)\",color:\"red\",strokeWidth:2,chartGroup:\"submeters\"})\n  .addColMeta(\"v2\",{dis:\"1 NERSC PR+OFF Energy (MWh)\",unit:\"MWh\",color:\"#33ccff\",strokeWidth:2,chartGroup:\"submeters\"})\n  .addColMeta(\"v3\",{dis: \"2 ALS PR Energy (MWh)\", unit:\"MWh\", color:\"#ffcc00\",strokeWidth:2,chartGroup:\"submeters\"})\n  .removeCols([\"v0\",\"v1\"])\n  \n  if ([\"Weekly Avg\",\"Weekly Min\",\"Weekly Max\"].contains(rollup)) do\n    rollupFunc: sum\n    profileFunc: if (rollup==\"Weekly Avg\") avg\n                 else if (rollup==\"Weekly Min\") min\n                 else max\n    grid= grid\n    .toolGridProfiles(\"Weekly\", 1hr, rollupFunc, profileFunc)\n  end else \n    grid= grid\n    .hisRollup(sum, if(rollup==\"Monthly\") 1mo else if(rollup==\"Weekly\") 1wk else 1day)\n    .addCol(\"ts2\",row => row->ts.format(sFormat))\n    .removeCol(\"ts\")\n    .renameCol(\"ts2\",\"ts\")\n  \n  grid= grid\n  .keepCols([\"ts\",\"v2\",\"v3\",\"other\",\"error\"])\n  .reorderCols([\"ts\",\"other\",\"v2\",\"v3\",\"error\"])\n  .addMeta({chartType: if(stacked==\"Stacked\") \"stackedBar\" else \"line\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","toolRecTags"],,,,M,,,,,,"ptVirtualEquipAverage",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  average value of all points which are in the same equip or\n  in a subequip and which share the same set of tags with the\n  virtual point.\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  tagsList: toolRecTags(rec)\n  equipId: rec->equipRef\n  filterStr: tagsList.concat(\" and \") + \" and point and not virtual\"\n  \n  pts: toolRecursiveSearch(equipId, filterStr)\n  \n  pts.hisRead(dates, {limit: null})\n     .hisInterpolate()\n     .hisMap(x => if (x==null) na() else x)\n     .hisFoldCols(avg)\n     .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptVirtualMin",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function calculates history for a virtual point as the \n  min value of all points which have a virtualRef equal\n  to the id of the virtual point\n\n  Arguments:\n  *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  rec = rec->id.readById  // Normalize to absolute ref (for Historian)\n  readAll(virtualRef==rec->id)\n         .hisRead(dates, {limit: null})\n         .hisInterpolate()\n         .hisMap(x => if (x==null) na() else x)\n         .hisFoldCols(min)\n         .each(row => if(row[\"v0\"] != na()) yield(row->ts, row->v0))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viTrendByDay",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays each day of trending data as a separate trend,\n  for the given point over the given period.\n  \n  Arguments: \n  ptRec     record (dict) for selected point\n  span      period to use to calculate profiles\n  interval  time interval to roll up and align data\n  chartType string, either \"area\", \"scatter\" or \"line\"\n*/\n\n(ptRec: readById(@p:lbnl:r:23301612-0c02de4b), span: pastMonth(),\n interval: 0min, chartType: null) => do\n  if (isRef(ptRec)) ptRec= readById(ptRec)\n  \n  data: ptRec\n        .hisRead(span, {limit:null})\n  \n  if (interval > 0 or ptRec.has(\"delta\"))\n    if (ptRec->kind==\"Bool\") do\n      rollupFunc: covAvg\n      effRollup: interval\n      data= data.hisMap(val => if (val) 100% else 0%)\n                .hisRollup(rollupFunc, effRollup)\n    end else do\n      rollupFunc: if (ptRec.has(\"delta\") or ptRec.has(\"energy\")) sum\n                  else avg\n      effRollup: if (interval>0) interval else 60min\n      data= data.hisRollup(rollupFunc, effRollup)\n    end\n  else effRollup: interval\n  \n  hisGrid: {}.toGrid()\n  \n  span.eachDay(day => do\n    subset: data\n        .findAll(row => date(row->ts)==day)\n        .map(row => if (row[\"v0\"]!=null)\n                      return {ts:time(row->ts)}\n                             .set(day.toStr.toTagName, row->v0)\n            )\n    \n    if (isEmpty(hisGrid)) hisGrid= subset\n    else hisGrid= hisGrid.join(subset, \"ts\")\n  end)\n  \n  rollupStr: if (effRollup==0) \", no rollup\"\n             else \", \" + effRollup + \" \"\n                  + reGroups(r\"(fold)?(.*)\\(.*\\).*\", rollupFunc.toStr)[2]\n                  + \" rollup\"\n  \n  if (chartType==null)\n    if (ptRec.has(\"chartType\")) chartType= ptRec->chartType\n    else chartType= \"line\"\n  \n  return hisGrid.reorderCols(hisGrid.colNames.moveTo(\"ts\",0))\n                .sort((a,b) => a->ts <=> b->ts)\n                .addMeta({chartType: chartType,\n                          title: \"Daily profiles for \"\n                                 + ptRec.dis() + rollupStr})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["hisFormula","toolHisAlign"],,,,M,,,,,,"hisWriteFormula",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Delete stored point history after startDate, recalculate and store.\n  This function calculates history for a virtual point using sums and\n  fixed multipliers specified in hisFormula records with pointRef\n  equal to the target virtual point.\n\n  Arguments:\n  ptId\n  startDate\n \n   Tags:\n  - virtual\n  --- hisRollup function with (val, acc) arguments\n  --- hisInterval (optional)\n  --- hisMissingVals (optional) hide / show / ignore\n  --- hisRecalculate (optional)\n*/\n\n(ptId, startDate:null) => do\n  rec: if (isRef(ptId)) readById(ptId) else ptId\n  if (rec.missing(\"hisRollup\")) return null\n  if (rec.has(\"connRef\") or rec.has(\"elasticMetric\")) return null\n  \n  // Load params from target point record\n  rollupFunc: eval(\"(val,acc)=>\"+rec->hisRollup+\"(val,acc)\")\n  minRollup: if (rec.has(\"hisInterval\")) rec->hisInterval else 0\n  hisMissingVals: if (rec.has(\"hisMissingVals\")) rec->hisMissingVals\n                  else \"hide\"\n  removeMissing: if (hisMissingVals==\"hide\") true else false\n  hisRecalculate: if (rec.has(\"hisRecalculate\")) rec->hisRecalculate else 0s\n  \n  // Find all source points that might be needed in formula\n  sourcePts: readAll(hisFormula and pointRef==rec->id)\n             .colToList(\"sourcePointRef\")\n  if (isEmpty(sourcePts)) return null\n  \n  // If startDate is null, use hisEnd\n  if (startDate==null) do\n    if (rec.missing(\"hisEnd\")) return null\n    hisEnd: rec->hisEnd + 1s - hisRecalculate\n  end else do\n    hisEnd: dateTime(startDate, time(0,0,0)) - 1s\n  end\n  calcSpan: hisEnd..now()\n  \n  // Erase existing history data, to be replaced\n  rec.hisRemove(calcSpan)\n  \n  // Determine target unit\n  tUnit: rec->unit\n  \n  // Process day by day\n  calcSpan.eachDay(day => do\n    // Load and align source data\n    hisGrid: sourcePts\n             .hisRead(day, {limit:null})\n             .hisMap(v => if (isNumber(v)) v.to(tUnit) else v)\n             .toolHisAlign(rollupFunc,\n                           min,            // intervalFunc\n                           removeMissing,  // removeMissing\n                           minRollup)      // minRollup\n             // toolHisAlign maintains NA, remove rows with NA\n             .findAll(r => r.all(v=> v != na()))\n    \n    // Stop processing day if source grid is empty\n    if (isEmpty(hisGrid.hisClip)) return null\n   \n    // store key between column name and point id\n    refKey: hisGrid.removeCol(\"ts\")\n            .colNames\n            .map(colName => \n                {colName:colName,\n                 id:hisGrid.col(colName).meta->id})\n    \n    // Row by row, process history grid of source points\n    // and apply appropriate formula\n    hisGrid= hisGrid.addCol(\"val\", row => do\n      appropriateFormula: hisFormula(row->ts, rec->id)\n      result: 0\n      \n      appropriateFormula.each(coeff => do\n        multiplier: coeff->multiplier\n        sourcePointRef: coeff->sourcePointRef\n        sourceColName: refKey.find(key => key->id==sourcePointRef)->colName\n        if (hisMissingVals==\"ignore\" and row[sourceColName]==na())\n          result= result\n        else\n          result= result + multiplier * row[sourceColName]\n      end)\n      \n      return result\n    end)\n    \n    hisGrid.keepCols([\"ts\",\"val\"])\n           .findAll(row => row.all(v => v!=null)\n                           and row->ts > hisEnd\n                           and row->ts < now())\n           .hisWrite(rec)\n  end)\n  \n  // Mark point with hisFormula tag\n  commit(diff(rec, {hisFromFormula,\n                    hisWarning: if(hisMissingVals==\"ignore\")\n                                  \"Missing values are ignored and count as zero in sum. \"\n                                  + \"Data quality could be compromised.\"\n                                else null,\n                    disMacro: if(hisMissingVals==\"ignore\")\n                                \"\\\$equipRef \\\$navName (Missing values are ignored)\"\n                              else rec->disMacro\n                   }))\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n    Added filtering to remove rows with any NA value (never removed by toolHisAlign)\n*/",,
,[],,,,M,,,,,,"tmpSetColEffZoneTempTL",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  csv: readLink(@p:lbnl:r:21827e46-8bf0cac5).ioReadCsv({noHeader})\n  \n  //TEST\n  readLink(@p:lbnl:r:21827e46-8bf0cac5).ioReadCsv({noHeader}).addCol(\"v2\", row => read(point and effective and zone and temp and sensor and bacnetCur==row->v0)->navName)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap74TUTsi",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Load csv with Rm # and floor to create terminal units\n*/\n\n() => do\n  file: ioReadCsv(`io/integration_b74/tsi_equip.csv`)\n  \n  siteDis: \"74\"\n  siteId: read(site and dis==siteDis)->id\n  \n  file.each row => do\n    floorDis: row[\"floor\"]\n    locationDis: \"B74 Floor \" + floorDis    \n    locationId: read(location and siteRef==siteId and\n                  dis==locationDis)->id\n    room: row[\"room\"]\n    roomDis: \"Rm \" + room\n    zoneId: read(zone and locationRef==locationId\n                 and navName==roomDis)->id\n                 \n    vavNum: reGroups(\"74-VAV-(\\\\d\\\\d\\\\d)\",row[\"vav\"])[1]\n    vavDis: \"Supply VAV-\" + vavNum\n    ahuNum: reGroups(\"74-AC-(\\\\d\\\\d\\\\d)\",row[\"ahu\"])[1]\n    ahuId: read(siteRef==siteId and ahu and equip\n                and navName==\"AC-\"+ahuNum)->id\n        \n    uriText: row[\"bacnetAddress\"]\n    uri: parseUri(uriText)\n    connRef: read(conn and bacnetConn and uri==uri)->id\n    \n    exist: readAll(siteRef==siteId and \n                   locationRef==locationId and\n                   equip and supply and terminalUnit\n                   and equipRef==zoneId\n                   and navName==vavDis)\n    \n    // Hot water reheat check\n    hhwReheat: true // All supply VAVs on TSI controllers have reheat\n    \n    // Exhaust TU check\n    exhaust: true // All supply VAVs on TSI controller have exhaust counterparts\n                  // Only one general exhaust per 8682, but only one will be \n                  // created due to isEmpty(existE) check\n   \n    // Create supply TU \n    if (isEmpty(exist)) do\n      commit(diff(\n        null,\n        {navName: vavDis,\n         disMacro: \"\\\$equipRef \\\$navName\",\n         ahuRef: ahuId,\n         connRef: connRef,\n         connInstance: row[\"instance\"],\n         supply,\n         terminalUnit,\n         equip,\n         hotWaterHeat: if(hhwReheat) marker() else null,\n         hotWaterPlantRef: @p:lbnl:r:23907277-80a8cbf3,\n         locationRef: locationId,\n         siteRef: siteId,\n         equipRef: zoneId,\n         tmp2:today()\n        },\n        {add}\n      ))\n    end else do\n      commit(diff(\n        exist[0],\n        {navName: vavDis,\n         disMacro: \"\\\$equipRef \\\$navName\",\n         ahuRef: ahuId,\n         connRef: connRef,\n         connInstance: row[\"instance\"],\n         controls: row[\"controlProg\"],\n         supply,\n         terminalUnit,\n         equip,\n         hotWaterHeat: if(hhwReheat) marker() else null,\n         hotWaterPlantRef: @p:lbnl:r:23907277-80a8cbf3,\n         locationRef: locationId,\n         siteRef: siteId,\n         equipRef: zoneId,\n         tmp2:today()\n        }\n      ))\n    end\n    \n    // Create exhaust TU\n    if (exhaust) do\n      exDis: \"Exhaust TU\"\n    \n      existE: readAll(siteRef==siteId and \n                      locationRef==locationId and\n                      equip and exhaust and terminalUnit\n                      and equipRef==zoneId\n                      and navName==exDis)\n                      \n      if (isEmpty(existE)) do\n        commit(diff(\n          null,\n          {navName: exDis,\n           disMacro: \"\\\$equipRef \\\$navName\",\n           equip,\n           equipRef: zoneId,\n           exhaust,\n           connRef: connRef,\n           terminalUnit,\n           locationRef: locationId,\n           siteRef: siteId,\n           tmp2:today()\n          },\n          {add}\n        ))\n    end\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolRecursiveSearch","facZoneClgReqIgnoresNow","foldRequest"],,,,M,,,,,,"facAhuRequestsNow",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given AHU, scan all zones served by the AHU for cooling PID loop outputs,\n  load recent trends (past 3h, adjustable) for each, and determine for each zone\n  whether the zone is requesting more cooling (with foldRequest).\n  Return total number of requests.\n\n  See:\n  https://docs.google.com/document/d/1N4GbHF4PvBYiJrxrfcE4FQK1JjH_Pak3svAbK1-fp2Q/\n  \n  Arguments: \n  ahuRef       Id of an ahu equip\n  ptTags       Str, tags of zone points to query for request generation\n  hystTime     Time, period considered in the hysteresis of the request generation\n  offlineTime  Time, allowed gap between latest data point and now(), zone doesn't\n               count if it's considered offline\n  ignoresEn    Bool, if true, check if generated requests should be ignored\n*/\n(ahuRef:@p:lbnl:r:22dc02cf-fb26e410, ptTags: \"cool and pid and cmd\",\n hystTime: 3hr, offlineTime: 30min, ignoresEn:true) => do\n  // Normalization\n  ahuId: if (isRef(ahuRef)) ahuRef else ahuRef->id\n  ahu: readById(ahuId)\n  \n  // Initialize requests\n  requests: 0\n  ignores: 0\n  reportingZones: 0\n  \n  // Determine tags for requests point and ignore function\n  if (ptTags==\"cool and pid and cmd\") do\n    reqPtTags: \"cool and air and request and cmd and not connRef\"\n    zoneReqIgnoreFunc: facZoneClgReqIgnoresNow\n  end else do\n    reqPtTags: null\n    zoneReqIgnoreFunc: null\n  end\n  \n  // Find all pid outputs using ptTags for terminal units served by AHU\n  zoneOutputs: readAll(parseFilter(ptTags+\" and equipRef->ahuRef==@\"+ahuId))\n  \n  // Loop through outputs and calculate request for each\n  zoneOutputs.each rec => do\n    his: rec.hisRead(now()-hystTime..now())\n    // If latest datapoint is too old, skip zone\n    if (isEmpty(his.findAll(r => r->ts > now()-offlineTime)))\n      return null\n    \n    // Else determine if a request is generated\n    else do\n      zoneReq: his.foldCol(\"v0\",foldRequest)\n      if (isNumber(zoneReq)) do\n        reportingZones= reportingZones + 1\n        requests= requests + zoneReq\n        \n        // Store request if point exists and isn't connected to BMS trend\n        writePt: if (reqPtTags==null) null\n                 else toolRecursiveSearch(rec->equipRef, reqPtTags).first\n        if (writePt!=null and jobIsRunning())\n          hisWrite({ts:now(), val:zoneReq.as(1)}, writePt)\n          \n        // Determine if request should be ignored\n        if (ignoresEn and zoneReqIgnoreFunc!=null) do\n          ignore: zoneReqIgnoreFunc(rec->equipRef, // zoneRef, but OK to use TU ID\n                                    30min,         // reqTime, not used here\n                                    24h,           // disqualTime\n                                    zoneReq)       // reqInput\n          if (isNumber(ignore))\n            ignores= ignores + ignore\n        end\n      end\n    end\n  end\n  \n  return {requests:        requests,\n          reportingZones:  reportingZones,\n          ignores:         ignores}\nend\n\n/*\n  Updates\n  2020-02-28   Added storage of zone request values, and processing of zone request\n               ignores, added ignoresEn input.\n  2020-03-02   Increased disqualification-from-spark time from 8h to 24h to properly\n               catch scheduled zones with leaky reheat valves.\n*/\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toAhuOutTemp"],,,,M,,,,,,"nonOptimalEconomizer",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(ahu, dates, minTime: 30min) => do\n\n// normalize minTime to hours\n  minTime = minTime.to(1h)\n\n  // get periods when cooling and heating\n\n  rat: read(air and \"return\" and temp and sensor and equipRef==ahu->id, false)\n  if (rat == null) return null\n  else rat= rat.hisRead(dates)\n  mat: read(air and mixed and temp and sensor and equipRef==ahu->id, false)\n  if (mat == null) return null\n  else mat= mat.hisRead(dates)\n  sat: read(air and discharge and temp and sensor and equipRef==ahu->id, false)\n  if (sat == null) return null\n  else sat= sat.hisRead(dates)\n  oat: toAhuOutTemp(ahu, false)\n  if (sat == null) return null\n  else oat = oat.hisRead(dates)\n // cool: read((cool or (chilled and water)) and valve and (cmd or sensor) and unit == \"%\" and equipRef==ahu->id, false).hisRead(dates).hisFindPeriods(x => x > 5%)\n  econ: read(outside and damper and cmd and unit and not minVal and equipRef==ahu->id, false)\n  if (econ == null) return null\n  else econ = econ.hisRead(dates).hisFindPeriods(x => x < 50%)\n  fan: read(discharge and air and fan and run and equipRef==ahu->id, false)\n  if (fan == null) return null\n  else fan= fan.hisRead(dates).hisFindPeriods(x => x == true)\n  \n  joined: hisJoin([rat, oat]).hisInterpolate()\n  \n    //finds difference in oat and rat\n  mapped: joined.map row => do\n            {\n            ts: row->ts,\n            v0: abs(row.get(\"v0\") - row.get(\"v1\"))\n            }\n          end\n  \n  spark1: mapped.hisFindPeriods(x => x >2)\n   \n  \n  // compute intersection of those periods\n  hisPeriodIntersection([spark1, econ, fan])\n    .findAll(r => r->v0 >= minTime)\n end\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,"Zone Heating with ZAT > HTG SP",,M,"Zone reheat valve command is greater than zero, despite zone air temp being higher than the heating setpoint for a given amount of time (default 1h)",,,,,"ruZoneHeatingSpIssue",,"equip and ((terminalUnit and supply) or zone)","/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  This function returns periods when a terminal unit's reheat valve\n  command is > 0% but the ZAT has been above the ZAT heating setpoint\n  for a given amount of time\n  \n  Arguments:\n  equip           equip record of equip to test airflow on\n  span            dateSpan, span of dates to run analysis on\n  tolerance       number, increases ZAT heating setpoint as additional\n                  tolerance to account for integral term\n  minOutput       number, minimum output above which we consider the\n                  reheat valve command is active\n  minTime         duration, filter out periods shorter than minTime\n  mergePeriod     duration, merge flagged periods separated by less than\n                  mergePeriod\n*/\n\n(equip, dates, tolerance: 0.1, minOutput: 1%,\n minTime: 2h, mergePeriod: 0min) => do\n  heatSP: read(point and zone and air and temp\n               and effective and heating and sp\n               and equipRef==equip->id, false)\n               \n  rhvCmd: read(point and heat and valve and cmd\n                and equipRef==equip->id, false)\n           \n  zat: read(point and zone and air and temp\n            and sensor\n            and equipRef==equip->id, false)\n            \n  // If any of these three points is missing, stop testing\n  if (heatSP==null or rhvCmd==null or zat==null) return null\n  \n  // Read history, combine\n  flagPeriods: [zat, heatSP, rhvCmd].hisRead(dates, {limit: null})\n      .hisInterpolate()\n      .addCol(\"flag\", row => do\n        if (row[\"v0\"]==null or row[\"v1\"]==null or row[\"v2\"]==null)\n          return null\n        else if ((row[\"v0\"] > (row[\"v1\"] + tolerance))\n                 and row[\"v2\"] > minOutput)\n          return 1\n        else return 0\n      end)\n      .keepCols([\"ts\",\"flag\"])\n      .hisFindAll(val => val != null)\n      .hisFindPeriods(val => val == 1)\n      \n  // Merge adjacent short periods, filter out remaining short periods\n  flagPeriods = hisPeriodShift(flagPeriods, -mergePeriod/2, mergePeriod/2)\n  flagPeriods = hisPeriodShift(flagPeriods, mergePeriod/2, -mergePeriod/2)\n  flagPeriods = flagPeriods.findAll(r => r->flag >= minTime)\n  \n  if (isEmpty(flagPeriods)) return null\n  \n  dis: equip->navName + \" is heating despite ZAT > HTG SP\"\n  return flagPeriods.addColMeta(\"flag\", {dis: dis})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recValidateTask",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(rec) => do\n  return rec\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["recValidateDeficiency"],,,,M,,,,,,"recNewDeficiency",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(deficiencyDict) => do\n  // Normalize action input\n  deficiencyDict= actionNormInput(deficiencyDict, \"dict\")\n  \n  if (deficiencyDict.has(\"equipRef\"))\n    deficiencyDict= deficiencyDict\n    .set(\"siteRef\", readById(deficiencyDict[\"equipRef\"])->siteRef)\n    .set(\"locationRef\", readById(deficiencyDict[\"equipRef\"])->locationRef)\n    .set(\"disMacro\", \"\\\$equipRef \\\$navName\")\n  else if (deficiencyDict.has(\"siteRef\")) do\n    siteRec: readById(deficiencyDict[\"siteRef\"])\n    deficiencyDict= deficiencyDict\n    .set(\"disMacro\", if (parseNumber(siteRec->dis, false)==null) \"\\\$siteRef \\\$navName\"\n                     else \"B\\\$siteRef \\\$navName\")\n  end\n  \n  deficiencyDict= deficiencyDict\n  .set(\"createdBy\", userCur()->dis)\n  .set(\"createdOn\", today())\n  .set(\"lastModifiedBy\", userCur()->dis)\n\n  deficiencyDict= deficiencyDict\n  .remove(\"deficiencyRef\")\n  .remove(\"hasResponses\")\n  .remove(\"link\")\n\n  // Validate record\n  deficiencyDict= recValidateDeficiency(deficiencyDict)\n\n  recNew(deficiencyDict)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"removeZeros",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n() => do\n  newPoints: readAll(point and equipRef==@p:lbnl:r:258e7b9c-0591c336)\n  .each(newPt => do\n    read(point and equipRef==@p:lbnl:r:258a7b11-f6e60b87 and navName==newPt->navName)\n    .hisRead(2014-01-01..today(),{limit:null})\n    .hisMap(v => if(v==0) return null else return v)\n    .hisFindAll(v => v!=null)\n    .hisWrite(newPt)\n    end)\n  \n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"intgUpdateConnCache",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given BACnet connector, use bacnetLearn to discover\n  all the points / objects accessible through the connector, and \n  store the corresponding records in the database with the tag\n  connPointCache for later, faster access.\n  \n  This function checks if an object already exists under the connector,\n  unique pairs are connector + dis\n*/\n\n(connRef) => do\n  // If record is passed instead of id, retrieve id\n  if (not(isRef(connRef)))\n    try connRef= connRef->id\n    catch return {error: \"Incorrect input argument. \"\n                  + \"Expected ID of a connector object.\"}\n                 .toGrid()\n    \n  // First bacnetLearn returns object types\n  try objectTypes: bacnetLearn(connRef).colToList(\"learn\")\n  catch return {error: \"First bacnetLearn failed on connector \"\n                + \"@\" + connRef.toStr()}\n  \n  // Cycle through object types\n  objectTypes.each type => do\n    try grid: bacnetLearn(connRef, type)\n    catch return null\n    \n    // Cycle through grid of objects\n    grid.each objDict => do\n      // If object has no \"dis\", skip it\n      if (not(objDict.has(\"dis\"))) return null\n    \n      // Depending on object type, add bacnetCurName or bacnetHisName\n      if (type==20)\n        objDict= objDict.set(\"bacnetHisName\",objDict->dis)\n      else\n        objDict= objDict.set(\"bacnetCurName\",objDict->dis)\n        \n      // Add / remove tags\n      objDict= objDict.set(\"connPointCache\",marker())\n                      .set(\"connRef\", connRef)\n                      .set(\"point\", null)\n    \n      // Check if there already exists a connPointCache record\n      prevRec: read(connPointCache and connRef==connRef and dis==objDict->dis,\n                    false)\n                    \n      // Update record or commit a new record\n      if (prevRec==null) do\n        // New record\n        commit(diff(null, objDict, {add}))\n      end else do\n        // Update existing record\n        commit(diff(prevRec, objDict))\n      end\n    end\n  end\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"ptGasVolumeToEnergy",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function calculates natural gas energy or power based on\n  natural gas volume or volume rate, respectively.\n  \n Source point needs to be tagged as reference within new virtual\n  point. Multipliers need to be provided as tags in parent equip.\n  \n Due to limitations in current units system, this function changes\n  the output unit to BTU/h, and this assumes the following input units:\n  - combEnergy in BTU\n  - combVolume in ft³\n  - rec in ft³ or cfh or cfm\n \n Arguments:\n *** Typical arguments for hisFunc\n*/\n\n(rec, dates, opts, yield) => do\n  combEnergy: rec->equipRef->combustionEnergy\n  combVolume: rec->equipRef->combustionVolume\n  combHeat: combEnergy / combVolume\n\n  // Check input unit to determine proper conversion of output\n  recUnit: readById(rec->pointRef)[\"unit\"]\n  if (recUnit==unit(1cfh)) do\n    unitIn: 1cfh\n    unitOut: 1BTU/h\n  end else if (recUnit==unit(1cfm)) do\n    unitIn: 1cfh\n    unitOut: 1BTU/h\n  end else if (recUnit==unit(1ft³)) do\n    unitIn: 1ft³\n    unitOut: 1BTU\n  end else do\n    unitIn: 1\n    unitOut: 1\n  end\n\n  rec->pointRef  // Source volume point\n    .hisRead(dates, {limit: null})\n    .hisMap(val => val.to(unitIn))\n    .each(row => yield(row->ts, (row->v0 * combHeat).as(unitOut)))\nend\n\n// if (number>30) do percentile:30\n// end else if (number<0) do percentile:0\n// end else do percentile:number end\n\n// cfh_BTU/ft³\n// unit(r[\"v0\"])==unit(1BTU/h)\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viOccAlwaysOn",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n This function returns a grid of occupancy sensor data from\n zones where occupancy is detected more than a certain percentage of the\n time (e.g. 90%) during the given time period; grid is optimized for use as a chart.\n \n Arguments:\n span      dateSpan, span of dates for which to return data\n threshold number, between 0 and 1 (0% and 100%)\n*/\n\n(span, threshold) => do\n  // Check inputs, prepare filters\n  if (threshold > 1) threshold= 1\n  if (threshold <0) threshold= 0\n  threshold= threshold.as(1) // Remove unit if any\n  span= span.toDateSpan\n  timeThreshold: (span.end - span.start + 1day) * threshold\n\n  data: readAll(zone and occupied and sensor and point)\n          .findAll(row => hisRead(row->id, span, {limit: null})\n                            .hisFindPeriods(p => p)\n                            .foldCol(\"v0\", sum) > timeThreshold)\n          .hisRead(span)\n\n  // Chart group by site\n  data.colNames()[1..-1].each colName => do\n    data = data.addColMeta(colName, {chartGroup: data.col(colName).meta->siteRef->dis})\n  end\n  \n  if (isEmpty(data)) data= read(zone and occupied and sensor and point)\n                             .hisRead(span)\n                             .addColMeta(\"v0\", {dis: \"All Occ Sensors OK\"})\n  \n  data= data.addMeta({title: \"Occupancy sensors that are ON more than \"\n                             + threshold*100 + \"% of the time\"})\n  \n  return(data)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["fandocRoomPressureReport"],,,,M,,,,,,"findRPRFieldValue",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/* This function is to check for empty fields in the Room Pressure Reports,\n  and if it is empty, return an empty string, and if it is filled, \n  it returns the value for that field\n  \n  This is a sub-function used in the fandocRoomPressureReport function\n*/\n(rpr, fieldname, ifEmpty:\"\") => do\n\n  if (rpr.has(fieldname)) \n    return get(rpr, fieldname)\n  else\n    return ifEmpty\nend\n\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toolHisRollupAuto",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Similar to hisRollupAuto, with custom processing of tags\n  \n  Arguments: \n  hisGrid        Grid with ts column and value columns\n  minRollup      Number (time), specify desired rollup interval\n*/\n\n(hisGrid, minRollup:0s) => do\n  if (minRollup <= 0) return hisGrid\n  \n  // Iterate on column names\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    // his is similar to the point record\n    try do\n      his: hisGrid.col(colName).meta\n      eq: readById(his->equipRef)\n    end catch\n      return null\n      \n    // If hide tag, skip\n    if (his.has(\"hide\")) return null\n    \n    // If kind==\"Bool\" or hisMode==\"cov\", skip\n    if (his[\"kind\"]==\"Bool\" or his[\"hisMode\"]==\"cov\") return null\n    \n    // Choose rollupFunc\n    rollupFunc: avg\n    if (his.has(\"delta\") and (his.has(\"volume\") or his.has(\"energy\")))\n      rollupFunc: sum\n    \n    // Extract single his\n    tmpGrid: hisGrid.keepCols([\"ts\",colName])\n                    .findAll(row => row[colName] != null)\n                    \n    // Rollup and merge back\n    tmpGrid= tmpGrid.hisRollup(rollupFunc, minRollup)\n                    .findAll(row => row[colName] != null)\n                    .addColMeta(colName,\n                      {dis: tmpGrid.col(colName).meta.dis() +\n                            \", \"+minRollup+\" Rollup\"})\n    hisGrid= hisJoin([hisGrid.removeCol(colName), tmpGrid])\n  end\n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"tmpMap06SREquip",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n// Create equips for B6 storage ring\n// Only bring in AHUs. AHU Manager will be created manually.\n\n() => do\n  equipGrid: ioReadCsv(`io/integration_b6/storage_ring_equip.csv`)\n  \n  equipGrid.each row => do\n    dict: {equip,\n           ahu,\n           chilledWaterCool,\n           chilledWaterPlantRef: @a,\n           navName: row->navName,\n           disMacro: \"\\\$locationRef \\\$navName\",\n           continuousOp: \"Supplies cooling for storage ring\",\n           locationRef: @p:lbnl:r:23133031-d5f4f137,\n           siteRef: @p:lbnl:r:211cc8a4-6dc3ebdd,\n           tmp20180827}\n           \n    commit(diff(null, dict, {add}))\n  end\n  \nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"toPlantLoad",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(plant, dates) => do\n\n  supply: read(equipRef==plant->id and (hot or chilled) and sensor and water and leaving, false)\n  if (supply == null) return null\n  else\n  supply = supply.hisRead(dates)\n  retrn: read(equipRef==plant->id and (hot or chilled) and sensor and water and entering, false)\n  if (retrn == null) return null\n  else\n  retrn = retrn.hisRead(dates)\n  gpm: read(equipRef==plant->id and (hot or chilled) and sensor and water and flow and sensor, false)\n  if (gpm == null) return null\n  else\n  gpm = gpm.hisRead(dates)\n  \n  //collect staegUp sp for selected dates\n  stageUp: read(stageUp and sp and unit == \"ton\" and equipRef == plant->id, false)\n  if (stageUp == null) return null\n  else\n  stageUp = stageUp.hisRead(dates)\n  \n  //calculate load based on flow and deltaT and add it to grid\n  load: hisJoin([supply, retrn, gpm, stageUp]).addCol(\"load\", row => if (row.has(\"v0\") and row.has(\"v1\") and row.has(\"v2\")) \n  (abs(row[\"v1\"]-row[\"v0\"])*500*row[\"v2\"]/12000)\n  .to(\"tons\"))\n  .hisInterpolate()\n  \nreturn load\n\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,["toolHisAlign"],,,,M,,,,,,"toolGridProfiles",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Convert a history grid to a new grid of value profiles per\n  period. Profiles can be averaged, min or max. Profiles can\n  be calculated over entire week-long period, or for daily\n  periods (weekday, weekend or both)\n  \n  Arguments:\n  grid          grid to convert\n  period        Str, describes averaging period:\n                Weekly, Daily, Daily (weekends), Daily(weekdays)\n  rollup        Number, time, rollup period\n  rollupFunc    Function for rollup (default avg)\n  profileFunc   Function for profiling (default avg)\n  filterFunc    Function (optional), applied through hisFindAll\n                before any other operation takes place\n*/\n\n(grid, period:\"Weekly\", rollup:1hr,\n rollupFunc:avg, profileFunc:avg, filterFunc: x=>true) => do\n  // Determine ts format\n  tsFormat: if (period==\"Weekly\") \"WWW ka\"\n            else \"hh:mm\"\n\n  // Perform rollup\n  grid= grid.hisFindAll(filterFunc)\n            .toolHisAlign(rollupFunc, min, true, rollup)\n\n  // Apply filtering and formatting\n  if (not(grid.has(\"ts\"))) return null\n  grid= grid.addCol(\"tsP\", row => do\n    if (period==\"Daily (weekends)\" and isWeekday(row->ts))\n      return null\n    if (period==\"Daily (weekdays)\" and isWeekend(row->ts))\n      return null\n    return row->ts.format(tsFormat)\n  end)\n  \n  // List of non-ts column names\n  aCols: grid.colNames\n  vCols: aCols.remove(index(aCols, \"ts\"))\n  vCols= vCols.remove(index(vCols, \"tsP\"))\n  \n  // Group by new ts\n  newGrid: {}.toGrid()\n  grid.colToList(\"tsP\")\n      .findAll(v => v!=null)\n      .unique().each tsP => do\n    dict: {ts: tsP}\n    fGrid: grid.findAll(row => row->tsP==tsP)\n    vCols.each vCol =>\n      dict= dict.set(vCol,\n                     fGrid.foldCol(vCol, profileFunc))\n    newGrid= newGrid.addRow(dict)\n  end\n  \n  // Add meta back\n  vCols.each vCol =>\n    newGrid= newGrid.addColMeta(vCol,\n                     grid.col(vCol).meta)\n  \n  return newGrid.reorderCols([\"ts\"].addAll(vCols))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"viDailyBreakdown",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display a stacked bar chart showing the breakdown of energy usage\n  over an average day for a given meter into the usage of its\n  submeters. Also displays a line chart showing the meter usage and \n  the error between the meter and the total of available submeter usage.\n\n  Arguments: \n  meterRef\n  span\n  daytype\n  stacked\n*/\n\n(meterRef:read(siteMeter and elec and meter and siteRef->dis==\"30\")->id,\n span:pastMonth(), daytype: \"Weekday\", stacked: true) => do\n    // Parameters\n    interval: if (stacked) 1h else 15min // 24 bars in one chart works well\n    dayType: if (daytype==\"Weekday\") \"weekday \"\n             else if (daytype==\"Weekend\") \"weekend \"\n             else \"\"\n    \n    // Inline functions\n    maxRound: x => do y:if(x<100) 10 else if(x<250) 50 else 100; ceil(x/y)*y end\n    \n    // If no submeters, exit\n    ptType: if (stacked) \"energy and delta and not hidden\"\n            else \"power and not hidden\"\n    filterStr: ptType + \" and (equipRef->submeterOf==@\" + meterRef\n                      + \" or equipRef->meterRef==@\" + meterRef + \")\"\n    submeterPts: readAll(parseFilter(filterStr))\n    if (isEmpty(submeterPts))\n        return {empty: \"The selected meter has no submeter\"}\n               .toGrid()\n    unit: submeterPts.first->unit\n \n    // Main meter history\n    meterUsage: read(energy and delta and not hidden and equipRef==meterRef)\n    mHis: meterUsage.hisRead(span, {limit: null})\n                    .findAll(row => if (daytype==\"All\") true\n                                    else if (daytype==\"Weekday\") isWeekday(row->ts)\n                                    else isWeekend(row->ts))\n                    .hisRollup(if(stacked) sum else avg, interval)\n                    .hisDailyProfile(avg)\n                    .map(row => {time: time(row->time.hour(),30), v0: row[\"v0\"]})\n    cMax: mHis.foldCol(\"v0\",max).maxRound()\n \n    submHis: submeterPts.hisRead(span, {limit: null})\n    submHis= submHis.findAll(row => if (daytype==\"All\") true\n                                    else if (daytype==\"Weekday\") isWeekday(row->ts)\n                                    else isWeekend(row->ts))\n    colNames: submHis.colNames.findAll(v => v != \"ts\")\n    \n    // Prepare chart\n    submStackedHis: submHis.hisRollup(if(stacked) sum else avg, interval)\n                           .hisDailyProfile(avg)\n    colNames.each colN => do\n      col: submStackedHis.col(colN)\n      submStackedHis= submStackedHis.addColMeta(colN,\n        {chartType: if (stacked) \"stackedBar\" else \"line\",\n         dis: if (reMatches(r\".* - (.*)\", col.meta->equipRef->navName))\n                reGroups(r\".* - (.*)\", col.meta->equipRef->navName)[1]\n              else col.meta->equipRef->navName,\n         chartGroup: \"breakdown\",\n         chartMin: 0.as(unit),\n         chartMax: if(stacked) cMax.as(unit) else null\n        })\n    end\n    \n    title: if (stacked) readById(meterRef).dis + \", \" + dayType\n                + \"average usage profile and stacked disaggregation\" \n           else \"Submeters of \" + readById(meterRef).dis + \", \" + dayType\n                + \"average power profile\"\n    \n    submStackedHis= submStackedHis.addMeta({title: title})\n        \n    if (not(stacked)) return submStackedHis\n    \n    // Prepare line chart with aggregation error    \n    combinedDailyHis: submHis.hisRollup(if(stacked) sum else avg, interval)\n                             .hisDailyProfile(avg)\n                             .foldCols(colNames, \"combined\", sum)\n                             .map(row => {time: time(row->time.hour(),30),\n                                          combined: row->combined})\n                    \n    combinedHis: hisJoin([combinedDailyHis, mHis])\n                 .addCol(\"error\", row => row[\"v0\"]-row[\"combined\"])\n                 .addColMeta(\"v0\", {\n                     dis: \"Meter, selected\",\n                     chartGroup: \"breakdown\",\n                     chartMin: 0.as(unit),\n                     chartMax: cMax.as(unit),\n                     color:\"#000000\"})\n                 .addColMeta(\"combined\", {\n                     dis: \"Submeters, combined\",\n                     chartGroup: \"lines\",\n                     chartMin: 0.as(unit)})\n                 .addColMeta(\"error\", {\n                     dis: \"Total unmetered or error\",\n                     chartType: \"area\",\n                     chartGroup: \"lines\",\n                     chartMin: 0.as(unit),\n                     chartMax: cMax.as(unit),\n                     color: \"#e85c5c\"})\n                 .removeCol(\"combined\")\n    \n    return hisJoin([submStackedHis,combinedHis])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"recMarkMonthlyReadNonroutine",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Assign ignore:\"Nonroutine\" tag to selected monthly read.\n  \n  Arguments:\n  sel        Selection, id of monthly read to edit.\n*/\n\n(sel) => do\n  // Normalize action input\n  sel= actionNormInput(sel, \"id\")\n  \n  // Edit record\n  rec: readById(sel)\n  rec= rec.set(\"ignore\",\"Nonroutine\")\n  \n  // Submit change\n  recEdit(rec)\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,
,[],,,,M,,,,,,"boilerFail",,,"(boiler, dates) => do\n\n//Find when any alarm point = true \nspark: readAll(point and alarm and hisSize and equipRef==boiler->id).hisRead(dates).hisFindPeriods(x => x)\n\nend\n",,
,["syncALC","syncALCSecondary"],,,,M,,,,,,"syncALC_grid",,,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(alcGrid) => do\n  grit: []\n  alcGrid.each row => do\n  try do\n     syncALCSecondary(row)\n   end catch (ex) do\n     grit = grit.add({name: row->navName, error: ex})\n   end// end try\n   \n  end// end each\n  return grit\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",,

