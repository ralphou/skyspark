ver:"3.0"
appName,depends,dependsFiles,dis,func,name,order,src,view
,[],,,M,"foldSample",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  if (val == foldStart()) return {v0: null}\n  if (val == foldEnd()) return acc[\"v0\"]\n  if (val == na() or acc[\"v0\"]==na()) return {v0: na()}\n  if (val == null) return acc\n  return {v0: val}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
"trendAnalysis",["toolFormatTrends","viZoneTrends_v2","viZoneTrends","recNewToolFormatTrendsOptions"],,"Zone Trends",,,1,"view: {inherit:\"chart\"}\nzoneRef: {var kind:\"Ref<zone>\" input navAuxFilter:\"equip and not equipRef\"}\nspan: {var kind:\"Span\" input defExpr:\"(yesterday()-2day..yesterday()).toSpan()\" navAuxFilter:\"equip\"}\ntime: {var kind:\"Time[]\" input defVal:[00:00:00,23:59:59]}\nptsSelect: {var enum:\"Typical Points,ZAT Controls,All Points\" kind:\"Str\" input defVal:\"Typical Points\"}\nsummarizeTrends: {var enum:\"All Trends,Summary Trends\" kind:\"Str\" input defVal:\"Summary Trends\"}\nfaults: {var enum:\"All Faults,Summary Faults,Hide Faults\" kind:\"Str\" input defVal:\"Summary Faults\"}\ngroupSelect: {var enum:\"Typical Groups,By unit,By equip,By equip and unit,By tags,By equip and tags\" kind:\"Str\" input defVal:\"Typical Groups\"}\nrollupSelect: {var enum:\"Auto Rollup,Minimum 1min,Minimum 5min,Minimum 10min,Minimum 15min\" kind:\"Str\" input defVal:\"Auto Rollup\"}\noptions: {dis:\"Reset Options\" refresh action:\"recNewToolFormatTrendsOptions\" templateName:\"toolFormatTrendsOptions\"}\ndata: {expr:\"viZoneTrends_v2({{zoneRef}},dateTime({{span}}.toDateSpan().start(),{{time}}[0],now().tz)..dateTime({{span}}.toDateSpan().end(),{{time}}[1],now().tz),{{ptsSelect}},{{summarizeTrends}}==\\\"Summary Trends\\\",{{faults}},{{groupSelect}},{{rollupSelect}})\"}\n","zoneTrendsV2"
,["toolFormatTrends","toolHisGridShowGaps","viTargetsDeficiencies","toolRecursiveSearch","foldAny","toolHisFoldColsByTags","toolHisRollupAuto"],,,M,"viZoneTrends_v2",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Display data trends associated with a given zone, and SAT and DSP\n  trends from the AHU associated with the first VAV equip that serves\n  that zone.\n  \n  Option to display all points in sub-equips or summary points.\n  \n  Format trends and return as chart grid.\n  \n  Arguments: \n  zoneId          Id, reference to zone equip\n  dates           DateSpan, dates of data to display\n  ptsSelect       String, \"All\" or \"Typical\", describes points to display\n  summarizeByTags Bool, if true, use pre-programmed folds by tags\n  faults          Str, if \"Summary Faults\", show one summary of all sparked rules \n                  and one summary of all deficiencies. If \"All\", show all the\n                  sparked rules and all the active deficiencies.\n  groupSelect     Str\n*/\n\n(zoneId, span: today()-3day..today()-1day,\n ptsSelect: \"Typical Points\", summarizeByTags: true,\n faults: \"Summary Faults\", groupSelect: \"Typical Groups\",\n rollupSelect: \"Auto Rollup\") => do\n  // Parameters\n  maxGap: 30min\n  \n  // Load toolFormatTrendsOptions parameters\n  defaultOpts: read(toolFormatTrendsOptions and default)\n  userOpts: try read(toolFormatTrendsOptions\n                     and username==userCur()->username)\n            catch {}\n  \n  // Options processing\n  if (rollupSelect==\"Minimum 1min\") minRollup: 1min\n  else if (rollupSelect==\"Minimum 5min\") minRollup: 5min\n  else if (rollupSelect==\"Minimum 10min\") minRollup: 10min\n  else if (rollupSelect==\"Minimum 15min\") minRollup: 15min\n  else minRollup: 0min\n \n  // Attempt to find zone, exit if no zone found\n  zone: if (isRef(zoneId)) readById(zoneId) else zoneId\n  if (not(zone.has(\"zone\")))\n    return {error: \"Selected record is not a zone\"}.toGrid()\n  \n  // Point selection\n  zonePtsStr: if (ptsSelect==\"All Points\")\n                \"point and not raw\"\n              else if (ptsSelect==\"ZAT Controls\")\n                \"((air or slab) and temp) \" +\n                \"or (water and temp and (entering or leaving))\" +\n                \"or (flow and (equipRef->supply or supply)) \" +\n                \"or (valve or ((cool or heat) and pid))\"\n              else if (ptsSelect==\"Typical Points\")\n                \"(damper or valve or ((air or slab) and temp) \" +\n                \"or (flow and not equipRef->zone) \" +\n                \"or (pressure and not cmd) \" +\n                \"or (zone and occupied and sensor))\"\n  \n  // Retrieve recs of all points in zone or sub-equips that match\n  // string filter zonePtsStr\n  subPts: toolRecursiveSearch(zone->id, zonePtsStr)\n  \n  // Find the AHU associated with the 1st supply terminal unit in zone\n  supplyTUs: readAll(supply and terminalUnit and ahuRef and equip\n                     and (equipRef==zone->id or zoneRef==zone->id))\n  if (isEmpty(supplyTUs)\n      or supplyTUs.first[\"ahuRef\"]==null\n      or ptsSelect==\"ZAT Controls\")\n    graphPts: subPts\n  else do\n    ahuId: supplyTUs.first->ahuRef\n    ahuPts: readAll(point and his and not raw\n                    and discharge and air and (temp or pressure)\n                    and equipRef==ahuId)\n    graphPts: subPts.addRows(ahuPts)\n  end\n  \n  // Load trend history and apply minimum rollup if > 0\n  hisGrid: graphPts.hisRead(span, {limit: null})\n\n  // Exit if no trends were found\n  if (isEmpty(hisGrid)) return null\n\n  // Create summary points as needed\n  if (summarizeByTags) do\n    hisGrid= hisGrid\n    .toolHisFoldColsByTags(tagsFilter: \"flow\",\n        foldFunc: sum, rollupFunc: avg, minRollup, removeMissing: true)\n    .toolHisFoldColsByTags(tagsFilter= \"temp\",\n        foldFunc= avg, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(tagsFilter= \"damper\",\n        foldFunc= max, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(tagsFilter= \"valve\",\n        foldFunc= max, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(tagsFilter= \"pressure and not request\",\n        foldFunc= avg, rollupFunc= avg, minRollup, removeMissing= true)\n    .toolHisFoldColsByTags(\"occupied\",           // tagsFilter\n                           foldAny, foldAny,     // foldFunc, rollupFunc\n                           minRollup, true)      // minRollup, removeMissing\n    .toolHisFoldColsByTags(\"request\",            // tagsFilter\n                           sum, avg,             // foldFunc, rollupFunc\n                           minRollup, true)      // minRollup, removeMissing\n    .toolHisFoldColsByTags(\"air and speed\",      // tagsFilter\n                           avg, avg,             // foldFunc, rollupFunc\n                           minRollup, true)      // minRollup, removeMissing\n  end\n  \n  // Show data gaps and apply minRollup\n  hisGrid= hisGrid.toolHisGridShowGaps(maxGap)\n                  .toolHisRollupAuto(minRollup)\n\n  // Add detected periods from sparkRules\n  ruHis: if (isEmpty(toolRecursiveSearch(zone->id, \"equip\"))) {}.toGrid\n         else ruleSparks(toolRecursiveSearch(zone->id, \"equip\"),\n                         span, readAll(sparkRule))\n              .ruleSparkHis()\n  \n  if (faults==\"Summary Faults\" and ruHis.colNames.size > 2) do\n    ruHisList: []\n    ruCount: ruHis.colNames.size -1\n    ruHis.removeCol(\"ts\").colNames.each colName => do\n      ruHisList= ruHisList\n        .add(ruHis.keepCols([\"ts\",colName])\n                  .findAll(row => row[colName] != null))\n    end\n    ruHisDis: hisPeriodMatrix(ruHisList)\n              .findAll(r => r->numTrue > 0)\n              .keepCols([\"ts\",\"dur\"])\n              .addColMeta(\"dur\",\n                {dis: \"Summary: \"+ruCount+\" Rules Sparked\",\n                 spark})\n  end else ruHisDis: ruHis\n  if (faults != \"Hide Faults\")\n  hisGrid= [hisGrid, ruHisDis].findAll(v => not(isEmpty(v)) and v!=null).hisJoin\n  \n  // Display active deficiencies\n  defs: viTargetsDeficiencies(\n          toolRecursiveSearch(zone->id, \"equip\"),\n          span)\n  if (defs!=null and not(isEmpty(defs))) do\n    if (faults==\"Summary Faults\" and defs.colNames.size > 2) do\n      defsList: []\n      defsCount: defs.colNames.size - 1\n      defs.removeCol(\"ts\").colNames.each colName => do\n        defsList= defsList\n          .add(defs.keepCols([\"ts\",colName])\n                   .findAll(row => row[colName] != null))\n      end\n      defsDis: hisPeriodMatrix(defsList)\n               .findAll(r => r->numTrue > 0)\n               .keepCols([\"ts\",\"dur\"])\n               .addColMeta(\"dur\",\n                 {dis: \"Summary: \"+defsCount+\" Deficiencies\",\n                  spark})\n    end else defsDis: defs.addColMeta(\"v0\", {spark})\n    if (faults != \"Hide Faults\")\n      hisGrid= hisJoin([hisGrid, defsDis])\n  end\n  \n  // Format trends\n  group: null\n  tagGroups: []\n  if (groupSelect==\"Typical Groups\") do\n    group= \"By specified tag groups\"\n    tagGroups= [\"equipRef->ahu\",\n                \"equipRef->zone and flow\"]\n    toolRecursiveSearch(zone->id, \"equip and (terminalUnit or fumeHood)\")\n    .each(tEq => do\n      tagGroups= tagGroups\n        .add(\"unit==\\\"%\\\" and (supply or equipRef==@\"+tEq->id+\")\")\n        .add(\"flow and (supply or equipRef==@\"+tEq->id+\")\")\n        .add(\"zone and air and temp and not discharge and equipRef==@\"+tEq->id)\n    end)\n    tagGroups= tagGroups.add(\"discharge and air and temp\")\n  end else\n    group= groupSelect\n  colorZones: try userOpts->colorFilters catch defaultOpts->colorFilters\n  spanFilters: try userOpts->spanFilters catch defaultOpts->spanFilters\n  hisGrid= hisGrid\n    .toolFormatTrends(group, tagGroups, colorZones, spanFilters, 2)\n  \n  return hisGrid.addMeta({title: zone.dis()+\" Trends\"})\n                .addMeta({hisStart:span.start})\n                .addMeta({hisEnd:span.end})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolFormatTrends"],,,M,"recNewToolFormatTrendsOptions",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(toolFormatTrendsOptionsDict) => do\n  // Normalize action input\n  toolFormatTrendsOptionsDict= actionNormInput(toolFormatTrendsOptionsDict, \"dict\")\n  \n  toolFormatTrendsOptionsDict= toolFormatTrendsOptionsDict\n  .set(\"username\", userCur()->username)\n\n  // If existing record, edit\n  exRec: read(toolFormatTrendsOptions and username==userCur()->username,\n              false)\n  if (exRec != null)\n    commit(diff(exRec, toolFormatTrendsOptionsDict))\n  else \n    commit(diff(null, toolFormatTrendsOptionsDict, {add}))\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolHierarchy"],,,M,"toolHierarchy",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given point or equip, return a list of ids of all the \n  records above it, including potential chain of equips, e.g.\n  [siteId, locationId, equipId, equipId, equipId]\n  \n  Arguments: \n  N/A\n*/\n\n(recId, result:[]) => do\n  if (recId==null) return [null]\n  \n  if (isRef(recId)) rec: readById(recId)\n  else rec: recId\n  \n  result= result.add(rec->id)\n  \n  if(rec.has(\"equipRef\"))\n    result= toolHierarchy(rec->equipRef, result)\n  else if(rec.has(\"locationRef\"))\n    result= toolHierarchy(rec->locationRef, result)\n  else if(rec.has(\"siteRef\"))\n    result= toolHierarchy(rec->siteRef, result)\n  else return result\n  \n  return result\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolHierarchy"],,,M,"viTargetsDeficiencies",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given list of targets (points or equips), and a given span,\n  return a timeline of deficiencies that apply at or above each\n  target.\n  \n  Arguments: \n  recsIds      List of target ids\n  span         Datespan\n*/\n\n(recsIds:[null, @p:lbnl:r:235126e0-5461ac88], span:pastMonth()) => do\n  // Input check\n  span= span.toDateSpan()\n  \n  // All records above in the equip hierarchy are valid targets\n  listTargets: []\n  recsIds.each recId =>\n    listTargets= listTargets.addAll(toolHierarchy(recId))\n  listTargets= listTargets.unique()\n  \n  // Find deficiencies that apply to any of the targets\n  deficiencies:\n    readAll(deficiency and equipRef)\n    // Filter out deficiencies not related to targets\n    .findAll(def => listTargets\n                    .any(target => target==def->equipRef))\n    // Filter out deficiencies that ended before span's start or\n    // started after span's end\n    .findAll(def => do\n      if (def.has(\"endDate\") and (def->endDate < span.start()))\n        return false\n      if (def.has(\"startDate\") and (def->startDate > span.end()))\n        return false\n      return true\n    end)\n  \n  if(isEmpty(deficiencies)) return null\n  \n  // Chart deficiencies\n  chart: {}.toGrid()\n  deficiencies.each def => do\n    dstart: if(def.has(\"startDate\")\n               and (def->startDate > span.start()))\n              def->startDate\n            else\n              span.start()\n    dend: if(def.has(\"endDate\")\n               and (def->endDate < span.end()))\n              def->endDate\n            else\n              span.end()\n    dspan: (dstart..dend).toSpan()\n    defTrend: hisSlidingWindows(dspan,1h,1h)\n              .addColMeta(\"v0\", {dis: \"Deficiency - \"+def.dis()+\" - \"+def->state,\n                                 color: \"#b3b300\",\n                                 spark})\n    if (isEmpty(chart)) chart= defTrend\n    else chart= hisJoin([chart, defTrend])\n  end\n  \n  return chart.addMeta({view:\"chart\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,[],,,M,"toolHisRollupAuto",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Similar to hisRollupAuto, with custom processing of tags\n  \n  Arguments: \n  hisGrid        Grid with ts column and value columns\n  minRollup      Number (time), specify desired rollup interval\n*/\n\n(hisGrid, minRollup:0s) => do\n  if (minRollup <= 0) return hisGrid\n  \n  // Iterate on column names\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    // his is similar to the point record\n    try do\n      his: hisGrid.col(colName).meta\n      eq: readById(his->equipRef)\n    end catch\n      return null\n      \n    // If hide tag, skip\n    if (his.has(\"hide\")) return null\n    \n    // If kind==\"Bool\" or hisMode==\"cov\", skip\n    if (his[\"kind\"]==\"Bool\" or his[\"hisMode\"]==\"cov\") return null\n    \n    // Choose rollupFunc\n    rollupFunc: avg\n    if (his.has(\"delta\") and (his.has(\"volume\") or his.has(\"energy\")))\n      rollupFunc: sum\n    \n    // Extract single his\n    tmpGrid: hisGrid.keepCols([\"ts\",colName])\n                    .findAll(row => row[colName] != null)\n                    \n    // Rollup and merge back\n    tmpGrid= tmpGrid.hisRollup(rollupFunc, minRollup)\n                    .findAll(row => row[colName] != null)\n                    .addColMeta(colName,\n                      {dis: tmpGrid.col(colName).meta.dis() +\n                            \", \"+minRollup+\" Rollup\"})\n    hisGrid= hisJoin([hisGrid.removeCol(colName), tmpGrid])\n  end\n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,[],[`io/config/ignoreTags.csv`],,M,"toolRecTags",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given record, filter out tags that match the ignoreTags list\n  and return the remaining tags\n  \n  Arguments: \n  point            Record or Ref of the point\n*/\n\n(point) => do\n  // If a Ref was provided, load corresponding record\n  if (isRef(point))\n    try point= readById(point)\n    catch return {\"point not valid\"}.toGrid()\n    \n  // Load dependencies\n  try ignoreTags: ioReadCsv(`io/config/ignoreTags.csv`)\n                  .colToList(\"ignoreTagsRegex\")\n  catch\n    return {error: \"io/config/ignoreTags.csv could not be loaded\"}.toGrid()\n\n  if (not(isDict(point)))\n    return {\"point not valid\"}.toGrid()\n    \n  allTags: point.findAll(v => v != null).names()\n  filteredTags: allTags.findAll(tag => do\n        regexMatch: false\n        ignoreTags.each regex => if (regex.reMatches(tag)) regexMatch= true\n        return not(regexMatch)\n      end)\n  \n  return filteredTags\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolRecursiveSearch"],,,M,"viZoneTrends",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all data points associated with a given zone in a given\n  building, including all points in sub-equips of that zone that\n  are not raw points, and any discharge air temp points from the\n  AHU associated with the first terminal unit of the zone. Load\n  and display historical data for all these points across the given\n  date span.\n  \n  Arguments: \n  siteStr      string, site name / dis, e.g. \"67\"\n  roomStr      string, room navName, e.g. \"Rm 1236D\"\n  dates        dateSpan, dates of data to display\n  rules        bool, whether to display result of sparkRules\n  zonePtsStr   string, filter used to customize what points to return\n               at the zone level, default \"point and not raw\"\n  ahuChartG... string, force same chartGroup for all AHU trends\n  datChartG... string, force given chartGroup for DAT trend\n*/\n\n(siteStr: \"67\", roomStr: \"Rm 1236D\", dates: yesterday(), rules: true,\n zonePtsStr: \"point and not raw\",\n ahuChartGroup: \"AHU\", datChartGroup: null) => do\n  // Attempt to find zone, exit if no zone found\n  zone: read(navName==roomStr and siteRef->dis==siteStr, false)\n  if (zone==null) return {error: \"No corresponding zone found\"}\n                         .toGrid()\n  \n  // Retrieve IDs of all points in zone or sub-equips that match\n  // string filter zonePtsStr\n  subPts: toolRecursiveSearch(zone->id,zonePtsStr)\n  \n  // Force supply terminal unit DAT chartGroup\n  subPts= subPts.map(row =>\n    if (row.has(\"discharge\") and row.has(\"temp\") and row.has(\"air\"))\n      row.set(\"chartGroup\", datChartGroup)\n    else\n      row)\n  \n  // Find a supply terminal unit associated with zone\n  supplyTU: read(supply and terminalUnit and ahuRef and equip\n                 and equipRef==zone->id, false)\n  if (supplyTU==null or supplyTU[\"ahuRef\"]==null) graphPts: subPts\n  else do\n    ahuId: supplyTU->ahuRef\n    satPts: readAll(point and his and not raw\n                    and discharge and air and (temp or pressure)\n                    and equipRef==ahuId)\n            .addCol(\"chartGroup\", row => ahuChartGroup)\n    graphPts: subPts.addRows(satPts)\n  end\n  \n  // Load trend history\n  graphHis: graphPts.hisRead(dates, {limit: null})\n  \n  // Add detected periods from sparkRules\n  if (rules) do\n    ruHis: ruleSparks(toolRecursiveSearch(zone->id, \"equip\"),\n                      dates, readAll(sparkRule))\n           .ruleSparkHis()\n    \n    graphHis= hisJoin([graphHis, ruHis])\n  end\n  \n  return graphHis\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,[],,,M,"toolHisAlign",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*  \n  Process a history grid to align timestamps of contained histories, for example\n  in preparation for a foldCols. Determine average interval for each history, \n  then select a target interval for hisRollup. Rollup using given rollupFunc. \n  Process missing (null) values based on selected option.\n  NA values are propagated. Options for null values:\n  - Show missing values with NA\n  - Remove rows with any missing values\n  If any column / trend is COV with hisMode:\"cov\" tag, return original\n  grid if minRollup is 0, or apply hisRollup at provided minRollup.\n  \n  Arguments:\n  hisGrid          History grid to process\n  rollupFunc       Func, function used for rollup\n  intervalFunc     Func, (x,y) function used to select rollup interval\n  removeMissing    Bool, if true, remove rows with any null values,\n                   else replace all null values with NA\n  minRollup        Number (time), specify minimum rollup time\n  validIntervals   List of Numbers (time), valid rollup intervals\n*/\n\n(hisGrid, rollupFunc:avg, intervalFunc:min,\n removeMissing:true, minRollup:0min,\n validIntervals:[1s, 2s, 5s, 10s, 15s, 30s,\n                 1min, 2min, 3min, 5min, 10min, 15min, 30min,\n                 1hr, 2hr, 6hr, 12hr, 24hr]) => do\n  // Initialize\n  interval: null\n  covFlag: false\n  minRollup= try minRollup.to(\"s\") catch 0s\n  \n  // Cycle through each column and determine corresponding\n  // average interval\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    subHisGrid: hisGrid.keepCols([\"ts\"].add(colName))\n                       .hisClip\n                       .findAll(row => row[colName] != null)\n    if (subHisGrid.size < 2) return null\n    tsList: subHisGrid.colToList(\"ts\")\n    avgInterval: (tsList[-1] - tsList[0]) / (tsList.size - 1)\n    avgInterval= avgInterval.to(\"s\")\n    // Check metadata for hisMode==cov\n    if (subHisGrid.col(colName).meta[\"hisMode\"]==\"cov\")\n      covFlag= true\n    // Apply intervalFunc selection function\n    interval= if (interval==null) avgInterval\n              else intervalFunc(interval, avgInterval)\n  end\n  // If minRollup > 0, apply to interval\n  if (minRollup > 0) interval= max(interval, minRollup)\n  \n  // If some histories are COV and minRollup is specified,\n  // simply rollup at minRollup\n  if (covFlag and minRollup > 0)\n    hisGrid= hisGrid.hisRollup(rollupFunc, minRollup)\n  // Else if any history is COV and minRollup isn't specified, or if\n  // no interval was found do not rollup\n  else if (covFlag or interval==null or interval==0)\n    hisGrid= hisGrid\n  // Else select closest valid interval from validIntervals and rollup\n  else do\n    distF: (x,y) => abs(x.to(\"s\") - y.to(\"s\")).as(1)\n    finalInterval: validIntervals\n      .sort((a,b) => distF(a,interval) <=> distF(b,interval))\n      .first\n    \n    // Perform rollup\n    hisGrid= hisGrid.hisRollup(rollupFunc, finalInterval)\n  end\n  \n  // Process missing data\n  if (removeMissing)\n    hisGrid= hisGrid.findAll(row => row.all(v => v != null))\n  else // Show missing values with NA\n    hisGrid= hisGrid.hisMap(v => if (v==null) na() else v)\n\n  return hisGrid\nend\n\n/*\n  Updates\n  2020-01-21  Raphael Vitti\n    Added default rollup of cov series if minRollup is provided.\n*/",
,["toolRecTags"],,,M,"toolFormatTrends",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Takes in a history grid and applies additional grouping, colors, width\n  \n  Arguments: \n  hisGrid        History grid\n  group          Str, describes grouping methodology, see enum below\n  tagGroups      Str[], used with group==\"By specified tag groups\"\n                   list of tag filters to group points together\n  colorFilters   Str[], list of color filters, see default below\n  spanFilters    Str[], list of chart min/max filters, see default below\n  width          Number, override strokeWidth if not zero\n  chartMin       Number, if not null, add corresponding chartMin to all trends\n\n  group enum: \"By unit, By equip, By equip and unit, By tags,\n               By equip and tags, By specified tag groups\"\n*/\n\n(hisGrid, group, tagGroups:[], colorFilters:null, spanFilters:null,\n width:0, chartMin:null) => do\n  // Default color filters if null passed as argument\n  if (colorFilters==null)\n    // Default colors\n    colorFilters= [\"outside and air:forestgreen\",\n                   \"return and air:red\",\n                   \"discharge and air and equipRef->ahu:deepskyblue\",\n                   \"(mixed or recovery) and air:blueviolet\",\n                   \"exhaust and air:grey\",\n                   \"cool and valve:dodgerblue\",\n                   \"heat and valve:firebrick\",\n                   \"sp:black\"]\n                   \n  // Default chart min/max\n  if (spanFilters==null)\n    spanFilters= [\"unit==\\\"%\\\" and cmd:0%,100%\",\n                  \"zone and air and temp:50°F,90°F\"]\n  \n  // Apply display units\n  hisGrid= hisGrid.hisMap((val,ts,his) => do\n    if(his.has(\"chartUnit\")) val.to(his[\"chartUnit\"])\n    else val\n  end)\n\n\n  // Cycle through history columns and apply grouping and colors\n  hisGrid.colNames.remove(0).each colName => do\n    his: hisGrid.col(colName).meta\n    // Remove weatherPoint tag to allow grouping of weather station points\n    hisGrid= hisGrid.addColMeta(colName, {-weatherPoint})\n    \n    // chartGroup overrides\n    if (group==\"By navName\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->navName\n                       catch null})\n    \n    if (group==\"By unit\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:null})\n      \n    if (group==\"By equip\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->equipRef.toStr()\n                       catch null})\n                                                \n    if (group==\"By equip and unit\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->equipRef.toStr()+his->unit\n                       catch null})\n                                                \n    if (group==\"By tags\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:\n          try toolRecTags(his)\n              .findAll(v => not([\"sensor\",\"sp\",\"cmd\"].contains(v)))\n              .sort().concat(\"_\")\n          catch null})\n        \n    if (group==\"By equip and tags\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:\n          try his->equipRef.toStr()+toolRecTags(his)\n              .findAll(v => not([\"sensor\",\"sp\",\"cmd\"].contains(v)))\n              .sort().concat(\"_\")\n          catch null})\n          \n    if (group==\"By specified tag groups\" and his[\"kind\"]==\"Number\"\n        and tagGroups != null and not(isEmpty(tagGroups))) do\n      tagGroups.each tagGrp => do\n        try if (not(isEmpty([his].findAll(filterToFunc(tagGrp.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {chartGroup: tagGrp.toTagName()})\n        catch null\n      end\n    end\n    \n    // Color overrides\n    colorFilters.each colorFilter => do\n      color: colorFilter.split(\":\")[1]\n      filter: colorFilter.split(\":\")[0]\n      try if (not(isEmpty([his].findAll(filterToFunc(filter.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {color: color})\n        catch null\n    end\n    \n    // Span overrides\n    spanFilters.each spanFilter => do\n      disSpan: spanFilter.split(\":\")[1]\n      chartMin: try disSpan.split(\",\")[0].parseNumber() catch null\n      chartMax: try disSpan.split(\",\")[1].parseNumber() catch null\n      filter: spanFilter.split(\":\")[0]\n      try if (not(isEmpty([his].findAll(filterToFunc(filter.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {chartMin: chartMin,\n             chartMax: chartMax})\n        catch null\n    end\n    \n    // Override width if greater than zero\n    if (width>0)\n      hisGrid= hisGrid.addColMeta(colName,\n                 {strokeWidth: width})\n    \n    // Add chartMin if provided\n    if (isNumber(chartMin) and his.has(\"unit\"))\n      hisGrid= hisGrid.addColMeta(colName,\n                 {chartMin: chartMin.as(his->unit)})\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-24  Raphael Vitti\n    Added chartMin input and block of code to add chartMin to trends.\n  2020-03-30  Raphael Vitti\n    Added unit to chartMin, and chartMin doesn't apply if his has no unit.\n*/",
,["toolRecursiveSearch"],,,M,"toolRecursiveSearch",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all records that match the given filter string and that have\n  an equipRef (or other specified ref) located at or below the given\n  equipRef (called trunkRef)\n  e.g. allows to find all the power sensors in a high-level equipment\n  such as a cooling tower, even if the power sensors are located\n  under the cooling tower fans.\n  \n  Example use:\n  toolRecursiveSearch(@p:lbnl:r:2322ffa1-a7bd7110, \"power and sensor\")\n  \n  Return grid similar to readAll\n  \n  Arguments: \n  trunkRef         Ref to an equip to search under\n  filterStr        String that will be parsed as filter\n  refTypes         List of strings, refs to follow (e.g. equipRef)\n  maxDepth         Number, stop after given number of iterations\n*/\n\n(trunkRef, filterStr: \"point\",\n refTypes:[\"locationRef\",\"equipRef\", \"zoneRef\"],\n nodeTypes: [\"location\",\"equip\",\"zone\"],\n maxDepth:10) => do\n  // Build filter to follow provided refTypes\n  refsStr: \"(\" + refTypes.map(v => v+\"==@\"+trunkRef).concat(\" or \") + \")\"\n  // Build complete filter including point filter string\n  filterStrLoc: \"(\" + filterStr + \") and \" + refsStr\n  grid: readAll(parseFilter(filterStrLoc))\n  \n  // Find other nodes pointing to current trunkRef\n  nodesStr: \"(\" + nodeTypes.concat(\" or \") + \")\"\n  nodeFilterStr: nodesStr + \" and \" + refsStr\n  nodeList: readAll(parseFilter(nodeFilterStr))\n  if (isEmpty(nodeList) or maxDepth==0)\n    if (isEmpty(grid)) return grid else return grid.unique(\"id\")\n  else do\n    nodeList.each node => do\n      newRows: toolRecursiveSearch(node->id, filterStr, refTypes, nodeTypes, maxDepth-1)\n      if (not(isEmpty(newRows))) grid = grid.addRows(newRows)\n    end\n  end\n  if (isEmpty(grid)) return grid else return grid.unique(\"id\")\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n  2020-04-10  Raphael Vitti\n    Fixed usage of refTypes.\n    Added nodeTypes and corresponding processing.\n    Added unique(\"id\") to filter out doubles produced by various node refs.\n*/",
,["toolHisAlign","toolRecTags"],,,M,"toolHisFoldColsByTags",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Simplifies a history grid by folding together all the histories\n  that share the exact same set of identifying tags and which\n  corresponding equips also share the exact same set of tags. Only\n  the columns that also match the provided tags filter get folded.\n  Returns a new grid with the new folded column and all \n  other unmatched columns.\n  \n  Arguments: \n  hisGrid        Grid with ts column and value columns\n  tagsFilter     String, process only the points that match filter\n  foldFunc       Func, function to use for folding columns\n  rollupFunc     Func, function to use for rollup\n  minRollup      Number (time), pass to hisAlign to specify minimum\n                 desired rollup interval\n  removeMissing  Bool, if true, remove rows with any null values,\n                 else replace all null values with NA\n*/\n\n(hisGrid, tagsFilter:\"flow\", foldFunc:sum,\n rollupFunc:avg, minRollup:0s, removeMissing:true) => do\n  // Iterate on column names\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    // his is similar to the point record\n    try do\n      his: hisGrid.col(colName).meta\n      eq: readById(his->equipRef)\n    end catch\n      return null\n      \n    // If \"hide\" tag is detected, skip to next column\n    if (his.has(\"hide\") or his.has(\"foldedByTags\")) return null\n    filterFunc: filterToFunc(tagsFilter.parseFilter)\n    if (not(filterFunc(his))) return null\n    \n    // tagSet is a list of identifying tags for the point\n    tagSet: toolRecTags(his)\n            .addAll(toolRecTags(eq))\n            .sort\n    \n    // Find all other columns with the same set of tags\n    groupCols: hisGrid.colNames.findAll(colName2 => do\n      try do\n        his2: hisGrid.col(colName2).meta\n        eq2: readById(his2->equipRef)\n      catch\n        return false\n      \n      // Retrieve point and equip tags and test equality\n      tagSet2: toolRecTags(his2)\n               .addAll(toolRecTags(eq2))\n               .sort\n      return (tagSet == tagSet2)\n    end)\n    \n    // Skip if there is only one history\n    if (groupCols.size < 2) return null\n    \n    // Create temporary grid with only ts and selected cols\n    tGrid: hisGrid.keepCols([\"ts\"].addAll(groupCols))\n    totCount: groupCols.size\n    \n    // Remove empty rows\n    tGrid= tGrid.findAll(row => row.remove(\"ts\").any(v => v != null))\n    \n    interpolateDis: false\n    // Check hisMode for COV\n    if (his[\"hisMode\"]==\"cov\" and his[\"kind\"]==\"Bool\")\n      // Typical COV data, interpolate instead of rolling up\n      tGrid= tGrid.hisInterpolate()\n    else if (his[\"hisMode\"]==\"cov\" and his[\"kind\"]!=\"Bool\") do\n      // Atypical COV data, interpolate and flag\n      tGrid= tGrid.hisInterpolate()\n      interpolateDis= true\n    end else\n      // Else align timestamps / rollup with rollupFunc\n      tGrid= tGrid.toolHisAlign(rollupFunc,     // rollupFunc\n                                min,            // intervalFunc\n                                removeMissing,  // removeMissing\n                                minRollup)      // minRollup\n          \n    // Fold using foldFunc\n    tGrid= tGrid\n           .hisFoldCols(foldFunc)\n           \n    // Add relevant metadata: display name and identifying tags\n    foldFuncStr: if (foldFunc==sum) \"Sum\"\n                 else if (foldFunc==avg) \"Average\"\n                 else if (foldFunc==min) \"Min\"\n                 else if (foldFunc==max) \"Max\"\n                 else reGroups(r\"(fold)?(.*)\\(.*\\).*\", foldFunc.toStr)[2]\n    eqType: try reGroups(r\"([A-Za-z0-9 ,]*?)((,| |-)+\\d+[[:alpha:]]?)+\", eq->navName)[1] + \" \"\n            catch \"\"\n    ptName: try reGroups(r\"(( ?[A-Za-z])+)( \\\\(.*\\\\))?\", his->navName)[1]\n            catch his->navName\n    dis: capitalize(foldFuncStr) + \" of \" + totCount + \" \"\n         + eqType + ptName + \"(s)\" \n    if (tGrid.meta[\"hisRollupInterval\"] > 0)\n      dis= dis + \", \" + tGrid.meta[\"hisRollupInterval\"] + \" Rollup\"\n    if (interpolateDis)\n      dis= dis + \", interpolated\"\n    colMetaDict: {dis: dis}\n    tGrid= tGrid.addColMeta(\"v0\",\n      {dis: dis,\n      kind: his[\"kind\"],\n      unit: his[\"unit\"],\n      enum: his[\"enum\"],\n      foldedByTags: marker(),\n      hisMode: his[\"hisMode\"],\n      hisRollupInterval: tGrid.meta[\"hisRollupInterval\"],\n      hisRollupDis: tGrid.meta[\"hisRollupDis\"]})\n    // Add point and equip tags\n    tagSet.each tag =>\n      tGrid= tGrid.addColMeta(\"v0\", {}.set(tag, marker()))\n      \n    // Join with main grid\n    hisGrid= hisJoin([hisGrid, tGrid])\n    \n    // Mark all original column with \"hide\" tag\n    groupCols.each colName2 => do\n      hisGrid= hisGrid.addColMeta(colName2, {hide})\n    end\n  end\n  \n  // Remove all columns with \"hide\" tag\n  hisGrid.removeCol(\"ts\").colNames.each colName => do\n    // his is similar to the point record\n    his: hisGrid.col(colName).meta\n    \n    // Remove column if it has \"hide\" tag\n    if (his.has(\"hide\")) hisGrid= hisGrid.removeCol(colName)\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n  2020-04-10  Raphael Vitti\n    Added foldFuncStr specific to functions sum, avg, min and max.\n*/",
,[],,,M,"foldAny",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  if (val == foldStart()) return {status:false}\n  if (val == foldEnd()) return acc[\"status\"]\n  if (val == na() or acc[\"status\"]==na()) return {status:na()}\n  if (val == null) return acc\n  return {status: acc->status or val}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["foldSample"],,,M,"toolHisGridShowGaps",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given history grid, detect data gaps longer than the\n  given threshold and insert NA() value to show gap.\n  \n  Arguments:\n  hisGrid         History grid to analyze\n  maxGap          Number (time), longest allowed gap between readings\n  tagsFilter      Only highlight gaps in points that match filter\n*/\n\n(hisGrid, maxGap:1min,\n tagsFilter:\"(not hisMode or hisMode!=\\\"cov\\\") and kind==\\\"Number\\\"\") => do\n  // Create filter from tagsFilter string\n  filterFunc: filterToFunc(tagsFilter.parseFilter)\n  \n  // Determine selected grid and remaining grid\n  selColNames: hisGrid.removeCol(\"ts\").colNames\n               // Only highlight gaps in points that match filter\n               .findAll(colName =>\n                 filterFunc(hisGrid.col(colName).meta))\n               // Unselect columns with only null or na() values\n               .findAll(colName =>\n                 hisGrid.colToList(colName)\n                        .any v => (v != null and v != na()))\n  // Selected grid is the grid in which data gaps will be analyzed\n  selGrid: hisGrid.keepCols([\"ts\"].addAll(selColNames))\n                  .findAll(row => row.remove(\"ts\").any(v => v!= null))\n  // Remaining grid columns will be passed through \"as is\"\n  remGrid: hisGrid.removeCols(selColNames)\n                  .findAll(row => row.remove(\"ts\").any(v => v!= null))\n\n  // Add NAN for detected gaps in selected grid\n  nanGrid: selGrid\n           .hisRollup(foldSample, maxGap)\n           .map(row => row.map((val, name) =>\n               if (name==\"ts\") return val\n               else if (val==null) return na()\n               else return val))\n           .findAll(row => row.any(v => v==na()))\n  selGrid= selGrid\n           .addRows(nanGrid)\n           // After adding NaN rows, resort by chronological order\n           .sort((a,b) => a[\"ts\"] <=> b[\"ts\"])\n  selGrid= selGrid.reorderCols(selGrid.colNames.moveTo(\"ts\",0))\n  \n  // Merge selected and remaining grids back and return\n  return hisJoin([selGrid,remGrid])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",

