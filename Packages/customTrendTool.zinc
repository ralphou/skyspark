ver:"3.0"
appName,depends,dependsFiles,dis,func,name,order,src,view
,[],,,M,"foldSample",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n(val, acc) => do\n  if (val == foldStart()) return {v0: null}\n  if (val == foldEnd()) return acc[\"v0\"]\n  if (val == na() or acc[\"v0\"]==na()) return {v0: na()}\n  if (val == null) return acc\n  return {v0: val}\nend\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolHierarchy"],,,M,"toolHierarchy",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given point or equip, return a list of ids of all the \n  records above it, including potential chain of equips, e.g.\n  [siteId, locationId, equipId, equipId, equipId]\n  \n  Arguments: \n  N/A\n*/\n\n(recId, result:[]) => do\n  if (recId==null) return [null]\n  \n  if (isRef(recId)) rec: readById(recId)\n  else rec: recId\n  \n  result= result.add(rec->id)\n  \n  if(rec.has(\"equipRef\"))\n    result= toolHierarchy(rec->equipRef, result)\n  else if(rec.has(\"locationRef\"))\n    result= toolHierarchy(rec->locationRef, result)\n  else if(rec.has(\"siteRef\"))\n    result= toolHierarchy(rec->siteRef, result)\n  else return result\n  \n  return result\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolHierarchy"],,,M,"viTargetsDeficiencies",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given list of targets (points or equips), and a given span,\n  return a timeline of deficiencies that apply at or above each\n  target.\n  \n  Arguments: \n  recsIds      List of target ids\n  span         Datespan\n*/\n\n(recsIds:[null, @p:lbnl:r:235126e0-5461ac88], span:pastMonth()) => do\n  // Input check\n  span= span.toDateSpan()\n  \n  // All records above in the equip hierarchy are valid targets\n  listTargets: []\n  recsIds.each recId =>\n    listTargets= listTargets.addAll(toolHierarchy(recId))\n  listTargets= listTargets.unique()\n  \n  // Find deficiencies that apply to any of the targets\n  deficiencies:\n    readAll(deficiency and equipRef)\n    // Filter out deficiencies not related to targets\n    .findAll(def => listTargets\n                    .any(target => target==def->equipRef))\n    // Filter out deficiencies that ended before span's start or\n    // started after span's end\n    .findAll(def => do\n      if (def.has(\"endDate\") and (def->endDate < span.start()))\n        return false\n      if (def.has(\"startDate\") and (def->startDate > span.end()))\n        return false\n      return true\n    end)\n  \n  if(isEmpty(deficiencies)) return null\n  \n  // Chart deficiencies\n  chart: {}.toGrid()\n  deficiencies.each def => do\n    dstart: if(def.has(\"startDate\")\n               and (def->startDate > span.start()))\n              def->startDate\n            else\n              span.start()\n    dend: if(def.has(\"endDate\")\n               and (def->endDate < span.end()))\n              def->endDate\n            else\n              span.end()\n    dspan: (dstart..dend).toSpan()\n    defTrend: hisSlidingWindows(dspan,1h,1h)\n              .addColMeta(\"v0\", {dis: \"Deficiency - \"+def.dis()+\" - \"+def->state,\n                                 color: \"#b3b300\",\n                                 spark})\n    if (isEmpty(chart)) chart= defTrend\n    else chart= hisJoin([chart, defTrend])\n  end\n  \n  return chart.addMeta({view:\"chart\"})\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
"his",["viFormattedTrends"],,"Chart - Custom",,,2,"view: {inherit:\"chart\"}\ntargets: {var kind:\"Ref<point>[]\" input navSelAnyRec}\nspan: {var kind:\"Span\" input defExpr:\"(today()-3day..today()-1day).toSpan()\"}\nrollupMinutes: {var kind:\"Number\" input defVal:0 unitless}\nuiViewBar: {var kind:\"Dict\" defVal:{} showVarLabels:T}\ngroup: {var enum:\"By unit,By equip,By equip and unit,By tags,By equip and tags,By specified tag groups,By navName\" kind:\"Str\" input defVal:\"By tags\"}\ntagGroups: {var kind:\"Str[]\" input defExpr:\"[\\\"zone and air and temp\\\"]\"}\ncolors: {var enum:\"Basic,Default\" kind:\"Str\" input defVal:\"Basic\"}\nwidth: {var kind:\"Number\" defVal:2 unitless}\nmaxSamples: {var enum:\"5000,10000,20000,50000,100000,250000\" kind:\"Str\" input defVal:\"20000\"}\ndeficiencies: {var enum:\"Show deficiencies,Show sparks,Show deficiencies and sparks,Hide all\" kind:\"Str\" input defVal:\"Show deficiencies\"}\ngaps:{var kind:\"Str\" input defVal:\"Show Gaps > 15min\" enum:\"Hide Gaps,Show Gaps > 15min,Show Gaps > 30min,Show Gaps > 1hr\"}\nchartMinStr:{var kind:\"Str\" input defVal:\"No Minimum\" enum:\"No Minimum,Minimum 0,Minimum 1\"}\ndata: {expr:\"viFormattedTrends(null,{{targets}},{{span}},{{rollupMinutes}},{{group}},{{tagGroups}},if({{colors}}==\\\"Basic\\\") null else [],{{width}},{{maxSamples}}.parseNumber,if({{deficiencies}}==\\\"Show deficiencies\\\" or {{deficiencies}}==\\\"Show deficiencies and sparks\\\") true else false, if({{deficiencies}}==\\\"Show sparks\\\" or {{deficiencies}}==\\\"Show deficiencies and sparks\\\") true else false,try reGroups(r\\\"Show Gaps > (\\\\d+[a-zA-Z]+)\\\", {{gaps}})[1].parseNumber() catch 0,{{chartMinStr}})\"}\n","trendsTool"
,["toolFormatTrends","toolHisGridShowGaps","viTargetsDeficiencies","toolRecursiveSearch"],,,M,"viFormattedTrends",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Displays trends for selected equipment and points, with formatting.\n  \n  Arguments:\n  equipRef       Ref to an equip, if provided display trends of all its points\n  pointsRefs     list of point IDs or point recs, display history for those points\n  span           period to display\n  rollup         time rollup to use for all trends\n  group          Str, see function toolFormatTrends for details\n  tagGroups      Str[], list of tag filters, see toolFormatTrends\n  colorFilter    Str[], list of color filters\n  width          Number, override strokeWidth if not zero\n  limit          Number, limit of number of points per trend to load\n  deficiencies   Bool, whether to show deficiencies on graph\n  rules          Bool, whether to display results of sparkrules\n  gaps           Number, if > 0 show gaps greater than provided time\n  chartMinStr    Str, \"No Minimum,Minimum 0,Minimum 1\"\n*/\n\n(equipRef:null, refsList:[], span:today()-3day..today()-1day, rollup:0,\n group:\"Default\", tagGroups:[], colorFilters:null, width:0,\n limit:null, deficiencies:true, rules:true, gaps:0min, chartMinStr:null) => do\n  if (refsList==null) refsList=[]\n  \n  gridE: try toolRecursiveSearch(equipRef, \"point and his\")\n         catch {}.toGrid()\n  \n  gridP: {}.toGrid()\n  refsList.each ref => do\n    rec: readById(ref)\n    if (rec.has(\"site\")) null\n    if (rec.has(\"location\")) null\n    if (rec.has(\"equip\")) gridP= gridP.addRows(toolRecursiveSearch(ref, \"point and his\"))\n    if (rec.has(\"point\")) gridP= gridP.addRow(rec)\n  end\n         \n  gridA: if(isEmpty(gridP)) gridE else gridE.addRows(gridP)\n  grid: gridA.hisRead(span, {limit:limit})\n\n  if (rollup != 0)\n    try grid= grid.hisRollupAuto(rollup.to(\"min\"))\n    catch return {error: \"Invalid rollup parameter\"}.toGrid()\n\n  // Process chartMinStr\n  chartMin: if(chartMinStr==\"Minimum 0\") 0\n            else if(chartMinStr==\"Minimum 1\") 1\n            else null\n\n  // Format trends\n  grid= grid.toolFormatTrends(group, tagGroups, colorFilters, [], width, chartMin)\n  // Show gaps\n  if (isNumber(gaps) and gaps>0)\n    grid= grid.toolHisGridShowGaps(gaps)\n\n  // Display active deficiencies\n  if (deficiencies) do\n    defs: viTargetsDeficiencies(gridA.colToList(\"id\"), span)\n    if (defs!=null and not(isEmpty(defs)))\n      grid= hisJoin([grid, defs])\n  end\n  \n  // Display active sparkRules results\n  if (rules) do\n    targets: [equipRef]\n    refsList.each ptRef =>\n      targets= targets.add(readById(ptRef)[\"equipRef\"])\n    targets= targets.findAll(v => v!= null).unique()\n    \n    ruHis: ruleSparks(targets, span, readAll(sparkRule))\n           .ruleSparkHis()\n    \n    grid= hisJoin([grid, ruHis])\n  end\n\n  return grid\nend\n\n/*\n  Updates\n  2020-03-17  Raphael Vitti\n    Added gaps input and toolHisGridShowGaps processing.\n  2020-03-24  Raphael Vitti\n    Added chartMinStr and related processing to cap display minimum\n*/",
,[],[`io/config/ignoreTags.csv`],,M,"toolRecTags",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given record, filter out tags that match the ignoreTags list\n  and return the remaining tags\n  \n  Arguments: \n  point            Record or Ref of the point\n*/\n\n(point) => do\n  // If a Ref was provided, load corresponding record\n  if (isRef(point))\n    try point= readById(point)\n    catch return {\"point not valid\"}.toGrid()\n    \n  // Load dependencies\n  try ignoreTags: ioReadCsv(`io/config/ignoreTags.csv`)\n                  .colToList(\"ignoreTagsRegex\")\n  catch\n    return {error: \"io/config/ignoreTags.csv could not be loaded\"}.toGrid()\n\n  if (not(isDict(point)))\n    return {\"point not valid\"}.toGrid()\n    \n  allTags: point.findAll(v => v != null).names()\n  filteredTags: allTags.findAll(tag => do\n        regexMatch: false\n        ignoreTags.each regex => if (regex.reMatches(tag)) regexMatch= true\n        return not(regexMatch)\n      end)\n  \n  return filteredTags\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["toolRecTags"],,,M,"toolFormatTrends",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Takes in a history grid and applies additional grouping, colors, width\n  \n  Arguments: \n  hisGrid        History grid\n  group          Str, describes grouping methodology, see enum below\n  tagGroups      Str[], used with group==\"By specified tag groups\"\n                   list of tag filters to group points together\n  colorFilters   Str[], list of color filters, see default below\n  spanFilters    Str[], list of chart min/max filters, see default below\n  width          Number, override strokeWidth if not zero\n  chartMin       Number, if not null, add corresponding chartMin to all trends\n\n  group enum: \"By unit, By equip, By equip and unit, By tags,\n               By equip and tags, By specified tag groups\"\n*/\n\n(hisGrid, group, tagGroups:[], colorFilters:null, spanFilters:null,\n width:0, chartMin:null) => do\n  // Default color filters if null passed as argument\n  if (colorFilters==null)\n    // Default colors\n    colorFilters= [\"outside and air:forestgreen\",\n                   \"return and air:red\",\n                   \"discharge and air and equipRef->ahu:deepskyblue\",\n                   \"(mixed or recovery) and air:blueviolet\",\n                   \"exhaust and air:grey\",\n                   \"cool and valve:dodgerblue\",\n                   \"heat and valve:firebrick\",\n                   \"sp:black\"]\n                   \n  // Default chart min/max\n  if (spanFilters==null)\n    spanFilters= [\"unit==\\\"%\\\" and cmd:0%,100%\",\n                  \"zone and air and temp:50°F,90°F\"]\n  \n  // Apply display units\n  hisGrid= hisGrid.hisMap((val,ts,his) => do\n    if(his.has(\"chartUnit\")) val.to(his[\"chartUnit\"])\n    else val\n  end)\n\n\n  // Cycle through history columns and apply grouping and colors\n  hisGrid.colNames.remove(0).each colName => do\n    his: hisGrid.col(colName).meta\n    // Remove weatherPoint tag to allow grouping of weather station points\n    hisGrid= hisGrid.addColMeta(colName, {-weatherPoint})\n    \n    // chartGroup overrides\n    if (group==\"By navName\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->navName\n                       catch null})\n    \n    if (group==\"By unit\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:null})\n      \n    if (group==\"By equip\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->equipRef.toStr()\n                       catch null})\n                                                \n    if (group==\"By equip and unit\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName,\n          {chartGroup: try his->equipRef.toStr()+his->unit\n                       catch null})\n                                                \n    if (group==\"By tags\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:\n          try toolRecTags(his)\n              .findAll(v => not([\"sensor\",\"sp\",\"cmd\"].contains(v)))\n              .sort().concat(\"_\")\n          catch null})\n        \n    if (group==\"By equip and tags\" and his[\"kind\"]==\"Number\")\n      hisGrid= hisGrid.addColMeta(colName, {chartGroup:\n          try his->equipRef.toStr()+toolRecTags(his)\n              .findAll(v => not([\"sensor\",\"sp\",\"cmd\"].contains(v)))\n              .sort().concat(\"_\")\n          catch null})\n          \n    if (group==\"By specified tag groups\" and his[\"kind\"]==\"Number\"\n        and tagGroups != null and not(isEmpty(tagGroups))) do\n      tagGroups.each tagGrp => do\n        try if (not(isEmpty([his].findAll(filterToFunc(tagGrp.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {chartGroup: tagGrp.toTagName()})\n        catch null\n      end\n    end\n    \n    // Color overrides\n    colorFilters.each colorFilter => do\n      color: colorFilter.split(\":\")[1]\n      filter: colorFilter.split(\":\")[0]\n      try if (not(isEmpty([his].findAll(filterToFunc(filter.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {color: color})\n        catch null\n    end\n    \n    // Span overrides\n    spanFilters.each spanFilter => do\n      disSpan: spanFilter.split(\":\")[1]\n      chartMin: try disSpan.split(\",\")[0].parseNumber() catch null\n      chartMax: try disSpan.split(\",\")[1].parseNumber() catch null\n      filter: spanFilter.split(\":\")[0]\n      try if (not(isEmpty([his].findAll(filterToFunc(filter.parseFilter)))))\n          hisGrid= hisGrid.addColMeta(colName,\n            {chartMin: chartMin,\n             chartMax: chartMax})\n        catch null\n    end\n    \n    // Override width if greater than zero\n    if (width>0)\n      hisGrid= hisGrid.addColMeta(colName,\n                 {strokeWidth: width})\n    \n    // Add chartMin if provided\n    if (isNumber(chartMin) and his.has(\"unit\"))\n      hisGrid= hisGrid.addColMeta(colName,\n                 {chartMin: chartMin.as(his->unit)})\n  end\n  \n  return hisGrid\nend\n\n/*\n  Updates\n  2020-03-24  Raphael Vitti\n    Added chartMin input and block of code to add chartMin to trends.\n  2020-03-30  Raphael Vitti\n    Added unit to chartMin, and chartMin doesn't apply if his has no unit.\n*/",
,["toolRecursiveSearch"],,,M,"toolRecursiveSearch",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  Find all records that match the given filter string and that have\n  an equipRef (or other specified ref) located at or below the given\n  equipRef (called trunkRef)\n  e.g. allows to find all the power sensors in a high-level equipment\n  such as a cooling tower, even if the power sensors are located\n  under the cooling tower fans.\n  \n  Example use:\n  toolRecursiveSearch(@p:lbnl:r:2322ffa1-a7bd7110, \"power and sensor\")\n  \n  Return grid similar to readAll\n  \n  Arguments: \n  trunkRef         Ref to an equip to search under\n  filterStr        String that will be parsed as filter\n  refTypes         List of strings, refs to follow (e.g. equipRef)\n  maxDepth         Number, stop after given number of iterations\n*/\n\n(trunkRef, filterStr: \"point\", refTypes:[\"equipRef\", \"zoneRef\"],\n maxDepth:10) => do\n  filterStrLoc: \"(\" + filterStr + \") and equipRef->id==@\" + toStr(trunkRef)\n  grid: readAll(parseFilter(filterStrLoc))\n  \n  // Find other equips pointing to current trunkRef\n  eqRefsStr: refTypes.map(v => v+\"==\"+trunkRef).concat(\" or \")\n  eqFilterStr: \"equip and \" + eqRefsStr\n  eqList: readAll(equip and equipRef==trunkRef)\n  if (isEmpty(eqList) or maxDepth==0) return grid\n  else do\n    eqList.each subeq => do\n      newRows: toolRecursiveSearch(subeq->id, filterStr, refTypes, maxDepth-1)\n      if (not(isEmpty(newRows))) grid = grid.addRows(newRows)\n    end\n  end\n  return grid\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",
,["foldSample"],,,M,"toolHisGridShowGaps",,"/*\n  Copyright 2020 Raphael Vitti\n  \n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n/*\n  For a given history grid, detect data gaps longer than the\n  given threshold and insert NA() value to show gap.\n  \n  Arguments:\n  hisGrid         History grid to analyze\n  maxGap          Number (time), longest allowed gap between readings\n  tagsFilter      Only highlight gaps in points that match filter\n*/\n\n(hisGrid, maxGap:1min,\n tagsFilter:\"(not hisMode or hisMode!=\\\"cov\\\") and kind==\\\"Number\\\"\") => do\n  // Create filter from tagsFilter string\n  filterFunc: filterToFunc(tagsFilter.parseFilter)\n  \n  // Determine selected grid and remaining grid\n  selColNames: hisGrid.removeCol(\"ts\").colNames\n               // Only highlight gaps in points that match filter\n               .findAll(colName =>\n                 filterFunc(hisGrid.col(colName).meta))\n               // Unselect columns with only null or na() values\n               .findAll(colName =>\n                 hisGrid.colToList(colName)\n                        .any v => (v != null and v != na()))\n  // Selected grid is the grid in which data gaps will be analyzed\n  selGrid: hisGrid.keepCols([\"ts\"].addAll(selColNames))\n                  .findAll(row => row.remove(\"ts\").any(v => v!= null))\n  // Remaining grid columns will be passed through \"as is\"\n  remGrid: hisGrid.removeCols(selColNames)\n                  .findAll(row => row.remove(\"ts\").any(v => v!= null))\n\n  // Add NAN for detected gaps in selected grid\n  nanGrid: selGrid\n           .hisRollup(foldSample, maxGap)\n           .map(row => row.map((val, name) =>\n               if (name==\"ts\") return val\n               else if (val==null) return na()\n               else return val))\n           .findAll(row => row.any(v => v==na()))\n  selGrid= selGrid\n           .addRows(nanGrid)\n           // After adding NaN rows, resort by chronological order\n           .sort((a,b) => a[\"ts\"] <=> b[\"ts\"])\n  selGrid= selGrid.reorderCols(selGrid.colNames.moveTo(\"ts\",0))\n  \n  // Merge selected and remaining grids back and return\n  return hisJoin([selGrid,remGrid])\nend\n\n/*\n  Updates\n  2020-03-30  Raphael Vitti\n    Added copyright and license information.\n*/",

